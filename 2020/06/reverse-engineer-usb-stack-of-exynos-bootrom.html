
<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="https://fredericb.info/theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="https://fredericb.info/theme/pygments/github.min.css">
  <link rel="stylesheet" type="text/css" href="https://fredericb.info/theme/font-awesome/css/font-awesome.min.css">


    <link href="https://fredericb.info/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="fred's notes Atom">


    <link rel="shortcut icon" href="/resources/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/resources/favicon.ico" type="image/x-icon">


  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="" />


<meta name="author" content="Frédéric" />
<meta name="description" content="In the previous post, we explained how to dump Exynos bootROM. Exynos (8895 in this post) bootROM contains a minimal USB stack to load a signed bootloader from an USB host (a.k.a. boot from USB). This post summarizes how this USB stack can be reversed using the Great …" />
<meta name="keywords" content="arm, exynos, samsung, bootrom, usb, reverse, ghidra">

<meta property="og:site_name" content="fred's notes"/>
<meta property="og:title" content="Reverse engineer USB stack of Exynos BootROM"/>
<meta property="og:description" content="In the previous post, we explained how to dump Exynos bootROM. Exynos (8895 in this post) bootROM contains a minimal USB stack to load a signed bootloader from an USB host (a.k.a. boot from USB). This post summarizes how this USB stack can be reversed using the Great …"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="https://fredericb.info/2020/06/reverse-engineer-usb-stack-of-exynos-bootrom.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2020-06-16 00:00:00-07:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="https://fredericb.info/author/frederic.html">
<meta property="article:section" content="Article"/>
<meta property="article:tag" content="arm"/>
<meta property="article:tag" content="exynos"/>
<meta property="article:tag" content="samsung"/>
<meta property="article:tag" content="bootrom"/>
<meta property="article:tag" content="usb"/>
<meta property="article:tag" content="reverse"/>
<meta property="article:tag" content="ghidra"/>
<meta property="og:image" content="/resources/sitelogo.jpg">

  <title>fred's notes &ndash; Reverse engineer USB stack of Exynos BootROM</title>

</head>
<body>
  <aside>
    <div>
      <a href="/">
        <img src="/resources/sitelogo.jpg" alt="fred's notes" title="fred's notes">
      </a>
      <h1><a href="/">fred's notes</a></h1>

<p>Security & Stuff</p>
      <nav>
        <ul class="list">
          <li><a href="https://fredericb.info/category/advisory.html">Advisory</a></li>
          <li><a href="https://fredericb.info/category/article.html">Article</a></li>
          <li><a href="https://fredericb.info/category/tool.html">Tool</a></li>
          <li><a href="https://fredericb.info/pages/contact.html#contact">Contact</a></li>

        </ul>
      </nav>

      <ul class="social">
        <li><a class="sc-github" href="https://github.com/frederic" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-linkedin" href="https://www.linkedin.com/in/fredericbasse" target="_blank"><i class="fa fa-linkedin"></i></a></li>
        <li><a class="sc-rss" href="/feeds/all.atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>
    </div>


  </aside>
  <main>

    <nav>
      <a href="https://fredericb.info/">    Home
</a>

      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>

      <a href="https://fredericb.info/feeds/all.atom.xml">    Atom
</a>

    </nav>

<article class="single">
  <header>
      
    <h1 id="reverse-engineer-usb-stack-of-exynos-bootrom">Reverse engineer USB stack of Exynos BootROM</h1>
    <p>
          Posted on Tue 16 June 2020 in <a href="https://fredericb.info/category/article.html">Article</a>


    </p>
  </header>


  <div>
    <p>In the previous post, we explained how to <a href="https://fredericb.info/2020/06/exynos8890-bootrom-dump-dump-exynos-8890-bootrom-from-samsung-galaxy-s7.html">dump Exynos bootROM</a>.</p>
<p>Exynos (8895 in this post) bootROM contains a minimal USB stack to load a signed bootloader from an USB host (a.k.a. boot from USB). 
This post summarizes how this USB stack can be reversed using the Great Tool <a href="https://ghidra-sre.org/">Ghidra</a> and <a href="https://opensource.samsung.com/">Linux kernel source code</a>.</p>
<p>The goal is to locate and analyze the proprietary USB protocol used to load the bootloader in RAM.</p>
<p><img alt="Catch the dragon" src="https://fredericb.info/blog/exy-bootrom/CatchTheDragon.png" width="800px"></p>
<h1>SoC level</h1>
<p>Device Tree Source files in Linux kernel provide a detailed description (like physical address and size) of Exynos SoC peripherals, including the USB controller. In file <em>arch/arm64/boot/dts/exynos/exynos8895.dtsi</em>, we learn that the USB controller is mapped at <strong>0x10C00000</strong> (also known as base address):</p>
<p><img alt="USB controller in DTSI" src="https://fredericb.info/blog/exy-bootrom/dwc3Dtsi.png"></p>
<p>Ghidra <em>Memory Map</em> feature allows us to create a memory block that represents this USB peripheral :</p>
<p><img alt="Memory map in Ghidra" src="https://fredericb.info/blog/exy-bootrom/bootromMemMap.png"></p>
<p>Don't forget to click <strong>Analysis&gt;Auto Analyze</strong> to update cross references to our new memory block.</p>
<h1>Peripheral level</h1>
<p>The Linux kernel also contains a list of registers and their offset to interact with the USB controller :</p>
<p><img alt="USB registers in kernel" src="https://fredericb.info/blog/exy-bootrom/dwc3Regs.png"></p>
<p>Register offsets are relative to the base address mentioned earlier.
Based on this list, we can rename each USB register referenced from the bootROM code (<strong>Navigation-&gt;Next Data</strong>) :</p>
<p><img alt="Xrefs to USB registers in Ghidra" src="https://fredericb.info/blog/exy-bootrom/regsXrefs2.png"></p>
<p>Adding names will help us to understand the purpose of functions that access these registers.</p>
<h1>Driver level</h1>
<p>BootROM functions that access USB registers directly are dedicated to USB operations. They are similar to the Linux USB driver code, but simplified since bootROM is bare metal code, without interrupt handlers, threads or even dynamic memory allocation.</p>
<p>Despite the lack of public documentation, we can study the Linux USB driver code to understand the purpose of most important USB registers.</p>
<p>With a better understanding of these registers, we can now infer the purpose of bootROM functions based on read/write operations they perform on these registers. In some cases, bootROM and Linux USB driver functions have such similar access patterns (to USB registers) that they can be quickly identified by comparison.</p>
<h2>USB enumeration and configurration</h2>
<p>Per USB specifications, when a new device is attached, USB host assigns it an unique address by sending the <em>Standard Device Request</em> <strong>USB_REQ_SET_ADDRESS</strong>. Device must then set its assigned address by writing it to register <strong>DWC3_DCFG</strong>. And thanks to the Linux USB driver, we even know that device address is a 7-bit value at offset 3 in this register.</p>
<p>By looking at references to <strong>DWC3_DCFG</strong> in Ghidra, we can locate bootROM functions that access this register :</p>
<p><img alt="USB controller in DTSI" src="https://fredericb.info/blog/exy-bootrom/dwc3DCFG.png"></p>
<p>Among these functions, only <em>write_DWC3_DCFG_DEVADDR</em> sets device address in <strong>DWC3_DCFG</strong> register :</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">write_DWC3_DCFG_DEVADDR</span><span class="p">(</span><span class="n">uint</span> <span class="n">devaddr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">uint</span> <span class="n">uVar1</span><span class="p">;</span>

  <span class="n">uVar1</span> <span class="o">=</span> <span class="n">cRead_4</span><span class="p">(</span><span class="n">DWC3_DCFG</span><span class="p">);</span>
  <span class="n">cWrite_4</span><span class="p">(</span><span class="n">DWC3_DCFG</span><span class="p">,</span><span class="n">uVar1</span> <span class="o">&amp;</span> <span class="mh">0xfffffc00</span> <span class="o">|</span> <span class="n">uVar1</span> <span class="o">&amp;</span> <span class="mi">7</span> <span class="o">|</span> <span class="p">(</span><span class="n">devaddr</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span><span class="c1">// DWC3_DCFG[3:7] : device address</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>By exploring incoming function calls to <em>write_DWC3_DCFG_DEVADDR</em>, we can easily locate the function that handles all incoming <em>Standard Device Requests</em> :</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">usb_handle_standard_device_request</span><span class="p">(</span><span class="n">longlong</span> <span class="n">param_1</span><span class="p">,</span><span class="n">uint</span> <span class="o">*</span><span class="n">param_2</span><span class="p">)</span>

<span class="p">{</span>
  <span class="c1">//[...]</span>
  <span class="n">bRequest</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">param_1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bRequest</span> <span class="o">==</span> <span class="n">USB_REQ_SET_ADDRESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">write_DWC3_DCFG_DEVADDR</span><span class="p">((</span><span class="n">ulonglong</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)(</span><span class="n">param_1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span><span class="c1">//set device address assigned by USB host</span>
    <span class="o">*</span><span class="p">(</span><span class="n">undefined4</span> <span class="o">*</span><span class="p">)(</span><span class="n">puVar3</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="o">*</span><span class="n">param_2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bRequest</span> <span class="o">==</span> <span class="n">USB_REQ_GET_DESCRIPTOR</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">descriptorType</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">param_1</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">descriptorType</span> <span class="o">==</span> <span class="n">USB_DT_DEVICE</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">usb_init_device_descriptor</span><span class="p">(</span><span class="n">sUSBBuffers_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">event_buffer</span> <span class="o">+</span> <span class="mh">0x70</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="mh">0x12</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">param_2</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">param_2</span> <span class="o">=</span> <span class="mh">0x12</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">descriptorType</span> <span class="o">==</span> <span class="n">USB_DT_CONFIG</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">puVar2</span> <span class="o">=</span> <span class="n">USBBuffers_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">usb_init_descriptors</span><span class="p">(</span><span class="n">puVar2</span><span class="o">-&gt;</span><span class="n">event_buffer</span> <span class="o">+</span> <span class="mh">0x70</span><span class="p">);</span>
  <span class="c1">//[...]</span>
<span class="p">}</span>
</pre></div>


<p>Among all <em>Standard Device Requests</em> sent during USB enumeration phase, <strong>USB_REQ_GET_DESCRIPTOR</strong> is another interesting one.</p>
<p>USB descriptors are sent to USB host in order to describe device, interface &amp; endpoints implemented by the device. These structures are part of the USB standard, so we can simply import structure definitions (struct USB_DESCRIPTORS &amp; USB_DEVICE_DESCRIPTOR) from Linux kernel in Ghidra (<strong>File-&gt;Parse C source...</strong>) :</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">usb_init_device_descriptor</span><span class="p">(</span><span class="n">USB_DEVICE_DESCRIPTOR</span> <span class="o">*</span><span class="n">param_1</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">bLength</span> <span class="o">=</span> <span class="mh">0x12</span><span class="p">;</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// USB_DT_DEVICE</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">bcdUSBL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">bcdUSBH</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">bDeviceClass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">bDeviceSubClass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">bDeviceProtocol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">bMaxPacketSize0</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span><span class="p">)</span><span class="n">DAT_02021544</span><span class="p">;</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">idVendorL</span> <span class="o">=</span> <span class="mh">0xe8</span><span class="p">;</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">idVendorH</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// VENDOR ID 0x04E8</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">idProductL</span> <span class="o">=</span> <span class="mh">0x34</span><span class="p">;</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">idProductH</span> <span class="o">=</span> <span class="mh">0x12</span><span class="p">;</span> <span class="c1">//PRODUCT ID 0x1234</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">bcdDeviceL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">bcdDeviceH</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">iManufacturer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">iProduct</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">iSerialNumber</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="n">param_1</span><span class="o">-&gt;</span><span class="n">bNumConfigurations</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">usb_init_descriptors</span><span class="p">(</span><span class="n">USB_DESCRIPTORS</span> <span class="o">*</span><span class="n">param_1</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">byte</span> <span class="n">bVar1</span><span class="p">;</span>
  <span class="n">byte</span> <span class="n">bVar2</span><span class="p">;</span>
  <span class="n">undefined4</span> <span class="n">uVar3</span><span class="p">;</span>

  <span class="n">uVar3</span> <span class="o">=</span> <span class="n">DAT_02021548</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescConfig</span><span class="p">).</span><span class="n">bLength</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescConfig</span><span class="p">).</span><span class="n">bDescriptorType</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// USB_DT_CONFIG</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescConfig</span><span class="p">).</span><span class="n">wTotalLengthL</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescConfig</span><span class="p">).</span><span class="n">wTotalLengthH</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescConfig</span><span class="p">).</span><span class="n">bNumInterfaces</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescConfig</span><span class="p">).</span><span class="n">bConfigurationValue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescConfig</span><span class="p">).</span><span class="n">iConfiguration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescConfig</span><span class="p">).</span><span class="n">bmAttributes</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescConfig</span><span class="p">).</span><span class="n">maxPower</span> <span class="o">=</span> <span class="mh">0xfa</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescInterface</span><span class="p">).</span><span class="n">bLength</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescInterface</span><span class="p">).</span><span class="n">bDescriptorType</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// USB_DT_INTERFACE</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescInterface</span><span class="p">).</span><span class="n">bInterfaceNumber</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescInterface</span><span class="p">).</span><span class="n">bAlternateSetting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescInterface</span><span class="p">).</span><span class="n">bNumEndpoints</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescInterface</span><span class="p">).</span><span class="n">bInterfaceClass</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span> <span class="c1">// USB_CLASS_VENDOR_SPEC</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescInterface</span><span class="p">).</span><span class="n">bInterfaceSubClass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescInterface</span><span class="p">).</span><span class="n">bInterfaceProtocol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescInterface</span><span class="p">).</span><span class="n">iInterface</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescEp0</span><span class="p">).</span><span class="n">bLength</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescEp0</span><span class="p">).</span><span class="n">bDescriptorType</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// USB_DT_ENDPOINT</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescEp0</span><span class="p">).</span><span class="n">bEndpointAddress</span> <span class="o">=</span> <span class="mh">0x81</span><span class="p">;</span> <span class="c1">// USB_DIR_IN | 1 : endpoint 1, direction IN</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescEp0</span><span class="p">).</span><span class="n">bmAttributes</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// USB_ENDPOINT_XFER_BULK</span>
  <span class="n">bVar1</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span><span class="p">)</span><span class="n">uVar3</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescEp0</span><span class="p">).</span><span class="n">wMaxPacketSizeL</span> <span class="o">=</span> <span class="n">bVar1</span><span class="p">;</span>
  <span class="n">bVar2</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span><span class="p">)((</span><span class="n">uint</span><span class="p">)</span><span class="n">uVar3</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescEp0</span><span class="p">).</span><span class="n">wMaxPacketSizeH</span> <span class="o">=</span> <span class="n">bVar2</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescEp0</span><span class="p">).</span><span class="n">bInterval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescEp1</span><span class="p">).</span><span class="n">bLength</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescEp1</span><span class="p">).</span><span class="n">bDescriptorType</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// USB_DT_ENDPOINT</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescEp1</span><span class="p">).</span><span class="n">bEndpointAddress</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// USB_DIR_OUT | 2 : endpoint 2, direction OUT</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescEp1</span><span class="p">).</span><span class="n">bmAttributes</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// USB_ENDPOINT_XFER_BULK</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescEp1</span><span class="p">).</span><span class="n">wMaxPacketSizeL</span> <span class="o">=</span> <span class="n">bVar1</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescEp1</span><span class="p">).</span><span class="n">wMaxPacketSizeH</span> <span class="o">=</span> <span class="n">bVar2</span><span class="p">;</span>
  <span class="p">(</span><span class="n">param_1</span><span class="o">-&gt;</span><span class="n">oDescEp1</span><span class="p">).</span><span class="n">bInterval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Among the important details in these descriptors, we can learn that this code implements :</p>
<ul>
<li><strong>1 device</strong> : vendor ID = 0x04E8, product ID = 0x1234.</li>
<li><strong>1 interface</strong> of vendor-specific class, which means protocol is likely proprietary.</li>
<li><strong>2 bulk endpoints</strong> : endpoint 1 for BULK IN transfers, endpoint 2 for BULK OUT transfers.</li>
</ul>
<h2>Event buffer setup</h2>
<p>During USB initialization, USB driver allocates a buffer called <em>event buffer</em> and informs USB controller by writing its address and size into registers <strong>DWC3_GEVNTADRLO</strong>, <strong>DWC3_GEVNTADRHI</strong>, <strong>DWC3_GEVNTSIZ</strong>. Once setup, USB controller can write events intended for USB driver into this shared buffer.</p>
<p>In Linux kernel, these registers are accessed by a single function <em>dwc3_event_buffers_setup</em>, called once during USB driver initialization. In bootROM code, event buffer is setup in the same way :</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">usb_setup_event_buffer</span><span class="p">(</span><span class="n">dword</span> <span class="n">bufferHigh</span><span class="p">,</span><span class="n">dword</span> <span class="n">bufferLow</span><span class="p">,</span><span class="n">ushort</span> <span class="n">bufferSize</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">uint</span> <span class="n">local_14</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">uVar1</span><span class="p">;</span>

  <span class="n">cWrite_4</span><span class="p">(</span><span class="n">DWC3_GEVNTADRHI</span><span class="p">,</span><span class="n">bufferHigh</span><span class="p">);</span>
  <span class="n">cWrite_4</span><span class="p">(</span><span class="n">DWC3_GEVNTADRLO</span><span class="p">,</span><span class="n">bufferLow</span><span class="p">);</span>
  <span class="n">uVar1</span> <span class="o">=</span> <span class="n">cRead_4</span><span class="p">(</span><span class="n">DWC3_GEVNTSIZ</span><span class="p">);</span>
  <span class="n">local_14</span> <span class="o">=</span> <span class="n">uVar1</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span> <span class="o">|</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="n">bufferSize</span><span class="p">;</span>
  <span class="n">cWrite_4</span><span class="p">(</span><span class="n">DWC3_GEVNTSIZ</span><span class="p">,</span><span class="n">local_14</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Events written to this buffer are 32-bit values with different structures depending on their type : either device or endpoint event. These structures, defined in the Linux kernel, can be imported into Ghidra to facilitate the reversing process.</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">dwc3_event_depevt</span> <span class="p">{</span><span class="c1">// Device Endpoint Events</span>
    <span class="n">u32</span> <span class="nl">one_bit</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span><span class="c1">// not used</span>
    <span class="n">u32</span> <span class="nl">endpoint_number</span><span class="p">:</span><span class="mi">5</span><span class="p">;</span><span class="c1">// number of the endpoint</span>
    <span class="n">u32</span> <span class="nl">endpoint_event</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span><span class="c1">// event type</span>
    <span class="n">u32</span> <span class="nl">reserved11_10</span><span class="p">:</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">u32</span> <span class="nl">status</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span><span class="c1">// Indicates the status of the event</span>
    <span class="n">u32</span> <span class="nl">parameters</span><span class="p">:</span><span class="mi">16</span><span class="p">;</span><span class="c1">// Parameters of the current event</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">dwc3_event_devt</span> <span class="p">{</span><span class="c1">// Device Events</span>
    <span class="n">u32</span> <span class="nl">is_devspec</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span><span class="c1">// indicates this is a non-endpoint event (device-specific)</span>
    <span class="n">u32</span> <span class="nl">device_event</span><span class="p">:</span><span class="mi">7</span><span class="p">;</span><span class="c1">// indicates it&#39;s a device event</span>
    <span class="n">u32</span> <span class="nl">type</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span><span class="c1">// type of device event</span>
    <span class="n">u32</span> <span class="nl">reserved15_12</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span>
    <span class="n">u32</span> <span class="nl">event_info</span><span class="p">:</span><span class="mi">9</span><span class="p">;</span><span class="c1">// Information about this event</span>
    <span class="n">u32</span> <span class="nl">reserved31_25</span><span class="p">:</span><span class="mi">7</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>
</pre></div>


<h2>USB events count</h2>
<p>Register <strong>DWC3_GEVNTCOUNT</strong> (updated by USB controller) contains the count of events pending in event buffer. BootROM code implements a simple function (named <em>read_DWC3_GEVNTCOUNT</em> here) to read this register :</p>
<div class="highlight"><pre><span></span><span class="n">uint</span> <span class="nf">read_DWC3_GEVNTCOUNT</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">uint</span> <span class="n">eventCnt</span><span class="p">;</span>

  <span class="n">eventCnt</span> <span class="o">=</span> <span class="n">cRead_4</span><span class="p">(</span><span class="n">DWC3_GEVNTCOUNT</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">uint</span><span class="p">)(</span><span class="kt">int</span><span class="p">)(</span><span class="kt">short</span><span class="p">)(</span><span class="n">eventCnt</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Again, we located that function by looking at references to <strong>DWC3_GEVNTCOUNT</strong> register.</p>
<h2>USB event handler</h2>
<p>By inspecting incoming function calls in Ghidra, we can now easily locate the main function that processes USB events :</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">usb_event_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">dwc3_event</span> <span class="n">evt</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">evtCnt</span><span class="p">;</span>

  <span class="n">evtCnt</span> <span class="o">=</span> <span class="n">read_DWC3_GEVNTCOUNT</span><span class="p">();</span><span class="c1">//read pending events count from DWC3_GEVNTCOUNT register</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">evtCnt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">evtCnt</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// loop while pending events available</span>
      <span class="n">evt</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">USBBuffers_ptr</span><span class="o">-&gt;</span><span class="n">event_buffer</span> <span class="o">+</span> <span class="n">usbEventIdx</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// read event from event buffer</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">evt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">evt</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="c1">// evt.is_devspec == 0 : event is endpoint-specific</span>
          <span class="n">epNum</span> <span class="o">=</span> <span class="n">evt</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span><span class="c1">// extract endpoint_number from event</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">epNum</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span><span class="c1">// endpoint 0 (bit 0 of endpoint_number is direction: 0=&gt;OUT, 1=&gt;IN)</span>
            <span class="n">usb_handle_ep0_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">evt</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span><span class="c1">//other endpoints</span>
            <span class="n">usb_handle_ep_event</span><span class="p">((</span><span class="n">ulonglong</span><span class="p">)(</span><span class="n">epNum</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">),(</span><span class="n">ulonglong</span><span class="p">)(</span><span class="n">evt</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">));</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span><span class="c1">// evt.is_devspec == 1 : event is device-specific</span>
          <span class="k">if</span> <span class="p">((</span><span class="n">evt</span> <span class="o">&amp;</span> <span class="mh">0xfe</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">usb_handle_device_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">evt</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">usbEventIdx</span> <span class="o">=</span> <span class="n">usbEventIdx</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
      <span class="n">write_DWC3_GEVNTCOUNT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="n">evtCnt</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Instead of relying on interrupts like in Linux driver, this handler implements a polling loop to check for new events in event buffer. Then, events are dispatched to three different functions depending on their type :</p>
<ul>
<li><em>usb_handle_device_event</em> : device-level events like (dis)connect USB cable, reset, link status change,...</li>
<li><em>usb_handle_ep0_event</em> : default control endpoint 0 to enumerate &amp; configure device</li>
<li><em>usb_handle_ep_event</em> : dispatch events related to other endpoints, including bulk endpoints</li>
</ul>
<p>The latter <em>usb_handle_ep_event</em> is the one we're interested in, because it handles data received from USB host (i.e. bootloader image).
In this function, a dispatch table calls a handler specific to each endpoint number. The only implemented handler in this table is for endpoint 2.
Based on configuration descriptors detailed above, we can confirm that endpoint 2 is for BULK OUT (host to device) transfers.</p>
<h2>Transfer Request Blocks</h2>
<p>Events described in the previous sections are only 32-bit values, they don't contain payload data. Actual data transfers are setup using <strong>Transfer Request Blocks</strong> (TRB)</p>
<p>A TRB is a structure that directs the USB controller where to write (or read, depending on endpoint direction) data for the next transfer on a specific endpoint.
The buffer has to be DMA coherent memory directly accessible by both main CPU and USB controller.</p>
<div class="highlight"><pre><span></span><span class="cm">/** struct dwc3_trb - transfer request block (hw format) */</span>
<span class="k">struct</span> <span class="n">dwc3_trb</span> <span class="p">{</span>
    <span class="n">u32</span>     <span class="n">bpl</span><span class="p">;</span><span class="c1">// buffer pointer (low)</span>
    <span class="n">u32</span>     <span class="n">bph</span><span class="p">;</span><span class="c1">// buffer pointer (high)</span>
    <span class="n">u32</span>     <span class="n">size</span><span class="p">;</span><span class="c1">// buffer len</span>
    <span class="n">u32</span>     <span class="n">ctrl</span><span class="p">;</span><span class="c1">// control bitfield</span>
<span class="p">};</span>
</pre></div>


<p>Linux driver function <em>dwc3_ep0_start_trans</em> is a good example of how to initiate a data transfer using a TRB :</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">dwc3_ep0_start_trans</span><span class="p">(</span><span class="k">struct</span> <span class="n">dwc3</span> <span class="o">*</span><span class="n">dwc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">epnum</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">buf_dma</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="n">u32</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">dwc3_gadget_ep_cmd_params</span> <span class="n">params</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">dwc3_trb</span>         <span class="o">*</span><span class="n">trb</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">dwc3_ep</span>          <span class="o">*</span><span class="n">dep</span><span class="p">;</span>

    <span class="n">dep</span> <span class="o">=</span> <span class="n">dwc</span><span class="o">-&gt;</span><span class="n">eps</span><span class="p">[</span><span class="n">epnum</span><span class="p">];</span>

    <span class="n">trb</span> <span class="o">=</span> <span class="n">dwc</span><span class="o">-&gt;</span><span class="n">ep0_trb</span><span class="p">;</span>

    <span class="n">trb</span><span class="o">-&gt;</span><span class="n">bpl</span> <span class="o">=</span> <span class="n">lower_32_bits</span><span class="p">(</span><span class="n">buf_dma</span><span class="p">);</span>
    <span class="n">trb</span><span class="o">-&gt;</span><span class="n">bph</span> <span class="o">=</span> <span class="n">upper_32_bits</span><span class="p">(</span><span class="n">buf_dma</span><span class="p">);</span>
    <span class="n">trb</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">trb</span><span class="o">-&gt;</span><span class="n">ctrl</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>

<span class="p">[...]</span>

    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">params</span><span class="p">));</span>
    <span class="n">params</span><span class="p">.</span><span class="n">param0</span> <span class="o">=</span> <span class="n">upper_32_bits</span><span class="p">(</span><span class="n">dwc</span><span class="o">-&gt;</span><span class="n">ep0_trb_addr</span><span class="p">);</span>
    <span class="n">params</span><span class="p">.</span><span class="n">param1</span> <span class="o">=</span> <span class="n">lower_32_bits</span><span class="p">(</span><span class="n">dwc</span><span class="o">-&gt;</span><span class="n">ep0_trb_addr</span><span class="p">);</span>

    <span class="n">dwc3_send_gadget_ep_cmd</span><span class="p">(</span><span class="n">dwc</span><span class="p">,</span> <span class="n">dep</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">DWC3_DEPCMD_STARTTRANSFER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">);</span>
<span class="p">[...]</span>
<span class="p">}</span>
</pre></div>


<p>First, <strong>trb</strong> structure is filled using buffer address and its size provided in function parameters. Then, <strong>DWC3_DEPCMD_STARTTRANSFER</strong> command is issued to USB controller with TRB pointer and endpoint number as arguments.</p>
<p>Back to bootROM code, identifying where TRBs are set is an important step towards our goal. It can lead us to buffers (corresponding to <em>buf_dma</em> here) used for data transfers. Among them, we're especially interested in those used for endpoint 2 (BULK OUT), because they are read back by the code we're ultimately interested in : vendor-specific protocol handlers.</p>
<p>Again, we rely on hardware register accesses performed by <em>dwc3_send_gadget_ep_cmd</em> to locate bootROM functions that can send command <strong>DWC3_DEPCMD_STARTTRANSFER</strong>.</p>
<h2>Send USB command</h2>
<p>In Linux driver, the function to send USB commands <em>dwc3_send_gadget_ep_cmd</em> is the only one to access registers <strong>DWC3_DEPCMDPAR0</strong>, <strong>DWC3_DEPCMDPAR1</strong>, <strong>DWC3_DEPCMDPAR2</strong>, <strong>DWC3_DEPCMD</strong>. And so it is with bootROM. By comparing both, we can deduce the bootROM function prototype :</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">usb_send_command</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">endpointNumber</span><span class="p">,</span> <span class="n">DWC3_DEPCMD_e</span> <span class="n">command</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">param0</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">param1</span><span class="p">);</span>
</pre></div>


<p>Here's the list of commands defined in Linux driver code :</p>
<div class="highlight"><pre><span></span><span class="cm">/* Device Endpoint Command Register */</span>
<span class="cp">#define DWC3_DEPCMD_DEPSTARTCFG     (0x09 &lt;&lt; 0)</span>
<span class="cp">#define DWC3_DEPCMD_ENDTRANSFER     (0x08 &lt;&lt; 0)</span>
<span class="cp">#define DWC3_DEPCMD_UPDATETRANSFER  (0x07 &lt;&lt; 0)</span>
<span class="cp">#define DWC3_DEPCMD_STARTTRANSFER   (0x06 &lt;&lt; 0)</span>
<span class="cp">#define DWC3_DEPCMD_CLEARSTALL      (0x05 &lt;&lt; 0)</span>
<span class="cp">#define DWC3_DEPCMD_SETSTALL        (0x04 &lt;&lt; 0)</span>
<span class="cp">#define DWC3_DEPCMD_GETSEQNUMBER    (0x03 &lt;&lt; 0)</span>
<span class="cp">#define DWC3_DEPCMD_GETEPSTATE      (0x03 &lt;&lt; 0)</span>
<span class="cp">#define DWC3_DEPCMD_SETTRANSFRESOURCE   (0x02 &lt;&lt; 0)</span>
<span class="cp">#define DWC3_DEPCMD_SETEPCONFIG     (0x01 &lt;&lt; 0)</span>
</pre></div>


<p>From there, we can explore all incoming function calls to <em>usb_send_command</em> and use the command argument as hint to ease the reversing.</p>
<p>As explained in previous section, we're especially interested in finding calls with command argument <strong>DWC3_DEPCMD_STARTTRANSFER</strong>, because they setup the TRB for a specific endpoint. In case of endpoint 2 (BULK OUT), the TRB contains the buffer address where data received from USB host will be written to.</p>
<p>With these last bits, we now have enough information to move on to the next level, our initial goal.</p>
<h1>Protocol level</h1>
<p>In previous sections, we collected the following information :</p>
<ul>
<li>interface configuration : USB interface class <em>bInterfaceClass</em> is vendor-specific (0xff)</li>
<li>endpoint configuration : endpoint 2 (BULK OUT) is expected to receive data.</li>
<li>TRB setup for transfer buffer : we know where received data is stored.</li>
<li>endpoint handlers : we identified the handler function for each endpoint.</li>
</ul>
<p>The vendor-specific interface class indicates that endpoint handler implements a proprietary protocol. Fortunately, a very simple protocol designed to download a bootloader from USB host.</p>
<p>The bootloader is encapsulated in a small structure <em>dldata_s</em>, and sent through USB bulk transfers of 512 bytes. Maximum data size is 321536 bytes.</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">dldata_s</span> <span class="p">{</span>
    <span class="n">u_int32_t</span> <span class="n">unknown0</span><span class="p">;</span>
    <span class="n">u_int32_t</span> <span class="n">size</span><span class="p">;</span><span class="c1">// header(8) + data(n) + footer(2)</span>
    <span class="n">u_int8_t</span>  <span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="n">u_int16_t</span> <span class="n">unknown1</span><span class="p">;</span><span class="c1">//footer</span>
<span class="p">};</span>
</pre></div>


<h1>Conclusion</h1>
<p>Despite the lack of documentation for the USB controller, we extracted enough technical information from Linux kernel drivers to reverse engineer USB stack implemented in Exynos bootROM. We concluded that this stack implements a single, proprietary interface to download a bootloader from USB host.</p>
<p>As a side note, the bootROM code we analyzed doesn't implement any mitigation technique. Probably because, at such early boot stage, performance is critical, MMU is disabled, and entropy is hard.</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="https://fredericb.info/tag/arm.html">arm</a>
      <a href="https://fredericb.info/tag/exynos.html">exynos</a>
      <a href="https://fredericb.info/tag/samsung.html">samsung</a>
      <a href="https://fredericb.info/tag/bootrom.html">bootrom</a>
      <a href="https://fredericb.info/tag/usb.html">usb</a>
      <a href="https://fredericb.info/tag/reverse.html">reverse</a>
      <a href="https://fredericb.info/tag/ghidra.html">ghidra</a>
    </p>
  </div>



    <div class="addthis_relatedposts_inline">


</article>

    <footer>
<p>
  &copy;   - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>    Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - Theme <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a>
</p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " fred's notes ",
  "url" : "https://fredericb.info",
  "image": "/resources/sitelogo.jpg",
  "description": "Frédéric's Thoughts and Writings"
}
</script>

</body>
</html>